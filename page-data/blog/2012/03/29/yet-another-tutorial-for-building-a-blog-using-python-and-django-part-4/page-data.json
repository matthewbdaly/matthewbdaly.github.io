{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2012/03/29/yet-another-tutorial-for-building-a-blog-using-python-and-django-part-4/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"4dba2747-3fb7-52f4-8f08-06f4826e2716","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"date\": \"2012-03-29 21:29:59\",\n  \"layout\": \"post\",\n  \"slug\": \"yet-another-tutorial-for-building-a-blog-using-python-and-django-part-4\",\n  \"status\": \"publish\",\n  \"title\": \"Yet another tutorial for building a blog using Python and Django - part 4\",\n  \"wordpress_id\": \"780\",\n  \"categories\": [\"django\", \"python\", \"webdevelopment\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Welcome back! In this tutorial we'll continue extending our Django-powered blogging engine. We'll add the capability to assign blog posts to categories, and comment on posts. We'll also generate an RSS feed for our blog posts.\"), mdx(\"p\", null, \"Categories are somewhat tougher to implement than most of what we've done beforehand. One category can be assigned to many blog posts, and many categories can be assigned to one blog post, so this relationship is described as a \\\"many to many relationship\\\" when drawing up the database structure. What it means is that you can't directly map categories onto posts and vice versa - you have to create an intermediate database table for the relationship between posts and categories.\"), mdx(\"p\", null, \"Here's what your models.py should look like:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from django.db import models \\nfrom django.contrib.auth.models import User\\n\\n# Create your models here. \\nclass Category(models.Model): \\n    title = models.CharField(max_length=200) \\n    slug = models.SlugField(max_length=40, unique=True) \\n    description = models.TextField() \\n \\n    class Meta: \\n        verbose_name_plural = \\\"Categories\\\" \\n \\n    def __unicode__(self): \\n        return self.title\\n\\n    def get_absolute_url(self):\\n        return \\\"/categories/%s/\\\" % self.slug\\n\\nclass Post(models.Model):\\n    title = models.CharField(max_length=200)\\n    pub_date = models.DateTimeField()\\n    text = models.TextField()\\n    slug = models.SlugField(max_length=40, unique=True)\\n    author = models.ForeignKey(User)\\n    categories = models.ManyToManyField(Category, blank=True, null=True, through='CategoryToPost')\\n\\n    def __unicode__(self):\\n        return self.title\\n\\n    def get_absolute_url(self):\\n        return \\\"/%s/%s/%s/\\\" % (self.pub_date.year, self.pub_date.month, self.slug)\\n\\nclass CategoryToPost(models.Model):\\n    post = models.ForeignKey(Post)\\n    category = models.ForeignKey(Category)\\n\")), mdx(\"p\", null, \"We're adding quite a bit of new code here. First of all we're defining a new model called Category. Each category has a title, a description, and a slug (so we can have a dedicated page for each category). As usual, we define methods for \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"unicode\"), \" and get_absolute_url, but also note the class Meta. Here we're defining some metadata for the class (ie, data about the data). The only thing we do here is essentially telling the admin interface that the plural of Category is not \\\"Categorys\\\" but \\\"Categories\\\".\"), mdx(\"p\", null, \"Then, in Post we add an additional field called Category, which we define as a ManyToManyField. Note the parameters passed through - we're saying here that a post need not be assigned a category, and that CategoryToPost should be used as an intermediate table to link posts to categories.\"), mdx(\"p\", null, \"Finally, we define the aforementioned CategoryToPost model, which has two fields, post and category. Both of these are foreign keys, mapping to a blog post and a category respectively. By creating entries in this table, a link can be created between a post and a category.\"), mdx(\"p\", null, \"With our model changed, it's time to update our admin.py as well:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"import models\\nfrom django.contrib import admin\\nfrom django.contrib.auth.models import User\\n\\nclass CategoryAdmin(admin.ModelAdmin):\\n    prepopulated_fields = {\\\"slug\\\": (\\\"title\\\",)}\\n\\nclass CategoryToPostInline(admin.TabularInline):\\n    model = models.CategoryToPost\\n    extra = 1 \\n\\nclass PostAdmin(admin.ModelAdmin):\\n    prepopulated_fields = {\\\"slug\\\": (\\\"title\\\",)}\\n    exclude = ('author',)\\n    inlines = [CategoryToPostInline]\\n\\n    def save_model(self, request, obj, form, change):\\n        obj.author = request.user\\n        obj.save()\\n\\nadmin.site.register(models.Post, PostAdmin)\\nadmin.site.register(models.Category, CategoryAdmin)\\n\")), mdx(\"p\", null, \"Here we define a new class called CategoryAdmin, which details how we're changing the admin interface for Category from the defaults generated from the fields provided. The only change we make here is that we prepopulate the slug field from the title, much like we did with blog posts.\"), mdx(\"p\", null, \"Next, we define an inline for the relationships between categories and post, called CategoryToPostInline. This is a new concept - essentially it means that the category to post relationships can be defined in another model's admin interface. We define the model this applies to, and that by default we will only add one additional field for adding categories when writing or editing a post (though users can add as many as they wish, or none). Note that the model this is based on is admin.TabularInline - this represents a tabular layout. If you prefer, you can use an alternative layout by using StackedInline instead.\"), mdx(\"p\", null, \"Then, in PostAdmin we add our newly declared CategoryToPostInline to the PostAdmin class as an inline. Finally, at the bottom we register Category with the admin interface, so we can create and manage categories easily.\"), mdx(\"p\", null, \"With that done, it's time to edit our views.py:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"# Create your views here.\\nfrom django.shortcuts import render_to_response\\nfrom django.core.paginator import Paginator, EmptyPage\\nfrom blogengine.models import Post, Category\\n\\ndef getPosts(request, selected_page=1):\\n    # Get all blog posts\\n    posts = Post.objects.all().order_by('-pub_date')\\n\\n    # Add pagination\\n    pages = Paginator(posts, 5)\\n\\n    # Get the specified page\\n    try:\\n        returned_page = pages.page(selected_page)\\n    except EmptyPage:\\n        returned_page = pages.page(pages.num_pages)\\n\\n    # Display all the posts\\n    return render_to_response('posts.html', { 'posts':returned_page.object_list, 'page':returned_page})\\n\\ndef getPost(request, postSlug):\\n    # Get specified post\\n    post = Post.objects.filter(slug=postSlug)\\n\\n    # Display specified post\\n    return render_to_response('single.html', { 'posts':post})\\n\\ndef getCategory(request, categorySlug, selected_page=1):\\n    # Get specified category\\n    posts = Post.objects.all().order_by('-pub_date')\\n    category_posts = []\\n    for post in posts:\\n        if post.categories.filter(slug=categorySlug):\\n            category_posts.append(post)\\n\\n    # Add pagination\\n    pages = Paginator(category_posts, 5)\\n\\n    # Get the category\\n    category = Category.objects.filter(slug=categorySlug)[0]\\n\\n    # Get the specified page\\n    try:\\n        returned_page = pages.page(selected_page)\\n    except EmptyPage:\\n        returned_page = pages.page(pages.num_pages)\\n\\n    # Display all the posts\\n    return render_to_response('category.html', { 'posts': returned_page.object_list, 'page': returned_page, 'category': category})\\n\")), mdx(\"p\", null, \"Here we import the Category model as well as the Post model. Then, the only additional change we need to make is to add a brand new getCategory view function. Note that this is quite similar to the getPosts function - we set up pagination in the same way, and rather than get all the posts, we get just those in the specified category. Also note that we're using the template category.html rather than posts.html here, and we pass through category as well as posts and page when we return the render_to_response.\"), mdx(\"p\", null, \"The next change we need to make is adding category.html. Go into your template directory and save the code below as category.html:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-django\"\n  }, \"{% include 'header.html' %}\\n        <h1>Posts for {{ category.title }}</h1>\\n        {% if posts %}\\n        {% for post in posts %}\\n        <h1><a href=\\\"{{ post.get_absolute_url }}\\\">{{ post.title }}</a></h1>\\n        {{ post.text }}\\n        {% endfor %}\\n        <br />\\n        {% if page.has_previous %}\\n        <a href=\\\"/{{ page.previous_page_number }}/\\\">Previous Page</a>\\n        {% endif %}\\n        {% if page.has_next %}\\n        <a href=\\\"/{{ page.next_page_number }}/\\\">Next Page</a>\\n        {% endif %}\\n        {% else %}\\n        <p>No posts matched</p>\\n        {% endif %}\\n{% include 'footer.html' %}\\n\")), mdx(\"p\", null, \"With our template in place, the last step is to add an appropriate URLconf. Edit urls.py to look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from django.conf.urls.defaults import patterns, include, url \\n\\n# Uncomment the next two lines to enable the admin:\\nfrom django.contrib import admin\\nadmin.autodiscover()\\n\\nurlpatterns = patterns('',\\n    # Examples:\\n    # url(r'^$', 'blog.views.home', name='home'),\\n    # url(r'^blog/', include('blog.foo.urls')),\\n\\n    # Uncomment the admin/doc line below to enable admin documentation:\\n    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),\\n\\n    # Uncomment the next line to enable the admin:\\n    url(r'^admin/', include(admin.site.urls)),\\n\\n    # Home page\\n    url(r'^$', 'blogengine.views.getPosts'),\\n    url(r'^(?P<selected_page>\\\\d+)/?$', 'blogengine.views.getPosts'),\\n\\n    # Blog posts\\n    url(r'^\\\\d{4}/\\\\d{1,2}/(?P[-a-zA-Z0-9]+)/?$', 'blogengine.views.getPost'),\\n\\n    # Categories\\n    url(r'^categories/(?P<categorySlug>\\\\w+)/?$', 'blogengine.views.getCategory'),\\n    url(r'^categories/(?P<categorySlug>\\\\w+)/(?P<selected_page>\\\\d+)/?$', 'blogengine.views.getCategory'),\\n\\n    # Flat pages\\n    url(r'', include('django.contrib.flatpages.urls')),\\n)\\n\")), mdx(\"p\", null, \"Now, if you run python manage.py syncdb again, the category system should be up and running.\"), mdx(\"p\", null, \"The next step is to add the facility to handle comments. Again, Django has its own application built in for handling comments, so go into settings.py and enter the following under INSTALLED_APPS:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"     'django.contrib.comments',\\n\")), mdx(\"p\", null, \"Then run python manage.py syncdb again to generate the appropriate database tables. You'll also need to amend urls.py to provide a dedicated URL for comments:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"    # Comments\\n    url(r'^comments/', include('django.contrib.comments.urls')),\\n\")), mdx(\"p\", null, \"Place this before the URLconf for the flat pages.\"), mdx(\"p\", null, \"Comments can be attached to any type of content, but we only want to attach them to blog posts, and they should only be visible in the single post template. But first of all, let's add a comment count to posts in posts.html and category.html. Replace posts.html with this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-django\"\n  }, \"{% include 'header.html' %}\\n        {% load comments %}\\n        {% if posts %}\\n        {% for post in posts %}\\n        <h1><a href=\\\"{{ post.get_absolute_url }}\\\">{{ post.title }}</a></h1>\\n        {{ post.text }}\\n        {% get_comment_count for post as comment_count %}\\n        <h3>Comments: {{ comment_count }}</h3>\\n        {% endfor %}\\n        <br />\\n        {% if page.has_previous %}\\n        <a href=\\\"/{{ page.previous_page_number }}/\\\">Previous Page</a>\\n        {% endif %}\\n        {% if page.has_next %}\\n        <a href=\\\"/{{ page.next_page_number }}/\\\">Next Page</a>\\n        {% endif %}\\n        {% else %}\\n        <p>No posts matched</p>\\n        {% endif %}\\n{% include 'footer.html' %}\\n\")), mdx(\"p\", null, \"And replace category.html with this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-django\"\n  }, \"{% include 'header.html' %}\\n        {% load comments %}\\n        <h1>Posts for {{ category.title }}</h1>\\n        {% if posts %}\\n        {% for post in posts %}\\n        <h1><a href=\\\"{{ post.get_absolute_url }}\\\">{{ post.title }}</a></h1>\\n        {{ post.text }}\\n        {% get_comment_count for post as comment_count %}\\n        <h3>Comments: {{ comment_count }}</h3>\\n        {% endfor %}\\n        <br />\\n        {% if page.has_previous %}\\n        <a href=\\\"/{{ page.previous_page_number }}/\\\">Previous Page</a>\\n        {% endif %}\\n        {% if page.has_next %}\\n        <a href=\\\"/{{ page.next_page_number }}/\\\">Next Page</a>\\n        {% endif %}\\n        {% else %}\\n        <p>No posts matched</p>\\n        {% endif %}\\n{% include 'footer.html' %}\\n\")), mdx(\"p\", null, \"The only significant changes here are that at the top we load comments, and underneath the post text we get the comment count for each post as the variable comment_count, then we display it underneath.\"), mdx(\"p\", null, \"Now, we want to go further with our single post template. As well as a comment count, we want to add the actual comments themselves. Finally, we need a form for adding comments - in theory you can use the admin interface for doing this, but it's very unlikely you'd want to do so. Open up single.html and edit it to look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-django\"\n  }, \"{% include 'header.html' %}\\n        {% load comments %}\\n        {% for post in posts %}\\n        <h1><a href=\\\"{{ post.get_absolute_url }}\\\">{{ post.title }}</a></h1>\\n        <h3>{{ post.pub_date }}</h3>\\n        {{ post.text }}\\n        <h3>By {{ post.author.first_name }} {{ post.author.last_name }}</h3>\\n        <h3>Categories: {% for category in post.categories.all %} {{ category.title }} {% endfor %}</h3>\\n        {% get_comment_count for post as comment_count %}\\n        <h3>Comments: {{ comment_count }}</h3>\\n        <ol>\\n        {% get_comment_list for post as comments %}\\n        {% for comment in comments %}\\n        <li>{{ comment }}</li>\\n        {% endfor %}\\n        </ol>\\n        {% render_comment_form for post %}\\n        {% endfor %}\\n        <br />\\n        {% if page.has_previous %}\\n        <a href=\\\"/{{ page.previous_page_number }}/\\\">Previous Page</a>\\n        {% endif %}\\n        {% if page.has_next %}\\n        <a href=\\\"/{{ page.next_page_number }}/\\\">Next Page</a>\\n        {% endif %}\\n{% include 'footer.html' %}\\n\")), mdx(\"p\", null, \"This includes the same changes as the other two templates, so we load comments and display the comment count. Afterwards, we get the comment list for this post as comments, and then loop through the comments, showing them in an ordered list. Afterwards, we then use render_comment_form to show the default comment form for this post. If you'd prefer to create your own comment form, you can use get_comment_form instead to get a form object you can use in the template.\"), mdx(\"p\", null, \"You'll also need to make some minor changes to the view to get the form working. Save single.html and open blogengine/views.py and add the following line of code to your import statements:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from django.template import RequestContext\\n\")), mdx(\"p\", null, \"Then, amend the final line of the getPost function as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"    return render_to_response('single.html', { 'posts':post}, context_instance=RequestContext(request))\\n\")), mdx(\"p\", null, \"The reason this needs to be changed is that the comment form includes the {% csrf_token %} tag, which requires information from the request object, and in order to do so rather than the default context, you need to pass through a RequestContext object instead, but don't worry too much about the details.\"), mdx(\"p\", null, \"If you now ensure the development server is running and visit a blog post, you should now see that you can post comments. If you want to enhance this very basic comment form, take a look at the excellent documentation on the Django website. Alternatively, there are a number of third-party comment services, such as Disqus and IntenseDebate that can handle comments for you and just require you to paste a snippet of code into whatever template you want to enable comments on, and these may be more convenient.\"), mdx(\"p\", null, \"Finally for this lesson, as promised, we'll implement our RSS feed. Again, there's an application bundled with Django that will do this - the syndication framework. Open settings.py and paste the following line in at the bottom of your INSTALLED_APPS:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"     'django.contrib.syndication',\\n\")), mdx(\"p\", null, \"Save the file and run python manage.py syncdb to add the appropriate tables to your database. Then, we need to add a URLconf for the RSS feed. We'll allow a consistent naming scheme for RSS feeds, so this will be /feeds/posts, and if you wanted to you could add /feeds/comments, for instance. Add this to you urls.py, before the url for flat pages:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"    # RSS feeds\\n    url(r'^feeds/posts/$', PostsFeed()),\\n\")), mdx(\"p\", null, \"We'll also need to tell urls.py where to find PostsFeed(). In this case, we're going to put it in the view, so add this import line near the top:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from blogengine.views import PostsFeed\\n\")), mdx(\"p\", null, \"Now open blogengine/views.py and add the following line to the import statements at the top:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from django.contrib.syndication.views import Feed\\n\")), mdx(\"p\", null, \"Then add the following class declaration to the bottom:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class PostsFeed(Feed):\\n    title = \\\"My Django Blog posts\\\"\\n    link = \\\"feeds/posts/\\\"\\n    description = \\\"Posts from My Django Blog\\\"\\n\\n    def items(self):\\n        return Post.objects.order_by('-pub_date')[:5]\\n\\n    def item_title(self, item):\\n        return item.title\\n\\n    def item_description(self, item):\\n        return item.text\\n\")), mdx(\"p\", null, \"This is pretty simple. We import the Feed class from thew views provided by the syndication framework, then we base PostsFeed on Feed. We set the title, the link for the feed, and a description for the feed. Then we get the last 5 Post objects in reverse chronological order, and we define each item's title as the post title. and each item's description as the text of the post. From here' it's pretty easy to see how you could create feeds based on comments, or pretty much any other object that might exist in the database.\"), mdx(\"p\", null, \"And with that done, our blogging engine is pretty-much feature-complete. We have blog posts with comments, categories, an RSS feed, and flat pages, but the look and feel of the site definitely needs some attention. Next time, we'll make our blogging engine look a little nicer. Once again, the code is available on GitHub in case you find that more convenient.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Welcome back! In this tutorial we'll continue extending our Django-powered blogging engine. We'll add the capability to assign blog posts to categories, and comment on posts. We'llâ€¦","frontmatter":{"title":"Yet another tutorial for building a blog using Python and Django - part 4","date":"29 March 2012","categories":["django","python","webdevelopment"]},"fields":{"path":"/blog/2012/03/29/yet-another-tutorial-for-building-a-blog-using-python-and-django-part-4/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2012/03/24/yet-another-tutorial-for-building-a-blog-using-python-and-django-part-3/"},"frontmatter":{"title":"Yet another tutorial for building a blog using Python and Django - Part 3","date":"2012-03-24 18:23:25","layout":"post"}},"next":{"fields":{"path":"/blog/2012/04/23/yet-another-tutorial-for-building-a-blog-using-python-and-django-part-5/"},"frontmatter":{"title":"Yet another tutorial for building a blog using Python and Django - part 5","date":"2012-04-23 21:55:40","layout":"post"}}}},"staticQueryHashes":["290055352","2909664151"]}