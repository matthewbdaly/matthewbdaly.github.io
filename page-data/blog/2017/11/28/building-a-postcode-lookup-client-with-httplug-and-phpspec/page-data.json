{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2017/11/28/building-a-postcode-lookup-client-with-httplug-and-phpspec/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"ac18e286-fd74-53bc-9787-4790e43f6e07","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Building a postcode lookup client with HTTPlug and PHPSpec\",\n  \"date\": \"2017-11-28 11:40:39 +0000\",\n  \"layout\": \"post\",\n  \"categories\": [\"php\", \"tdd\", \"phpspec\", \"http\", \"httplug\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"While PHPUnit is my normal go-to PHP testing framework, for some applications I find \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://www.phpspec.net/en/stable/\"\n  }, \"PHPSpec\"), \" superior, in particular REST API clients. I've found that it makes for a better flow when doing test-driven development, because it makes it very natural to write a test first, then run it, then make the test pass.\"), mdx(\"p\", null, \"In this tutorial I'll show you how to build a lookup API client for UK postcodes. In the process of doing so, we'll use PHPSpec to drive our development process. We'll also use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://docs.php-http.org/en/latest/httplug/tutorial.html\"\n  }, \"HTTPlug\"), \" as our underlying HTTP library. The advantage of this over using something like Guzzle is that we give library users the freedom to choose the HTTP library they feel is most appropriate to their situation.\"), mdx(\"h2\", null, \"Background\"), mdx(\"p\", null, \"If you're unfamiliar with it, the UK postcode system is our equivalent of a zip code in the US, but with two major differences:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The codes themselves are alphanumeric instead of numeric, with the first part including one or two letters usually (but not always) derived from the nearest large town or city (eg L for Liverpool, B for Birmingham, OX for Oxford), or for London, based on the part of the city (eg NW for the north-west of London)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A full postcode is in two parts (eg NW1 8TQ), and the first part narrows the location down to a similar area to a US-style zip code, while the second part usually narrows it down to a street (although sometimes large organisations that receive a lot of mail will have a postcode to themselves).\")), mdx(\"p\", null, \"This means that if you have someone's postcode and house name or address, you can use those details to look up the rest of their address details. This obviously makes it easier for users to fill out a form, such as when placing an order on an e-commerce site - you can just request those two details and then autofill the rest from them.\"), mdx(\"p\", null, \"Unfortunately, it's not quite that simple. The data is owned by Royal Mail, and they charge through the nose for access to the raw data, which places this data well outside the budgets of many web app developers. Fortunately, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://ideal-postcodes.co.uk/\"\n  }, \"Ideal Postcodes\"), \" offer a REST API for querying this data. It's not free, but at 2.5p per request it's not going to break the bank unless used excessively, and they offer some dummy postcodes that are free to query, which is perfectly fine for testing.\"), mdx(\"p\", null, \"For those of you outside the UK, this may not be of much immediate use, but the underlying principles will still be useful, and you can probably build a similar client for your own nation's postal code system. For instance, there's a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.zipcodeapi.com/API\"\n  }, \"Zipcode API\"), \" that those of you in the US can use, and if you understand what's going on here it shouldn't be hard to adapt it to work with that. If you do produce a similar client for your country's postal code system, submit a pull request to update the README with a link to it and I'll include it.\"), mdx(\"h2\", null, \"Setting up\"), mdx(\"p\", null, \"First we'll create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"composer.json\"), \" to specify our dependencies:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"{\\n    \\\"name\\\": \\\"matthewbdaly/postcode-client\\\",\\n    \\\"description\\\": \\\"A postcode lookup client.\\\",\\n    \\\"type\\\": \\\"library\\\",\\n    \\\"keywords\\\": [\\\"postcode\\\"],\\n    \\\"require\\\": {\\n        \\\"psr/http-message\\\": \\\"^1.0\\\",\\n        \\\"php-http/client-implementation\\\": \\\"^1.0\\\",\\n        \\\"php-http/httplug\\\": \\\"^1.0\\\",\\n        \\\"php-http/message-factory\\\": \\\"^1.0\\\",\\n        \\\"php-http/discovery\\\": \\\"^1.0\\\"\\n    },\\n    \\\"require-dev\\\": {\\n        \\\"psy/psysh\\\": \\\"^0.8.0\\\",\\n        \\\"phpspec/phpspec\\\": \\\"^3.2\\\",\\n        \\\"squizlabs/php_codesniffer\\\": \\\"^2.7\\\",\\n        \\\"php-http/mock-client\\\": \\\"^1.0\\\",\\n        \\\"php-http/message\\\": \\\"^1.0\\\",\\n        \\\"guzzlehttp/psr7\\\": \\\"^1.0\\\"\\n    },\\n    \\\"license\\\": \\\"MIT\\\",\\n    \\\"authors\\\": [\\n        {\\n            \\\"name\\\": \\\"Matthew Daly\\\",\\n            \\\"email\\\": \\\"matthewbdaly@gmail.com\\\"\\n        }\\n    ],\\n    \\\"autoload\\\": {\\n        \\\"psr-4\\\": {\\n            \\\"Matthewbdaly\\\\\\\\Postcode\\\\\\\\\\\": \\\"src/\\\"\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"Note that we don't install an actual HTTPlug client, other than the mock one, which is only useful for testing. This is deliberate - we're giving developers working with this library the choice of working with whatever HTTP client they see fit. We do use the Guzzle PSR7 library, but that's just for the PSR7 library.\"), mdx(\"p\", null, \"Then we install our dependencies:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ composer install\\n\")), mdx(\"p\", null, \"We also need to tell PHPSpec what our namespace will be. Save this as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"phpspec.yml\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yml\"\n  }, \"suites:\\n    test_suite:\\n        namespace: Matthewbdaly\\\\Postcode\\n        psr4_prefix: Matthewbdaly\\\\Postcode\\n\")), mdx(\"p\", null, \"Don't forget to update the namespace in both files to whatever you're using, which should have a vendor name and a package name.\"), mdx(\"p\", null, \"With that done, it's time to introduce the next component.\"), mdx(\"h2\", null, \"Introducing HTTPlug\"), mdx(\"p\", null, \"In the past I've usually used either Curl or Guzzle to carry out HTTP requests. However, the problem with this approach is that you're forcing whoever uses your library to use whatever HTTP client, and whatever version of that client, that you deem appropriate. If they're also using another library that someone else has written and they made different choices, you could have problems.\"), mdx(\"p\", null, \"HTTPlug is an excellent way of solving this problem. By requiring only an interface and not a concrete implementation, using HTTPlug means that you can specify that the consumer of the library must provide a suitable implementation of that library, but leave the choice of implementation up to them. This means that they can choose whatever implementation best fits their use case. There are \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://docs.php-http.org/en/latest/clients.html\"\n  }, \"adapters for many different clients\"), \", so it's unlikely that they won't be able to find one that meets their needs.\"), mdx(\"p\", null, \"In addition, HTTPlug provides the means to automatically determine what HTTP client to use, so that if one is not explicitly provided, it can be resolved without any action on the part of the developer. As long as a suitable HTTP adapter is installed, it will be used.\"), mdx(\"h2\", null, \"Getting started\"), mdx(\"p\", null, \"One advantage of PHPSpec is that it will automatically generate much of the boilerplate for our client and specs. To create our client spec, run this command:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec desc Matthewbdaly/Postcode/Client\\nSpecification for Matthewbdaly\\\\Postcode\\\\Client created in /home/matthew/Projects/postcode-client/spec/ClientSpec.php.\\n\")), mdx(\"p\", null, \"Now that we have a spec for our client, we can generate the client itself:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec run\\nMatthewbdaly/Postcode/Client                                                    \\n  11  - it is initializable\\n      class Matthewbdaly\\\\Postcode\\\\Client does not exist.\\n\\n                                      100%                                       1\\n1 specs\\n1 example (1 broken)\\n14ms\\n\\n                                                                                \\n  Do you want me to create `Matthewbdaly\\\\Postcode\\\\Client` for you?              \\n                                                                         [Y/n] \\ny\\nClass Matthewbdaly\\\\Postcode\\\\Client created in /home/matthew/Projects/postcode-client/src/Client.php.\\n\\n                                      100%                                       1\\n1 specs\\n1 example (1 passed)\\n16ms\\n\")), mdx(\"p\", null, \"You will need to enter \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Y\"), \" when prompted. We now have an empty class for our client.\"), mdx(\"p\", null, \"Next, we need to make sure that the constructor for our client accepts two parameters:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The HTTP client\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A message factory instance, which is used to create the request\")), mdx(\"p\", null, \"Amend \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spec/ClientSpec.php\"), \" as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace spec\\\\Matthewbdaly\\\\Postcode;\\n\\nuse Matthewbdaly\\\\Postcode\\\\Client;\\nuse PhpSpec\\\\ObjectBehavior;\\nuse Prophecy\\\\Argument;\\nuse Http\\\\Client\\\\HttpClient;\\nuse Http\\\\Message\\\\MessageFactory;\\n\\nclass ClientSpec extends ObjectBehavior\\n{\\n    function let (HttpClient $client, MessageFactory $messageFactory)\\n    {\\n        $this->beConstructedWith($client, $messageFactory);\\n    }\\n\\n    function it_is_initializable()\\n    {\\n        $this->shouldHaveType(Client::class);\\n    }\\n}\\n\")), mdx(\"p\", null, \"Note the use of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"let()\"), \" method here. This lets us specify how the object is constructed, with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"beConstructedWith()\"), \" method. Also, note that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$this\"), \" refers not to the test, but to the object being tested - this takes a bit of getting used to if you're used to working with PHPUnit.\"), mdx(\"p\", null, \"Also, note that the objects passed through are not actual instances of those objects - instead they are mocks created automatically by PHPSpec. This makes mocking extremely easy, and you can easily set up your own expectations on those mock objects in the test. If you want to use a real object, you can instantiate it in the spec as usual. If we need any other mocks, we can typehint them in our method in exactly the same way.\"), mdx(\"p\", null, \"If we once again use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"vendor/bin/phpspec run\"), \" we can now generate a constructor:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec run\\nMatthewbdaly/Postcode/Client                                                    \\n  18  - it is initializable\\n      method Matthewbdaly\\\\Postcode\\\\Client::__construct not found.\\n\\n                                      100%                                       1\\n1 specs\\n1 example (1 broken)\\n281ms\\n\\n                                                                                \\n  Do you want me to create `Matthewbdaly\\\\Postcode\\\\Client::__construct()` for    \\n  you?                                                                          \\n                                                                         [Y/n] \\ny\\n  Method Matthewbdaly\\\\Postcode\\\\Client::__construct() has been created.\\n  \\n                                      100%                                       1\\n1 specs\\n1 example (1 passed)\\n50ms\\n\")), mdx(\"p\", null, \"This will only create a placeholder for the constructor. You need to populate it yourself, so update \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src/Client.php\"), \" as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace Matthewbdaly\\\\Postcode;\\n\\nuse Http\\\\Client\\\\HttpClient;\\nuse Http\\\\Discovery\\\\HttpClientDiscovery;\\nuse Http\\\\Message\\\\MessageFactory;\\nuse Http\\\\Discovery\\\\MessageFactoryDiscovery;\\n\\nclass Client\\n{\\n    public function __construct(HttpClient $client = null, MessageFactory $messageFactory = null)\\n    {\\n        $this->client = $client ?: HttpClientDiscovery::find();\\n        $this->messageFactory = $messageFactory ?: MessageFactoryDiscovery::find();\\n    }\\n}\\n\")), mdx(\"p\", null, \"A little explanation is called for here. We need two arguments in our construct:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"An instance of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Http\\\\Client\\\\HttpClient\"), \" to send the request\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"An instance of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Http\\\\Message\\\\MessageFactory\"), \" to create the request\")), mdx(\"p\", null, \"However, we don't want to force the user to create one. Therefore if they are not set, we use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Http\\\\Discovery\\\\HttpClientDiscovery\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Http\\\\Discovery\\\\MessageFactoryDiscovery\"), \" to create them for us.\"), mdx(\"p\", null, \"If we re-run PHPSpec, it should now pass:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec run\\n                                      100%                                       1\\n1 specs\\n1 example (1 passed)\\n31ms\\n\")), mdx(\"p\", null, \"Next, we want to have a method for retrieving the endpoint. Add the following method to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spec/ClientSpec.php\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    function it_can_retrieve_the_base_url()\\n    {\\n        $this->getBaseUrl()->shouldReturn('https://api.ideal-postcodes.co.uk/v1/postcodes/');\\n    }\\n\")), mdx(\"p\", null, \"Here we're asserting that fetching the base URL returns the given result. Note how much simpler and more intuitive this syntax is than PHPUnit would be:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"$this->assertEquals('https://api.ideal-postcodes.co.uk/v1/postcodes/', $client->getBaseUrl());\\n\")), mdx(\"p\", null, \"Running the tests again should prompt us to create the boilerplate for the new method:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec run\\nMatthewbdaly/Postcode/Client                                                      \\n  23  - it can retrieve the base url\\n      method Matthewbdaly\\\\Postcode\\\\Client::getBaseUrl not found.\\n\\n                  50%                                     50%                    2\\n1 specs\\n2 examples (1 passed, 1 broken)\\n40ms\\n\\n                                                                                \\n  Do you want me to create `Matthewbdaly\\\\Postcode\\\\Client::getBaseUrl()` for     \\n  you?                                                                          \\n                                                                         [Y/n] \\ny\\n  Method Matthewbdaly\\\\Postcode\\\\Client::getBaseUrl() has been created.\\n  \\nMatthewbdaly/Postcode/Client                                                      \\n  23  - it can retrieve the base url\\n      expected \\\"https://api.ideal-postcod...\\\", but got null.\\n\\n                  50%                                     50%                    2\\n1 specs\\n2 examples (1 passed, 1 failed)\\n72ms\\n\")), mdx(\"p\", null, \"Now we need to update that method to work as expected:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    protected $baseUrl = 'https://api.ideal-postcodes.co.uk/v1/postcodes/';\\n\\n     ...\\n\\n    public function getBaseUrl()\\n    {\\n        return $this->baseUrl;\\n    }\\n\")), mdx(\"p\", null, \"This should make the tests pass:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec run\\n                                      100%                                       2\\n1 specs\\n2 examples (2 passed)\\n34ms\\n\")), mdx(\"p\", null, \"Next, we need to be able to get and set the API key. Add the following to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spec/ClientSpec.php\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    function it_can_get_and_set_the_key()\\n    {\\n        $this->getKey()->shouldReturn(null);\\n        $this->setKey('foo')->shouldReturn($this);\\n        $this->getKey()->shouldReturn('foo');\\n    }\\n\")), mdx(\"p\", null, \"Note that we expect \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$this->setKey('foo')\"), \" to return \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$this\"), \". This is an example of a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"fluent\"), \" interface - by returning an instance of the object, it enables methods to be chained, eg \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$client->setKey('foo')->get()\"), \". Obviously it won't work for anything that has to return a value, but it's a useful way of making your classes more intuitive to use.\"), mdx(\"p\", null, \"Next, run the tests again and agree to the prompts as before:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec run\\nMatthewbdaly/Postcode/Client                                                      \\n  28  - it can get and set the key\\n      method Matthewbdaly\\\\Postcode\\\\Client::getKey not found.\\n\\n                         66%                                     33%             3\\n1 specs\\n3 examples (2 passed, 1 broken)\\n51ms\\n\\n                                                                                \\n  Do you want me to create `Matthewbdaly\\\\Postcode\\\\Client::getKey()` for you?    \\n                                                                         [Y/n] \\ny\\n  Method Matthewbdaly\\\\Postcode\\\\Client::getKey() has been created.\\n  \\nMatthewbdaly/Postcode/Client                                                      \\n  28  - it can get and set the key\\n      method Matthewbdaly\\\\Postcode\\\\Client::setKey not found.\\n\\n                         66%                                     33%             3\\n1 specs\\n3 examples (2 passed, 1 broken)\\n43ms\\n\\n                                                                                \\n  Do you want me to create `Matthewbdaly\\\\Postcode\\\\Client::setKey()` for you?    \\n                                                                         [Y/n] \\ny\\n  Method Matthewbdaly\\\\Postcode\\\\Client::setKey() has been created.\\n  \\nMatthewbdaly/Postcode/Client                                                      \\n  28  - it can get and set the key\\n      expected [obj:Matthewbdaly\\\\Postcode\\\\Client], but got null.\\n\\n                         66%                                     33%             3\\n1 specs\\n3 examples (2 passed, 1 failed)\\n52ms\\n\")), mdx(\"p\", null, \"Next, add our getter and setter for the key, as well as declaring the property \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$key\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    protected $key;\\n\\n    public function getKey()\\n    {\\n        return $this->key;\\n    }\\n\\n    public function setKey(string $key)\\n    {\\n        $this->key = $key;\\n        return $this;\\n    }\\n\")), mdx(\"p\", null, \"That should make the tests pass:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec run\\n                                      100%                                       3\\n1 specs\\n3 examples (3 passed)\\n38ms\\n\")), mdx(\"p\", null, \"With that done, our final task is to be able to handle sending requests. Add the following imports at the top of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spec/ClientSpec.php\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"use Psr\\\\Http\\\\Message\\\\RequestInterface;\\nuse Psr\\\\Http\\\\Message\\\\ResponseInterface;\\nuse Psr\\\\Http\\\\Message\\\\StreamInterface;\\n\")), mdx(\"p\", null, \"And add the following method at the bottom of the same file:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    function it_can_send_the_request(HttpClient $client, MessageFactory $messageFactory, RequestInterface $request, ResponseInterface $response, StreamInterface $stream)\\n    {\\n        $this->beConstructedWith($client, $messageFactory);\\n        $this->setKey('foo');\\n        $data = json_encode([\\n            'result' => [\\n                \\\"postcode\\\" => \\\"SW1A 2AA\\\",\\n                \\\"postcode_inward\\\" => \\\"2AA\\\",\\n                \\\"postcode_outward\\\" => \\\"SW1A\\\",\\n                \\\"post_town\\\" => \\\"LONDON\\\",\\n                \\\"dependant_locality\\\" => \\\"\\\",\\n                \\\"double_dependant_locality\\\" => \\\"\\\",\\n                \\\"thoroughfare\\\" => \\\"Downing Street\\\",\\n                \\\"dependant_thoroughfare\\\" => \\\"\\\",\\n                \\\"building_number\\\" => \\\"10\\\",\\n                \\\"building_name\\\" => \\\"\\\",\\n                \\\"sub_building_name\\\" => \\\"\\\",\\n                \\\"po_box\\\" => \\\"\\\",\\n                \\\"department_name\\\" => \\\"\\\",\\n                \\\"organisation_name\\\" => \\\"Prime Minister & First Lord Of The Treasury\\\",\\n                \\\"udprn\\\" => 23747771,\\n                \\\"umprn\\\" => \\\"\\\",\\n                \\\"postcode_type\\\" => \\\"L\\\",\\n                \\\"su_organisation_indicator\\\" => \\\"\\\",\\n                \\\"delivery_point_suffix\\\" => \\\"1A\\\",\\n                \\\"line_1\\\" => \\\"Prime Minister & First Lord Of The Treasury\\\",\\n                \\\"line_2\\\" => \\\"10 Downing Street\\\",\\n                \\\"line_3\\\" => \\\"\\\",\\n                \\\"premise\\\" => \\\"10\\\",\\n                \\\"longitude\\\" => -0.127695242183412,\\n                \\\"latitude\\\" => 51.5035398826274,\\n                \\\"eastings\\\" => 530047,\\n                \\\"northings\\\" => 179951,\\n                \\\"country\\\" => \\\"England\\\",\\n                \\\"traditional_county\\\" => \\\"Greater London\\\",\\n                \\\"administrative_county\\\" => \\\"\\\",\\n                \\\"postal_county\\\" => \\\"London\\\",\\n                \\\"county\\\" => \\\"London\\\",\\n            ]\\n        ]);\\n        $messageFactory->createRequest('GET', 'https://api.ideal-postcodes.co.uk/v1/postcodes/SW1A%202AA?api_key=foo', [], null, '1.1')->willReturn($request);\\n        $client->sendRequest($request)->willReturn($response);\\n        $response->getStatusCode()->willReturn(200);\\n        $response->getBody()->willReturn($stream);\\n        $stream->getContents()->willReturn($data);\\n        $this->get('SW1A 2AA')->shouldBeLike(json_decode($data, true));\\n    }\\n\")), mdx(\"p\", null, \"This test is by far the biggest so far, so it merits some degree of explanation.\"), mdx(\"p\", null, \"Note that we don't make a real HTTP request against the API. This may sound strange, but bear with me. We have no control whatsoever over that API, and it could in theory become inaccessible or be subject to breaking changes at any time. We also don't want to be shelling out for a paid service just to test our API client works. All we can do is test that our implementation will send the request we expect it to send - we don't want our test suite reporting a bug when the API goes down.\"), mdx(\"p\", null, \"We therefore typehint not just the dependencies for the constructor, but a request, response and stream instance. We mock our our responses from those instances using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"willReturn()\"), \" method, so we have complete control over what we pass to our client. That way we can return any appropriate response or throw any exception we deem fit to test the behaviour under those circumstances. For the message factory, we specify what arguments it should receive to create the request, and return our mocked-out request object.\"), mdx(\"p\", null, \"Also, note we use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"shouldBeLike()\"), \" to verify the response - this is effectively using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"==\"), \" operator, whereas \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"shouldBe()\"), \" uses the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"===\"), \" operator, making it stricter.\"), mdx(\"p\", null, \"Let's run the tests, and don't forget the prompt:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"$ vendor/bin/phpspec run\\nMatthewbdaly/Postcode/Client                                                      \\n  38  - it can send the request\\n      method Matthewbdaly\\\\Postcode\\\\Client::get not found.\\n\\n                            75%                                     25%          4\\n1 specs\\n4 examples (3 passed, 1 broken)\\n55ms\\n\\n                                                                                \\n  Do you want me to create `Matthewbdaly\\\\Postcode\\\\Client::get()` for you?       \\n                                                                         [Y/n] \\ny\\n  Method Matthewbdaly\\\\Postcode\\\\Client::get() has been created.\\n  \\nMatthewbdaly/Postcode/Client                                                      \\n  38  - it can send the request\\n      expected [array:1], but got null.\\n\\n                            75%                                     25%          4\\n1 specs\\n4 examples (3 passed, 1 failed)\\n56ms\\n\")), mdx(\"p\", null, \"Now we can implement the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get()\"), \" method:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    public function get(string $postcode)\\n    {\\n        $url = $this->getBaseUrl() . rawurlencode($postcode) . '?' . http_build_query([\\n            'api_key' => $this->getKey()\\n        ]);\\n        $request = $this->messageFactory->createRequest(\\n            'GET',\\n            $url,\\n            [],\\n            null,\\n            '1.1'\\n        );\\n        $response = $this->client->sendRequest($request);\\n        $data = json_decode($response->getBody()->getContents(), true);\\n        return $data;\\n    }\\n\")), mdx(\"p\", null, \"We first build up our URL, before using the message factory to create a request object. We then pass the built request to our client to send, before decoding the response into the format we want.\"), mdx(\"p\", null, \"This should make our tests pass:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec run\\n                                      100%                                       4\\n1 specs\\n4 examples (4 passed)\\n307ms\\n\")), mdx(\"p\", null, \"Our client now works, but there are a couple of situations we need to account for. First, the API will raise a 402 if you make a request for a real postcode without having paid. We need to catch this and throw an exception. Add this to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spec/ClientSpec.php\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"use Matthewbdaly\\\\Postcode\\\\Exceptions\\\\PaymentRequired;\\n\\n    ...\\n\\n    function it_throws_an_exception_if_payment_required(HttpClient $client, MessageFactory $messageFactory, RequestInterface $request, ResponseInterface $response, StreamInterface $stream)\\n    {\\n        $this->beConstructedWith($client, $messageFactory);\\n        $this->setKey('foo');\\n        $messageFactory->createRequest('GET', 'https://api.ideal-postcodes.co.uk/v1/postcodes/SW1A%202AA?api_key=foo', [], null, '1.1')->willReturn($request);\\n        $client->sendRequest($request)->willReturn($response);\\n        $response->getStatusCode()->willReturn(402);\\n        $this->shouldThrow(PaymentRequired::class)->duringGet('SW1A 2AA');\\n    }\\n\")), mdx(\"p\", null, \"With that done, run the tests again:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec run\\nMatthewbdaly/Postcode/Client                                                      \\n  87  - it throws an exception if payment required\\n      expected exception of class \\\"Matthewbdaly\\\\Postcode\\\\Exc...\\\", but got\\n      [exc:Prophecy\\\\Exception\\\\Call\\\\UnexpectedCallException(\\\"Method call:\\n        - getBody()\\n      on Double\\\\ResponseInterface\\\\P15 was not expected, expected calls were:\\n        - getStatusCode()\\\")].\\n\\n                              80%                                     20%        5\\n1 specs\\n5 examples (4 passed, 1 failed)\\n130ms\\n\")), mdx(\"p\", null, \"Let's amend the client to throw this exception:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"use Matthewbdaly\\\\Postcode\\\\Exceptions\\\\PaymentRequired;\\n\\n    ...\\n\\n    public function get(string $postcode)\\n    {\\n        $url = $this->getBaseUrl() . rawurlencode($postcode) . '?' . http_build_query([\\n            'api_key' => $this->getKey()\\n        ]);\\n        $request = $this->messageFactory->createRequest(\\n            'GET',\\n            $url,\\n            [],\\n            null,\\n            '1.1'\\n        );\\n        $response = $this->client->sendRequest($request);\\n        if ($response->getStatusCode() == 402) {\\n            throw new PaymentRequired;\\n        }\\n        $data = json_decode($response->getBody()->getContents(), true);\\n        return $data;\\n    }\\n\")), mdx(\"p\", null, \"And let's re-run the tests:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec run\\nMatthewbdaly/Postcode/Client                                                    \\n  87  - it throws an exception if payment required\\n      expected exception of class \\\"Matthewbdaly\\\\Postcode\\\\Exc...\\\", but got [obj:Error] with the\\n      message: \\\"Class 'Matthewbdaly\\\\Postcode\\\\Exceptions\\\\PaymentRequired' not found\\\"\\n\\n                              80%                                     20%        5\\n1 specs\\n5 examples (4 passed, 1 failed)\\n389ms\\n\")), mdx(\"p\", null, \"It fails now because the exception doesn't exist. Let's create it at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src/Exceptions/PaymentRequired.php\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace Matthewbdaly\\\\Postcode\\\\Exceptions;\\n\\nclass PaymentRequired extends \\\\Exception\\n{\\n}\\n\")), mdx(\"p\", null, \"That should be enough to make our tests pass:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec run\\n                                      100%                                       5\\n1 specs\\n5 examples (5 passed)\\n89ms\\n\")), mdx(\"p\", null, \"We also need to raise an exception when the postcode is not found, which raises a 404 error. Add the following spec:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"use Matthewbdaly\\\\Postcode\\\\Exceptions\\\\PostcodeNotFound;\\n    ...\\n    function it_throws_an_exception_if_postcode_not_found(HttpClient $client, MessageFactory $messageFactory, RequestInterface $request, ResponseInterface $response, StreamInterface $stream)\\n    {\\n        $this->beConstructedWith($client, $messageFactory);\\n        $this->setKey('foo');\\n        $messageFactory->createRequest('GET', 'https://api.ideal-postcodes.co.uk/v1/postcodes/SW1A%202AA?api_key=foo', [], null, '1.1')->willReturn($request);\\n        $client->sendRequest($request)->willReturn($response);\\n        $response->getStatusCode()->willReturn(404);\\n        $this->shouldThrow(PostcodeNotFound::class)->duringGet('SW1A 2AA');\\n    }\\n\")), mdx(\"p\", null, \"Run the tests:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec run\\nMatthewbdaly/Postcode/Client                                                    \\n  98  - it throws an exception if postcode not found\\n      expected exception of class \\\"Matthewbdaly\\\\Postcode\\\\Exc...\\\", but got\\n      [exc:Prophecy\\\\Exception\\\\Call\\\\UnexpectedCallException(\\\"Method call:\\n        - getBody()\\n      on Double\\\\ResponseInterface\\\\P20 was not expected, expected calls were:\\n        - getStatusCode()\\\")].\\n\\n                                83%                                     16%      6\\n1 specs\\n6 examples (5 passed, 1 failed)\\n538ms\\n\")), mdx(\"p\", null, \"This time we'll create the exception class before updating the client. Create the following class at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src/Exceptions/PostcodeNotFound.php\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace Matthewbdaly\\\\Postcode\\\\Exceptions;\\n\\n/**\\n * Postcode not found exception\\n *\\n */\\nclass PostcodeNotFound extends \\\\Exception\\n{\\n}\\n\")), mdx(\"p\", null, \"And update the client:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"use Matthewbdaly\\\\Postcode\\\\Exceptions\\\\PostcodeNotFound;\\n    ...\\n    public function get(string $postcode)\\n    {\\n        $url = $this->getBaseUrl() . rawurlencode($postcode) . '?' . http_build_query([\\n            'api_key' => $this->getKey()\\n        ]);\\n        $request = $this->messageFactory->createRequest(\\n            'GET',\\n            $url,\\n            [],\\n            null,\\n            '1.1'\\n        );\\n        $response = $this->client->sendRequest($request);\\n        if ($response->getStatusCode() == 402) {\\n            throw new PaymentRequired;\\n        }\\n        if ($response->getStatusCode() == 404) {\\n            throw new PostcodeNotFound;\\n        }\\n        $data = json_decode($response->getBody()->getContents(), true);\\n        return $data;\\n    }\\n\")), mdx(\"p\", null, \"Re-run the tests:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec run\\n                                      100%                                       6\\n1 specs\\n6 examples (6 passed)\\n103ms\\n\")), mdx(\"p\", null, \"And our API client is feature complete! You can find the source code of the finished client \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/matthewbdaly/postcode-client\"\n  }, \"here\"), \".\"), mdx(\"h2\", null, \"Summary\"), mdx(\"p\", null, \"Personally, I find that while PHPSpec isn't appropriate for every use case, it's particularly handy for API clients and it's generally my go-to testing solution for them. It handles producing a lot of the boilerplate for me, and it results in a much better workflow for test-driven development as it makes it very natural to write the test first, then make it pass.\"), mdx(\"p\", null, \"HTTPlug has been a revelation for me. While it takes a bit of getting used to if you're used to something like Guzzle, it means that you're giving consumers of your library the freedom to choose the HTTP client of their choice, meaning they don't have to fight with several different libraries requiring different versions of Guzzle. It also allows for easy resolution of the HTTP client, rather than having to explicitly pass through an instance when instantiating your client. I'm planning to use it extensively in the future.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"While PHPUnit is my normal go-to PHP testing framework, for some applications I find  PHPSpec  superior, in particular REST API clients. I've found that it makes for a better flowâ€¦","frontmatter":{"title":"Building a postcode lookup client with HTTPlug and PHPSpec","date":"28 November 2017","categories":["php","tdd","phpspec","http","httplug"]},"fields":{"path":"/blog/2017/11/28/building-a-postcode-lookup-client-with-httplug-and-phpspec/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2017/11/16/creating-custom-assertions-with-phpunit/"},"frontmatter":{"title":"Creating custom assertions with PHPUnit","date":"2017-11-16 15:15:50 +0000","layout":"post"}},"next":{"fields":{"path":"/blog/2017/12/02/full-text-search-with-laravel-and-postgresql/"},"frontmatter":{"title":"Full text search with Laravel and PostgreSQL","date":"2017-12-02 23:30:44 +0000","layout":"post"}}}},"staticQueryHashes":["2909664151"]}