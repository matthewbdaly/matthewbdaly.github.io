{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2017/10/03/simple-fuzzy-search-with-laravel-and-postgresql/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"110ec65b-fa60-5c2c-a37d-d9142fd251d0","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Simple fuzzy search with Laravel and PostgreSQL\",\n  \"date\": \"2017-10-03 23:56:11 +0100\",\n  \"layout\": \"post\",\n  \"categories\": [\"laravel\", \"postgresql\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"When implementing fuzzy search, many developers reach straight for specialised tools like Elasticsearch. However, for simple implementations, this is often overkill. PostgreSQL, my relational database of choice, can natively handle fuzzy search quite easily if you know how. Here's how you might use this with Laravel.\"), mdx(\"p\", null, \"Suppose we have the following migration to create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"locations\"), \" table, storing towns, cities and villages:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nuse Illuminate\\\\Database\\\\Schema\\\\Blueprint;\\nuse Illuminate\\\\Database\\\\Migrations\\\\Migration;\\n\\nclass CreateLocations extends Migration\\n{\\n    /**\\n     * Run the migrations.\\n     *\\n     * @return void\\n     */\\n    public function up()\\n    {\\n        // Create locations table\\n        Schema::create('locations', function (Blueprint $table) {\\n            $table->increments('id')->unsigned();\\n            $table->string('name');\\n            $table->timestamps();\\n        });\\n    }\\n\\n    /**\\n     * Reverse the migrations.\\n     *\\n     * @return void\\n     */\\n    public function down()\\n    {\\n        // Drop locations table\\n        Schema::drop('locations');\\n    }\\n}\\n\")), mdx(\"p\", null, \"The key to this implementation of fuzzy search is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"trigrams\"), \". A trigram is a group of three consecutive characters taken from a string. Using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pg_trgm\"), \" module, which comes with PostgreSQL, we can break a string into as many trigrams as possible, and then return the strings with the most matching trigrams.\"), mdx(\"p\", null, \"We can ensure that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pg_trgm\"), \" is set up on the database by creating a migration:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nuse Illuminate\\\\Support\\\\Facades\\\\Schema;\\nuse Illuminate\\\\Database\\\\Schema\\\\Blueprint;\\nuse Illuminate\\\\Database\\\\Migrations\\\\Migration;\\n\\nclass AddTrgmExtension extends Migration\\n{\\n    /**\\n     * Run the migrations.\\n     *\\n     * @return void\\n     */\\n    public function up()\\n    {\\n        DB::statement('CREATE EXTENSION IF NOT EXISTS pg_trgm');\\n    }\\n\\n    /**\\n     * Reverse the migrations.\\n     *\\n     * @return void\\n     */\\n    public function down()\\n    {\\n        DB::statement('DROP EXTENSION IF EXISTS pg_trgm');\\n    }\\n}\\n\")), mdx(\"p\", null, \"Make sure you run the migration as well. Once that is done, we can make a raw fuzzy query against the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" field as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT * FROM locations WHERE 'burgh' % name;\\n\")), mdx(\"p\", null, \"Translating that to work with the Eloquent ORM, we can perform fuzzy queries against the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" field as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"$location = Location::whereRaw(\\\"'burgh' % name\\\")->get();\\n\")), mdx(\"p\", null, \"This query might match both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Aldeburgh\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Edinburgh\"), \". It's also able to handle slight misspellings, as in this example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"$location = Location::whereRaw(\\\"'hendrad' % name\\\")->get();\\n\")), mdx(\"p\", null, \"This query will match \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"East Hendred\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"West Hendred\"), \" successfully. As you can see, we can match strings at any point in the name string, and handle slight mis-spellings without any problems.\"), mdx(\"p\", null, \"In practice, rather than using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"whereRaw()\"), \" every time, you'll probably want to create a local scope that accepts the name you want to match against. You'll also want to use query parameters to prevent SQL injection:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"$location = Location::whereRaw(\\\"? % name\\\", [$name])->get();\\n\")), mdx(\"h2\", null, \"Improving performance with an index\"), mdx(\"p\", null, \"The performance of these queries isn't that great out of the box. We can improve them by creating an index:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nuse Illuminate\\\\Support\\\\Facades\\\\Schema;\\nuse Illuminate\\\\Database\\\\Schema\\\\Blueprint;\\nuse Illuminate\\\\Database\\\\Migrations\\\\Migration;\\n\\nclass AddTrgmExtension extends Migration\\n{\\n    /**\\n     * Run the migrations.\\n     *\\n     * @return void\\n     */\\n    public function up()\\n    {\\n        DB::statement('CREATE EXTENSION IF NOT EXISTS pg_trgm');\\n        DB::statement('CREATE INDEX locations_name_trigram ON locations USING gist(name gist_trgm_ops);');\\n    }\\n\\n    /**\\n     * Reverse the migrations.\\n     *\\n     * @return void\\n     */\\n    public function down()\\n    {\\n        DB::statement('DROP INDEX IF EXISTS locations_name_trigram');\\n        DB::statement('DROP EXTENSION IF EXISTS pg_trgm');\\n    }\\n}\\n\")), mdx(\"p\", null, \"Adding an index should produce a noticeable improvement in the response time.\"), mdx(\"h2\", null, \"Final thoughts\"), mdx(\"p\", null, \"PostgreSQL's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pg_trgm\"), \" module is a fairly straightforward way of implementing fuzzy search. It's not much more involved than a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LIKE\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ILIKE\"), \" clause in your query, and for many use cases, it's more than sufficient. If you don't have a huge number of records, it's probably a more appropriate choice than something like Elasticsearch, and has the advantage of a simpler stack. However, if you have a larger dataset, you may be better off with a dedicated search solution. As always, if you're unsure it's a good idea to try both and see what works best for that particular use case.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"When implementing fuzzy search, many developers reach straight for specialised tools like Elasticsearch. However, for simple implementations, this is often overkill. PostgreSQL, myâ€¦","frontmatter":{"title":"Simple fuzzy search with Laravel and PostgreSQL","date":"03 October 2017","categories":["laravel","postgresql"]},"fields":{"path":"/blog/2017/10/03/simple-fuzzy-search-with-laravel-and-postgresql/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2017/09/25/a-generic-php-sms-library/"},"frontmatter":{"title":"A generic PHP SMS library","date":"2017-09-25 22:18:18 +0100","layout":"post"}},"next":{"fields":{"path":"/blog/2017/10/20/using-phpiredis-with-laravel/"},"frontmatter":{"title":"Using phpiredis with Laravel","date":"2017-10-20 22:55:26 +0100","layout":"post"}}}},"staticQueryHashes":["2909664151"]}