{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2017/12/29/using-uuids-as-primary-keys-with-laravel-and-postgresql/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"ced2e7b7-5153-54fb-863e-7559b4361100","body":"var _excluded = [\"components\"];\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Using UUIDs as primary keys with Laravel and PostgreSQL\",\n  \"date\": \"2017-12-29 18:01:04 +0000\",\n  \"layout\": \"post\",\n  \"categories\": [\"php\", \"laravel\", \"postgresql\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"For many applications, using UUID's as the primary keys on a database table can make a lot of sense. For mobile or offline apps, in particular, they mean you can create new objects locally and assign them a primary key without having to worry about it colliding with another object that was created in the meantime once it gets synchronised to the server. Also, they are less informative to nefarious users - an autoincrementing value in a URL tells a user that that value is the primary key, and means the app may potentially allow gathering of information via user enumeration (eg calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/api/v1/users/1\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/api/v1/users/2\"), \" etc).\"), mdx(\"p\", null, \"It's fairly straightforward to use UUID's as primary keys on your models when using PostgreSQL. First, you need to set up your migrations to use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uuid-ossp\"), \" extension and set up the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" field as both a UUID and the primary key. You also need to set a default value manually so that if it's left empty it will generate a UUID for it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"DB::statement('CREATE EXTENSION IF NOT EXISTS \\\"uuid-ossp\\\";');\\nSchema::create('items', function (Blueprint $table) {\\n    $table->uuid('id')->primary();\\n    $table->text('text')->nullable();\\n    $table->timestamps();\\n});\\nDB::statement('ALTER TABLE items ALTER COLUMN id SET DEFAULT uuid_generate_v4();');\\n\")), mdx(\"p\", null, \"Then, in the model definition, you need to tell Laravel to cast the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" field to a string, and explicitly set the primary key to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"class Item extends Model\\n{\\n    protected $casts = [\\n        'id' => 'string',\\n    ];\\n\\n    protected $primaryKey = \\\"id\\\";\\n}\\n\")), mdx(\"p\", null, \"Once this is done, the model should generate the primary keys for you as usual, except as UUID's. If your application needs to accept UUID primary keys that were created offline, such as in a mobile app, you will probably want to add the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" field to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$fillable\"), \" array on the model to allow this.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"For many applications, using UUID's as the primary keys on a database table can make a lot of sense. For mobile or offline apps, in particular, they mean you can create new objectsâ€¦","frontmatter":{"title":"Using UUIDs as primary keys with Laravel and PostgreSQL","date":"29th December 2017 6:01 pm","isoDate":"2017-12-29T18:01:04+00:00","categories":["php","laravel","postgresql"]},"fields":{"path":"/blog/2017/12/29/using-uuids-as-primary-keys-with-laravel-and-postgresql/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2017/12/02/full-text-search-with-laravel-and-postgresql/"},"frontmatter":{"title":"Full text search with Laravel and PostgreSQL","date":"2017-12-02 23:30:44 +0000","layout":"post"}},"next":{"fields":{"path":"/blog/2018/01/01/creating-artisan-tasks-that-generate-files/"},"frontmatter":{"title":"Creating Artisan tasks that generate files","date":"2018-01-01 16:06:21 +0000","layout":"post"}}}},"staticQueryHashes":["1776624730","458490740"]}