{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2018/05/10/building-a-letter-classifier-in-php-with-tesseract-ocr-and-php-ml/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"d50986db-9367-53e5-9d6e-af80efcd4ce9","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Building a letter classifier in PHP with Tesseract OCR and PHP ML\",\n  \"date\": \"2018-05-10 22:50:08 +0000\",\n  \"layout\": \"post\",\n  \"categories\": [\"php\", \"machine-learning\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"PHP isn't the first language that springs to mind when it comes to machine learning. However, it is practical to use PHP for machine learning purposes. In this tutorial I'll show you how to build a pipeline for classifying letters.\"), mdx(\"h2\", null, \"The brief\"), mdx(\"p\", null, \"Before I was a web dev, I was a clerical worker for an FTSE-100 insurance company, doing a lot of work that nowadays is possible to automate away, if you know how. When they received a letter or other communication from a client, it would be sent to be scanned on. Once scanned, a human would have to look at it to classify it, eg was it a complaint, a request for information, a request for a quote, or something else, as well as assign it to a policy number. Let's imagine we've been asked to build a proof of concept for automating this process. This is a good example of a real-world problem that machine learning can help with.\"), mdx(\"p\", null, \"As this is a proof of concept we aren't looking to build a web app for this - for simplicity's sake this will be a command-line application. Unlike emails, letters don't come in an easily machine-readable format, so we will be receiving them as PDF files (since they would have been scanned on, this is a reasonable assumption). Feel free to mock up your own example letters using your own classifications, but I will be classifying letters into four groups:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Complaints\"), \" - letters expressing dissatisfaction\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Information requests\"), \" - letters requesting general information\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Surrender quotes\"), \" - letters requesting a surrender quote\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Surrender forms\"), \" - letters requesting surrender forms\")), mdx(\"p\", null, \"Our application will therefore take in a PDF file at one end, and perform the following actions on it:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Convert the PDF file to a PNG file\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use OCR (optical character recognition) to convert the letter to plain text\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Strip out unwanted whitespace\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Extract any visible policy number from the text\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use a machine learning library to classify the letter, having taught it using prior examples\")), mdx(\"p\", null, \"Sound interesting? Let's get started...\"), mdx(\"h2\", null, \"Introducing pipelines\"), mdx(\"p\", null, \"As our application will be carrying out a series of discrete steps on our data, it makes sense to use the pipeline pattern for this project. Fortunately, the PHP League have produced a excellent \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://pipeline.thephpleague.com/\"\n  }, \"package\"), \" implementing this. We can therefore create a single class for each step in the process and have it handle that in isolation.\"), mdx(\"p\", null, \"We'll also use the Symfony Console component to implement our command-line application. For our machine learning library we will be using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://php-ml.readthedocs.io/en/latest/\"\n  }, \"PHP ML\"), \", which requires PHP 7.1 or greater. For OCR, we will be using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/thiagoalessio/tesseract-ocr-for-php\"\n  }, \"Tesseract\"), \", so you will need to install the underlying Tesseract OCR library, as well as support for your language. On Ubuntu you can install these as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ sudo apt-get install tesseract-ocr tesseract-ocr-eng\\n\")), mdx(\"p\", null, \"This assumes you are using English, however you should be able to find packages to support many other languages. Finally, we need ImageMagick to be installed in order to convert PDF files to PNG's.\"), mdx(\"p\", null, \"Your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"composer.json\"), \" should look something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"{\\n    \\\"name\\\": \\\"matthewbdaly/letter-classifier\\\",\\n    \\\"description\\\": \\\"Demo of classifying letters in PHP\\\",\\n    \\\"type\\\": \\\"project\\\",\\n    \\\"require\\\": {\\n        \\\"league/pipeline\\\": \\\"^0.3.0\\\",\\n        \\\"thiagoalessio/tesseract_ocr\\\": \\\"^2.2\\\",\\n        \\\"php-ai/php-ml\\\": \\\"^0.6.2\\\",\\n        \\\"symfony/console\\\": \\\"^4.0\\\"\\n    },\\n    \\\"require-dev\\\": {\\n        \\\"phpspec/phpspec\\\": \\\"^4.3\\\",\\n        \\\"psy/psysh\\\": \\\"^0.8.17\\\"\\n    },\\n    \\\"autoload\\\": {\\n        \\\"psr-4\\\": {\\n            \\\"Matthewbdaly\\\\\\\\LetterClassifier\\\\\\\\\\\": \\\"src/\\\"\\n        }\\n    },\\n    \\\"license\\\": \\\"MIT\\\",\\n    \\\"authors\\\": [\\n        {\\n            \\\"name\\\": \\\"Matthew Daly\\\",\\n            \\\"email\\\": \\\"matthewbdaly@gmail.com\\\"\\n        }\\n    ]\\n}\\n\")), mdx(\"p\", null, \"Next, let's write the outline of our command-line client. We'll load a single class for our processor command. Save this as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"#!/usr/bin/env php\\n<?php\\n\\nrequire __DIR__.'/vendor/autoload.php';\\n\\nuse Symfony\\\\Component\\\\Console\\\\Application;\\nuse Matthewbdaly\\\\LetterClassifier\\\\Commands\\\\Processor;\\n\\n$application = new Application();\\n$application->add(new Processor());\\n$application->run();\\n\")), mdx(\"p\", null, \"Next, we create our command. Save this as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src/Commands/Processor.php\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace Matthewbdaly\\\\LetterClassifier\\\\Commands;\\n\\nuse Symfony\\\\Component\\\\Console\\\\Command\\\\Command;\\nuse Symfony\\\\Component\\\\Console\\\\Input\\\\InputInterface;\\nuse Symfony\\\\Component\\\\Console\\\\Output\\\\OutputInterface;\\nuse Symfony\\\\Component\\\\Console\\\\Input\\\\InputArgument;\\nuse League\\\\Pipeline\\\\Pipeline;\\nuse Matthewbdaly\\\\LetterClassifier\\\\Stages\\\\ConvertPdfToPng;\\nuse Matthewbdaly\\\\LetterClassifier\\\\Stages\\\\ReadFile;\\nuse Matthewbdaly\\\\LetterClassifier\\\\Stages\\\\Classify;\\nuse Matthewbdaly\\\\LetterClassifier\\\\Stages\\\\StripTabs;\\nuse Matthewbdaly\\\\LetterClassifier\\\\Stages\\\\GetPolicyNumber;\\n\\nclass Processor extends Command\\n{\\n    protected function configure()\\n    {\\n        $this->setName('process')\\n            ->setDescription('Processes a file')\\n            ->setHelp('This command processes a file')\\n            ->addArgument('file', InputArgument::REQUIRED, 'File to process');\\n    }\\n\\n    protected function execute(InputInterface $input, OutputInterface $output)\\n    {\\n        $file = $input->getArgument('file');\\n        $pipeline = (new Pipeline)\\n            ->pipe(new ConvertPdfToPng)\\n            ->pipe(new ReadFile)\\n            ->pipe(new StripTabs)\\n            ->pipe(new GetPolicyNumber)\\n            ->pipe(new Classify);\\n        $response = $pipeline->process($file);\\n        $output->writeln(\\\"Classification is \\\".$response['classification']);\\n        $output->writeln(\\\"Policy number is \\\".$response['policy']);\\n    }\\n}\\n\")), mdx(\"p\", null, \"Note how our command accepts the file name as an argument. We then instantiate our pipeline and pass it through a series of classes, each of which has a single role. Finally, we retrieve our response and output it.\"), mdx(\"p\", null, \"With that done, we can move on to implementing our first step. Save this as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src/Stages/ConvertPdfToPng.php\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace Matthewbdaly\\\\LetterClassifier\\\\Stages;\\n\\nuse Imagick;\\n\\nclass ConvertPdfToPng\\n{\\n    public function __invoke($file)\\n    {\\n        $tmp = tmpfile();\\n        $uri = stream_get_meta_data($tmp)['uri'];\\n        $img = new Imagick();\\n        $img->setResolution(300, 300);\\n        $img->readImage($file);\\n        $img->setImageDepth(8);\\n        $img->setImageFormat('png');\\n        $img->writeImage($uri);\\n        return $tmp;\\n    }\\n}\\n\")), mdx(\"p\", null, \"This stage fetches the file passed through, and converts it into a PNG file, stores it as a temporary file, and returns a reference to it. The output of this stage will then form the input of the next. This is how pipelines work, and it makes it easy to break up a complex process into multiple steps that can be reused in different places, facilitating easier code reuse and making your code simpler to understand and reason about.\"), mdx(\"p\", null, \"Our next step carries out optical character recognition. Save this as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src/Stages/ReadFile.php\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace Matthewbdaly\\\\LetterClassifier\\\\Stages;\\n\\nuse thiagoalessio\\\\TesseractOCR\\\\TesseractOCR;\\n\\nclass ReadFile\\n{\\n    public function __invoke($file)\\n    {\\n        $uri = stream_get_meta_data($file)['uri'];\\n        $ocr = new TesseractOCR($uri);\\n        return $ocr->lang('eng')->run();\\n    }\\n}\\n\")), mdx(\"p\", null, \"As you can see, this accepts the link to the temporary file as an argument, and runs Tesseract on it to retrieve the text. Note that we specify a language of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"eng\"), \" - if you want to use a language other than English, you should specify it here.\"), mdx(\"p\", null, \"At this point, we should have some usable text, but there may be unknown amounts of whitespace, so our next step uses a regex to strip them out. Save this as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src/Stages/StripTabs.php\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace Matthewbdaly\\\\LetterClassifier\\\\Stages;\\n\\nclass StripTabs\\n{\\n    public function __invoke($content)\\n    {\\n        return trim(preg_replace('/\\\\s+/', ' ', $content));\\n    }\\n}\\n\")), mdx(\"p\", null, \"With our whitespace issue sorted out, we now need to retrieve the policy number the communication should be filed under. These are generally regular alphanumeric patterns, so regexes are a suitable way of matching them. As this is a proof of concept, we'll assume a very simple pattern for policy numbers in that they will consist of between seven and nine digits. Save this as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src/Stages/GetPolicyNumber.php\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace Matthewbdaly\\\\LetterClassifier\\\\Stages;\\n\\nclass GetPolicyNumber\\n{\\n    public function __invoke($content)\\n    {\\n        $matches = [];\\n        $policyNumber = '';\\n        preg_match('/\\\\d{7,9}/', $content, $matches);\\n        if (count($matches)) {\\n            $policyNumber = $matches[0];\\n        }\\n        return [\\n            'content' => $content,\\n            'policy' => $policyNumber\\n        ];\\n    }\\n}\\n\")), mdx(\"p\", null, \"Finally, we're onto the really tough part - using machine learning to classify the letters. Save this as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src/Stages/Classify.php\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace Matthewbdaly\\\\LetterClassifier\\\\Stages;\\n\\nuse Phpml\\\\Dataset\\\\CsvDataset;\\nuse Phpml\\\\Dataset\\\\ArrayDataset;\\nuse Phpml\\\\FeatureExtraction\\\\TokenCountVectorizer;\\nuse Phpml\\\\Tokenization\\\\WordTokenizer;\\nuse Phpml\\\\CrossValidation\\\\StratifiedRandomSplit;\\nuse Phpml\\\\FeatureExtraction\\\\TfIdfTransformer;\\nuse Phpml\\\\Metric\\\\Accuracy;\\nuse Phpml\\\\Classification\\\\SVC;\\nuse Phpml\\\\SupportVectorMachine\\\\Kernel;\\n\\nclass Classify\\n{\\n    protected $classifier;\\n\\n    protected $vectorizer;\\n\\n    protected $tfIdfTransformer;\\n\\n    public function __construct()\\n    {\\n        $this->dataset = new CsvDataset('data/letters.csv', 1);\\n        $this->vectorizer = new TokenCountVectorizer(new WordTokenizer());\\n        $this->tfIdfTransformer = new TfIdfTransformer();\\n        $samples = [];\\n        foreach ($this->dataset->getSamples() as $sample) {\\n                $samples[] = $sample[0];\\n        }\\n        $this->vectorizer->fit($samples);\\n        $this->vectorizer->transform($samples);\\n        $this->tfIdfTransformer->fit($samples);\\n        $this->tfIdfTransformer->transform($samples);\\n        $dataset = new ArrayDataset($samples, $this->dataset->getTargets());\\n        $randomSplit = new StratifiedRandomSplit($dataset, 0.1);\\n        $this->classifier = new SVC(Kernel::RBF, 10000);\\n        $this->classifier->train($randomSplit->getTrainSamples(), $randomSplit->getTrainLabels());\\n        $predictedLabels = $this->classifier->predict($randomSplit->getTestSamples());\\n        echo 'Accuracy: '.Accuracy::score($randomSplit->getTestLabels(), $predictedLabels);\\n    }\\n\\n    public function __invoke(array $message)\\n    {\\n        $newSample = [$message['content']];\\n        $this->vectorizer->transform($newSample);\\n        $this->tfIdfTransformer->transform($newSample);\\n        $message['classification'] = $this->classifier->predict($newSample)[0];\\n        return $message;\\n    }\\n}\\n\")), mdx(\"p\", null, \"In our constructor, we train up our model by passing our sample data through the following steps:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"First, we use the token count vectorizer to convert our samples to a vector of token counts - replacing every word with a number and keeping track of how often that word occurs.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Next, we use \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TfIdfTransformer\"), \" to get statistics about how important a word is in a document.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Then we instantiate our classifier and train it on a random subset of our data.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Finally, we pass our message to our now-trained classifier and see what it tells us.\")), mdx(\"p\", null, \"Now, bear in mind I don't have a background in machine learning and this is the first time I've done anything with machine learning, so I can't tell you much more than that - if you want to know more I suggest you investigate on your own. In figuring this out I was helped a great deal by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.sitepoint.com/how-to-analyze-tweet-sentiments-with-php-machine-learning/\"\n  }, \"this article on Sitepoint\"), \", so you might want to start there.\"), mdx(\"p\", null, \"The finished application is \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/matthewbdaly/letter-classifier\"\n  }, \"on GitHub\"), \", and the repository includes a CSV file of training data, as well as the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"examples\"), \" folder, which contains some example PDF files. You can run it as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ php app process examples/Quote.pdf\\n\")), mdx(\"p\", null, \"I found that once I had trained it up using the CSV data from the repository, it was around 70-80% accurate, which isn't bad at all considering the comparatively small size of the dataset. If this were genuinely being used in production, there would be an extremely large dataset of historical scanned letters to use for training purposes, so it wouldn't be unreasonable to expect much better results under those circumstances.\"), mdx(\"h2\", null, \"Exercises for the reader\"), mdx(\"p\", null, \"If you want to develop this concept further, here are some ideas:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We should be able to correct the model when it's wrong. Add a separate command to train the model by passing through a file and specifying how it should be categorised, eg \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"php app train File.pdf quote\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Try processing information from different sources. For instance, you could replace the first two stages with a stage that pulls all unread emails from a specified mailbox using PHP's IMAP support, or fetching data from the Twitter API. Or you could have a telephony service such as Twilio set up as your voicemail, and automatically transcribe them, then pass the text to PHP ML for classification.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If you're multilingual, you could try adding a step to sort letters by language and have separate models for classifying in each language\")), mdx(\"h2\", null, \"Summary\"), mdx(\"p\", null, \"It's actually quite a sobering thought that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"already\"), \" it's possible to use techniques like these to produce tools that replace people in various jobs, and as the tooling matures more and more tasks involving classification are going to become amenable to automation using machine learning.\"), mdx(\"p\", null, \"This was my first experience with machine learning and it's been very interesting for me to solve a real-world problem with it. I hope it gives you some ideas about how you could use it too.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"PHP isn't the first language that springs to mind when it comes to machine learning. However, it is practical to use PHP for machine learning purposes. In this tutorial I'll show…","frontmatter":{"title":"Building a letter classifier in PHP with Tesseract OCR and PHP ML","date":"10 May 2018","categories":["php","machine-learning"]},"fields":{"path":"/blog/2018/05/10/building-a-letter-classifier-in-php-with-tesseract-ocr-and-php-ml/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2018/04/29/console-applications-with-the-symfony-console-component/"},"frontmatter":{"title":"Console applications with the Symfony Console component","date":"2018-04-29 20:59:27 +0100","layout":"post"}},"next":{"fields":{"path":"/blog/2018/05/13/full-text-search-with-mariadb/"},"frontmatter":{"title":"Full-text search with MariaDB","date":"2018-05-13 14:55:42 +0100","layout":"post"}}}},"staticQueryHashes":["2909664151"]}