{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2018/05/13/full-text-search-with-mariadb/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"1820cd1b-6444-541c-b49c-e03fbe90d9f2","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Full-text search with MariaDB\",\n  \"date\": \"2018-05-13 14:55:42 +0100\",\n  \"layout\": \"post\",\n  \"categories\": [\"mysql\", \"mariadb\", \"sql\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Recently I had the occasion to check out MariaDB's implementation of full-text search. As it's a relatively recent arrival in MySQL and MariaDB, it doesn't seem to get all that much attention. In this post I'll show you how to use it, with a few Laravel-specific pointers. We'll be using the default \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"User\"), \" model in a new Laravel installation, which has columns for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"email\"), \".\"), mdx(\"p\", null, \"Our first task is to create the fulltext index, which is necessary to perform the query. Run the following command:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"ALTER TABLE users ADD FULLTEXT (name, email);\\n\")), mdx(\"p\", null, \"As you can see, we can specify multiple columns in our table to index.\"), mdx(\"p\", null, \"If you're using Laravel, you'll want to create the following migration for this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nuse Illuminate\\\\Support\\\\Facades\\\\Schema;\\nuse Illuminate\\\\Database\\\\Schema\\\\Blueprint;\\nuse Illuminate\\\\Database\\\\Migrations\\\\Migration;\\n\\nclass AddFulltextIndexForUsers extends Migration\\n{\\n    /**\\n     * Run the migrations.\\n     *\\n     * @return void\\n     */\\n    public function up()\\n    {\\n        DB::statement('ALTER TABLE users ADD FULLTEXT(name, email)');\\n    }\\n\\n    /**\\n     * Reverse the migrations.\\n     *\\n     * @return void\\n     */\\n    public function down()\\n    {\\n        DB::statement('ALTER TABLE users DROP INDEX IF EXISTS name');\\n    }\\n}\\n\")), mdx(\"p\", null, \"Note that the index is named after the first field passed to it, so when we drop it we refer to it as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \". Then, to actually query the index, you should run a command something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT * FROM users WHERE MATCH(name, email) AGAINST ('jeff' IN NATURAL LANGUAGE MODE);\\n\")), mdx(\"p\", null, \"Note that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NATURAL LANGUAGE MODE\"), \" is actually the default, so you can leave it off if you wish. We also have to specify the columns to match against.\"), mdx(\"p\", null, \"If you're using Laravel, you may want to create a reusable local scope for it:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    public function scopeSearch($query, $search)\\n    {\\n        if (!$search) {\\n            return $query;\\n        }\\n        return $query->whereRaw('MATCH(name, email) AGAINST (?)', [$search]);\\n    }\\n\")), mdx(\"p\", null, \"Then you can call it as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"User::search('jeff')->get();\\n\")), mdx(\"p\", null, \"I personally have noticed that the query using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MATCH\"), \" keywords seems to be far more performant, with the response time being between five and ten times less than a similar command using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LIKE\"), \", however this observation isn't very scientific (plus, we are talking about queries that still run in a fraction of a second). However, if you're doing a particularly expensive query that currently uses a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LIKE\"), \" statement, it's possible you may get better results by switching to a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MATCH\"), \" statement. Full-text search probably isn't all that useful in this context - it's only once we're talking about longer text, such as blog posts, that some of the advantages like support for stopwords comes into play.\"), mdx(\"p\", null, \"From what I've seen this implementation of full-text search is a lot simpler than in PostgreSQL, which has ups and downs. On the one hand, it's a lot easier to implement, but conversely it's less useful - there's no obvious way to perform a full-text search against joined tables. However, it does seem to be superior to using a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LIKE\"), \" statement, so it's probably a good fit for smaller sites where something like Elasticsearch would be overkill.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Recently I had the occasion to check out MariaDB's implementation of full-text search. As it's a relatively recent arrival in MySQL and MariaDB, it doesn't seem to get all thatâ€¦","frontmatter":{"title":"Full-text search with MariaDB","date":"13th May 2018 1:55 pm","isoDate":"2018-05-13T13:55:42+00:00","categories":["mysql","mariadb","sql"]},"fields":{"path":"/blog/2018/05/13/full-text-search-with-mariadb/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2018/05/10/building-a-letter-classifier-in-php-with-tesseract-ocr-and-php-ml/"},"frontmatter":{"title":"Building a letter classifier in PHP with Tesseract OCR and PHP ML","date":"2018-05-10 22:50:08 +0000","layout":"post"}},"next":{"fields":{"path":"/blog/2018/06/03/logging-to-the-elk-stack-with-laravel/"},"frontmatter":{"title":"Logging to the ELK stack with Laravel","date":"2018-06-03 16:30:54 +0100","layout":"post"}}}},"staticQueryHashes":["290055352","3373576264"]}