{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2018/04/22/rendering-different-views-for-mobile-and-desktop-clients-in-laravel/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"2e7dc205-119b-59d8-9a3e-4dcf9968bbbb","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Rendering different views for mobile and desktop clients in Laravel\",\n  \"date\": \"2018-04-22 22:50:10 +0000\",\n  \"layout\": \"post\",\n  \"categories\": [\"php\", \"laravel\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This was a bit of a weird post to write. It started out explaining how I resolved an issue years ago on a CodeIgniter site, but amended to work for Laravel. In the process, I realised it made sense to implement it as middleware, and I ended up pulling it out into \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/matthewbdaly/laravel-dynamic-serving\"\n  }, \"a package\"), \". However, it's still useful to understand the concept behind it, even if you prefer to just install the complete package, because your needs might be slightly different to mine.\"), mdx(\"p\", null, \"On web development forums, it's quite common to see variants of the following question:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"How do I redirect a user on a mobile device to a mobile version of the site?\")), mdx(\"p\", null, \"It's quite surprising that this is still an issue that crops up. For many years, it's been widely accepted that the correct solution for this problem is responsive design. However, there are ways in which this may not be adequate for certain applications. For instance, you may have an application where certain functionality only makes sense in a certain context, or your user interface may need to be optimised for specific environments.\"), mdx(\"p\", null, \"The trouble is that a dedicated mobile site isn't a good idea either. Among other things, it means that users can't easily use the same bookmarks between desktop and mobile versions, and can result in at least some of the server-side logic being duplicated.\"), mdx(\"p\", null, \"Fortunately, there is another way - \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://developers.google.com/search/mobile-sites/mobile-seo/dynamic-serving\"\n  }, \"dynamic serving\"), \" allows you to render different content based on the user agent. You can also easily enable users to switch between desktop and mobile versions themselves if their client isn't detected correctly or they just prefer the other one. I've implemented this years ago for a CodeIgniter site. Here's how you might implement it in Laravel, although if you understand the principle behind it, it should be easy to adapt for any other framework.\"), mdx(\"p\", null, \"Don't try to implement mobile user agent detection yourself. Instead, find an implementation that's actively maintained and install it with Composer. That way you can be reasonably sure that as new mobile devices come onto the market the package will detect them correctly as long as you keep it up to date. I would be inclined to go for \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/jenssegers/agent\"\n  }, \"Agent\"), \", since it has Laravel support baked in.\"), mdx(\"p\", null, \"We could just use Agent to serve up different content based on the user agent. However, user agent strings are notoriously unreliable - if a new mobile device appears and it doesn't show up correctly in Agent, users could find themselves forced to use the wrong UI. Instead, we need to check for a flag in the session that indicates if the session is mobile or not. If it's not set, we set it based on the user agent. That way, if you need to offer functionality to override the detected session type, you can just update that session variable to correct that elsewhere in the application. I would be inclined to use a button in the footer that makes an AJAX request to toggle the flag, then reloads the page.\"), mdx(\"p\", null, \"You also need to set the HTTP response header \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Vary: User-Agent\"), \" to notify clients (including not only search engines, but also proxies at either end of the connection, such as Varnish or Squid) that the response will differ by user agent, in order to prevent users being served the wrong version.\"), mdx(\"p\", null, \"Middleware is the obvious place to do this. Here's a middleware that sets the session variable and the appropriate response headers:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Http\\\\Middleware;\\n\\nuse Closure;\\nuse Jenssegers\\\\Agent\\\\Agent;\\nuse Illuminate\\\\Contracts\\\\Session\\\\Session;\\n\\nclass DetectMobile\\n{\\n    protected $agent;\\n\\n    protected $session;\\n\\n    public function __construct(Agent $agent, Session $session)\\n    {\\n        $this->agent = $agent;\\n        $this->session = $session;\\n    }\\n\\n    /**\\n     * Handle an incoming request.\\n     *\\n     * @param  \\\\Illuminate\\\\Http\\\\Request  $request\\n     * @param  \\\\Closure  $next\\n     * @return mixed\\n     */\\n    public function handle($request, Closure $next)\\n    {\\n        if (!$this->session->exists('mobile')) {\\n            if ($this->agent->isMobile() || $this->agent->isTablet()) {\\n                $this->session->put('mobile', true);\\n            } else {\\n                $this->session->put('mobile', false);\\n            }\\n        }\\n        $response = $next($request);\\n        return $response->setVary('User-Agent');\\n    }\\n}\\n\")), mdx(\"p\", null, \"Now, you could then work with the session directly to retrieve the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mobile\"), \" flag, but as you may be working in the view, it makes sense to create helpers for this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nif (!function_exists('is_mobile')) {\\n    function is_mobile()\\n    {\\n        $session = app()->make('Illuminate\\\\Contracts\\\\Session\\\\Session');\\n        return $session->get('mobile') == true;\\n    }\\n}\\n\\nif (!function_exists('is_desktop')) {\\n    function is_desktop()\\n    {\\n        $session = app()->make('Illuminate\\\\Contracts\\\\Session\\\\Session');\\n        return $session->get('mobile') == false;\\n    }\\n}\\n\")), mdx(\"p\", null, \"Now, if you want to serve up completely different views, you can use these helpers in your controllers. If you instead want to selectively show and hide parts of the UI based on the user agent, you can instead use these in the views to determine what parts of the page should be shown.\"), mdx(\"p\", null, \"Agent offers more functionality than just detecting if a user agent is a mobile or desktop device, and you may find this useful as a starting point for developing middleware for detecting bots, or showing different content to users based on their device type or operating system. If you just need to detect if a user is a mobile or desktop client, this middleware should be sufficient.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"This was a bit of a weird post to write. It started out explaining how I resolved an issue years ago on a CodeIgniter site, but amended to work for Laravel. In the process, Iâ€¦","frontmatter":{"title":"Rendering different views for mobile and desktop clients in Laravel","date":"22 April 2018","categories":["php","laravel"]},"fields":{"path":"/blog/2018/04/22/rendering-different-views-for-mobile-and-desktop-clients-in-laravel/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2018/04/12/making-wordpress-less-shit/"},"frontmatter":{"title":"Making Wordpress less shit","date":"2018-04-12 23:57:05 +0100","layout":"post"}},"next":{"fields":{"path":"/blog/2018/04/29/console-applications-with-the-symfony-console-component/"},"frontmatter":{"title":"Console applications with the Symfony Console component","date":"2018-04-29 20:59:27 +0100","layout":"post"}}}},"staticQueryHashes":["2909664151"]}