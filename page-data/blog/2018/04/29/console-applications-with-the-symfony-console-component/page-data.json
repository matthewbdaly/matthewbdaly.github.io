{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2018/04/29/console-applications-with-the-symfony-console-component/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"b57d3451-3671-5889-b3fc-c1d849b79261","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Console applications with the Symfony Console component\",\n  \"date\": \"2018-04-29 20:59:27 +0100\",\n  \"layout\": \"post\",\n  \"categories\": [\"php\", \"symfony\", \"console\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Recently I've had the occasion to add a series of console commands to a legacy application. This can be made straightforward by using the Symfony console component. In this post I'll demonstrate how to write a simple console command for clearing a cache folder.\"), mdx(\"p\", null, \"The first step is to install the Console component:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ composer require symfony/console\\n\")), mdx(\"p\", null, \"Then we write the main script for the application. I usually save mine as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console\"), \" - note that we don't want to have to type out a file extension, so instead we use the shebang:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"#!/user/bin/env php\\n<?php\\n\\nrequire __DIR__.'/vendor/autoload.php';\\n\\nuse Symfony\\\\Component\\\\Console\\\\Application;\\n\\ndefine('CONSOLE_ROOT', __DIR__);\\n$app = new Application();\\n\\n$app->run();\\n\")), mdx(\"p\", null, \"In this case, I've defined \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CONSOLE_ROOT\"), \" as the directory in which the console command is run - that way, the commands can use it to refer to the application root.\"), mdx(\"p\", null, \"We can then run our console application as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ php console\\nConsole Tool\\n\\nUsage:\\n  command [options] [arguments]\\n\\nOptions:\\n  -h, --help            Display this help message\\n  -q, --quiet           Do not output any message\\n  -V, --version         Display this application version\\n      --ansi            Force ANSI output\\n      --no-ansi         Disable ANSI output\\n  -n, --no-interaction  Do not ask any interactive question\\n  -v|vv|vvv, --verbose  Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug\\n\\nAvailable commands:\\n  help  Displays help for a command\\n  list  Lists commands\\n\")), mdx(\"p\", null, \"This displays the available commands, but you'll note that there are none except for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"help\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"list\"), \". We'll remedy that. First, we'll register a command:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"$app->add(new App\\\\Console\\\\ClearCacheCommand);\\n\")), mdx(\"p\", null, \"This has to be done in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console\"), \", after we create \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$app\"), \", but before we run it.\"), mdx(\"p\", null, \"Don't forget to update the autoload section of your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"composer.json\"), \" to register the namespace:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"    \\\"autoload\\\": {\\n        \\\"psr-4\\\": {\\n            \\\"App\\\\\\\\Console\\\\\\\\\\\": \\\"src/Console/\\\"\\n        }\\n    },\\n\")), mdx(\"p\", null, \"Then create the class for that command. This class must extend \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Symfony\\\\Component\\\\Console\\\\Command\\\\Command\"), \", and must have two methods:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"configure()\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"execute()\"))), mdx(\"p\", null, \"In addition, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"execute()\"), \" method must accept two arguments, an instance of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Symfony\\\\Component\\\\Console\\\\Input\\\\InputInterface\"), \", and an instance of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Symfony\\\\Component\\\\Console\\\\Output\\\\OutputInterface\"), \". There are used to retrieve input and display output.\"), mdx(\"p\", null, \"Let's write our command:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Console;\\n\\nuse Symfony\\\\Component\\\\Console\\\\Command\\\\Command;\\nuse Symfony\\\\Component\\\\Console\\\\Input\\\\InputInterface;\\nuse Symfony\\\\Component\\\\Console\\\\Output\\\\OutputInterface;\\n\\nclass ClearCacheCommand extends Command\\n{\\n    protected function configure()\\n    {\\n        $this->setName('cache:clear')\\n             ->setDescription('Clears the cache')\\n             ->setHelp('This command clears the application cache');\\n    }\\n\\n    protected function execute(InputInterface $input, OutputInterface $output)\\n    {\\n        $dir = CONSOLE_ROOT.DIRECTORY_SEPARATOR.'cache';\\n        $this->deleteTree($dir);\\n        $output->writeln('Cache cleared');\\n    } \\n\\n    private function deleteTree($dir)\\n    {\\n        $files = array_diff(scandir($dir), array('.','..')); \\n        foreach ($files as $file) { \\n            (is_dir(\\\"$dir/$file\\\")) ? $this->deleteTree(\\\"$dir/$file\\\") : unlink(\\\"$dir/$file\\\"); \\n        } \\n        return rmdir($dir); \\n    }\\n}\\n\")), mdx(\"p\", null, \"As you can see, in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"configure()\"), \" method, we set the name, description and help text for the command.\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"execute()\"), \" method is where the actual work is done. In this case, we have some code that needs to be called recursively, so we have to pull it out into a private method. Once that's done we use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$output->writeln()\"), \" to write a line to the output.\"), mdx(\"p\", null, \"Now, if we run our console task, we should see our new command:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ php console\\nConsole Tool\\n\\nUsage:\\n  command [options] [arguments]\\n\\nOptions:\\n  -h, --help            Display this help message\\n  -q, --quiet           Do not output any message\\n  -V, --version         Display this application version\\n      --ansi            Force ANSI output\\n      --no-ansi         Disable ANSI output\\n  -n, --no-interaction  Do not ask any interactive question\\n  -v|vv|vvv, --verbose  Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug\\n\\nAvailable commands:\\n  help         Displays help for a command\\n  list         Lists commands\\n cache\\n  cache:clear  Clears the cache\\n\")), mdx(\"p\", null, \"And we can see it in action too:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ php console cache:clear\\nCache cleared\\n\")), mdx(\"p\", null, \"For commands that need to accept additional arguments, you can define them in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"configure()\"), \" method:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"$this->addArgument('file', InputArgument::REQUIRED, 'Which file do you want to delete?')\\n\")), mdx(\"p\", null, \"Then, you can access it in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"execute()\"), \" method using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"InputInterface\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"$file = $input->getArgument('file');\\n\")), mdx(\"p\", null, \"This tutorial is just skimming the surface of what you can do with the Symfony Console components - indeed, many other console interfaces, such as Laravel's Artisan, are built on top of it. If you have a legacy application built in a framework that lacks any sort of console interface, such as CodeIgniter, then you can quite quickly produce basic console commands for working with that application. The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://symfony.com/doc/current/console.html\"\n  }, \"documentation is very good\"), \", and with a little work you can soon have something up and running.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Recently I've had the occasion to add a series of console commands to a legacy application. This can be made straightforward by using the Symfony console component. In this post I…","frontmatter":{"title":"Console applications with the Symfony Console component","date":"29th April 2018 7:59 pm","isoDate":"2018-04-29T19:59:27+00:00","categories":["php","symfony","console"]},"fields":{"path":"/blog/2018/04/29/console-applications-with-the-symfony-console-component/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2018/04/22/rendering-different-views-for-mobile-and-desktop-clients-in-laravel/"},"frontmatter":{"title":"Rendering different views for mobile and desktop clients in Laravel","date":"2018-04-22 22:50:10 +0000","layout":"post"}},"next":{"fields":{"path":"/blog/2018/05/10/building-a-letter-classifier-in-php-with-tesseract-ocr-and-php-ml/"},"frontmatter":{"title":"Building a letter classifier in PHP with Tesseract OCR and PHP ML","date":"2018-05-10 22:50:08 +0000","layout":"post"}}}},"staticQueryHashes":["290055352","2909664151"]}