{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2018/12/06/decorating-service-classes/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"59a6c51b-3f4e-5614-8438-ba7c77a18c65","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Decorating service classes\",\n  \"date\": \"2018-12-06 18:34:16 +0000\",\n  \"layout\": \"post\",\n  \"categories\": [\"php\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I've written before about using decorators to extend the functionality of existing classes, in the context of the repository pattern when working with Eloquent. However, the same practice is applicable in many other contexts.\"), mdx(\"p\", null, \"Recently, I was asked to add RSS feeds to the home page of the legacy project that is my main focus these days. The resulting service class looked something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Services;\\n\\nuse Rss\\\\Feed\\\\Reader;\\nuse App\\\\Contracts\\\\Services\\\\FeedFetcher;\\n\\nclass RssFetcher implements FeedFetcher\\n{\\n    public function fetch($url)\\n    {\\n        return Reader::import($url);\\n    }\\n}\\n\")), mdx(\"p\", null, \"In accordance with the principle of loose coupling, I also created an interface for it:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Contracts\\\\Services;\\n\\ninterface FeedFetcher\\n{\\n    public function fetch($url);\\n}\\n\")), mdx(\"p\", null, \"I was recently able to add dependency injection to the project using PHP-DI, so now I can inject an instance of the feed fetcher into the controller by typehinting the interface and having it resolve to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RssFetcher\"), \" class.\"), mdx(\"p\", null, \"However, there was an issue. I didn't want the application to make multiple HTTP requests to fetch those feeds every time the page loads. At the same time, it was also a bit much to have a scheduled task running to fetch those feeds and store them in the database, since many times that would be unnecessary. The obvious solution was to cache the feed content for a specified length of time, in this case five minutes.\"), mdx(\"p\", null, \"I \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"could\"), \" have integrated the caching into the service class itself, but that wasn't the best practice, because it would be tied to that implementation. If in future we needed to switch to a different feed handler, we'd have to re-implement the caching functionality. So I decided it made sense to decorate the service class.\"), mdx(\"p\", null, \"The decorator class implemented the same interface as the feed fetcher, and accepted another instance of that interface in the constructor, along with a PSR6-compliant caching library. It looked something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Services;\\n\\nuse App\\\\Contracts\\\\Services\\\\FeedFetcher;\\nuse Psr\\\\Cache\\\\CacheItemPoolInterface;\\n\\nclass FetcherCachingDecorator implements FeedFetcher\\n{\\n    protected $fetcher;\\n\\n    protected $cache;\\n\\n    public function __construct(FeedFetcher $fetcher, CacheItemPoolInterface $cache)\\n    {\\n        $this->fetcher = $fetcher;\\n        $this->cache = $cache;\\n    }\\n\\n    public function fetch($url)\\n    {\\n        $item = $this->cache->getItem('feed_'.$url);\\n        if (!$item->isHit()) {\\n            $item->set($this->fetcher->fetch($url));\\n            $this->cache->save($item);\\n        }\\n        return $item->get();\\n    }\\n}\\n\")), mdx(\"p\", null, \"Now, when you instantiate the feed fetcher, you wrap it in the decorator as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\n$fetcher = new FetcherCachingDecorator(\\n        new App\\\\Services\\\\RssFetcher,\\n        $cache\\n);\\n\")), mdx(\"p\", null, \"As you can see, this solves our problem quite nicely. By wrapping our feed fetcher in this decorator, we keep the caching layer completely separate from any one implementation of the fetcher, so in the event we need to swap the current one out for another implementation, we don't have to touch the caching layer at all. As long as we're using dependency injection to resolve this interface, we're only looking at a little more code to instantiate it.\"), mdx(\"p\", null, \"In addition, this same approach can be applied for other purposes, and you can wrap the service class as many times as necessary. For instance, if we wanted to log all the responses we got, we could write a logging decorator something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Services;\\n\\nuse App\\\\Contracts\\\\Services\\\\FeedFetcher;\\nuse Psr\\\\Log\\\\LoggerInterface;\\n\\nclass FeedLoggingDecorator implements FeedFetcher\\n{\\n    protected $fetcher;\\n\\n    protected $logger;\\n\\n    public function __construct(FeedFetcher $fetcher, LoggerInterface $logger)\\n    {\\n        $this->fetcher = $fetcher;\\n        $this->logger = $logger;\\n    }\\n\\n    public function fetch($url)\\n    {\\n        $response = $this->fetcher->fetch($url);\\n        $this->logger->info($response);\\n        return $response;\\n    }\\n}\\n\")), mdx(\"p\", null, \"The same idea can be applied to an API client. For instance, say we have the following interface for an API client:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace Foo\\\\Bar\\\\Contracts;\\n\\nuse Foo\\\\Bar\\\\Objects\\\\Item;\\nuse Foo\\\\Bar\\\\Objects\\\\ItemCollection;\\n\\ninterface Client\\n{\\n    public function getAll(): ItemCollection;\\n\\n    public function find(int $id): Item;\\n\\n    public function create(array $data): Item;\\n\\n    public function update(int $id, array $data): Item;\\n\\n    public function delete(int $id);\\n}\\n\")), mdx(\"p\", null, \"Now, of course any good API client should respect HTTP headers and use those to do some caching itself, but depending on the use case, you may also want to cache these requests yourself. For instance, if the only changes to the entities stored by the third party API will be ones you've made, or they don't need to be 100% up to date, you may be better off caching those responses before they reach the actual API client. Under those circumstances, you might write a decorator like this to do the caching:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace Foo\\\\Bar\\\\Services;\\n\\nuse Foo\\\\Bar\\\\Contracts\\\\Client;\\nuse Psr\\\\Cache\\\\CacheItemPoolInterface;\\n\\nclass CachingDecorator implements Client\\n{\\n    protected $client;\\n\\n    protected $cache;\\n\\n    public function __construct(Client $client, CacheItemPoolInterface $cache)\\n    {\\n        $this->client = $client;\\n        $this->cache = $cache;\\n    }\\n\\n    public function getAll(): ItemCollection\\n    {\\n        $item = $this->cache->getItem('item_all');\\n        if (!$item->isHit()) {\\n            $item->set($this->client->getAll());\\n            $this->cache->save($item);\\n        }\\n        return $item->get();\\n    }\\n\\n    public function find(int $id): Item\\n    {\\n        $item = $this->cache->getItem('item_'.$id);\\n        if (!$item->isHit()) {\\n            $item->set($this->client->find($id));\\n            $this->cache->save($item);\\n        }\\n        return $item->get();\\n\\n    }\\n\\n    public function create(array $data): Item\\n    {\\n        $this->cache->clear();\\n        return $this->client->create($data);\\n    }\\n\\n    public function update(int $id, array $data): Item\\n    {\\n        $this->cache->clear();\\n        return $this->client->update($id, $data);\\n    }\\n\\n    public function delete(int $id)\\n    {\\n        $this->cache->clear();\\n        return $this->client->delete($id);\\n    }\\n}\\n\")), mdx(\"p\", null, \"Any methods that change the state of the data on the remote API will clear the cache, while any that fetch data will first check the cache, only explicitly fetching data from the API when the cache is empty, and caching it again. I won't go into how you might write a logging decorator for this, but it should be straightforward to figure out for yourself.\"), mdx(\"p\", null, \"The decorator pattern is a very powerful way of adding functionality to a class without tying it to a specific implementation. If you're familiar with how middleware works, decorators work in a very similar fashion in that you can wrap your service in as many layers as you wish in order to accomplish specific tasks, and they adhere to the single responsibility principle by allowing you to use different decorators for different tasks.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"I've written before about using decorators to extend the functionality of existing classes, in the context of the repository pattern when working with Eloquent. However, the sameâ€¦","frontmatter":{"title":"Decorating service classes","date":"6th December 2018 6:34 pm","isoDate":"2018-12-06T18:34:16+00:00","categories":["php"]},"fields":{"path":"/blog/2018/12/06/decorating-service-classes/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2018/10/20/simplify-your-tests-with-anonymous-classes/"},"frontmatter":{"title":"Simplify your tests with anonymous classes","date":"2018-10-20 14:48:05 +0100","layout":"post"}},"next":{"fields":{"path":"/blog/2018/12/27/improving-search-in-vim-and-neovim-with-fzf-and-ripgrep/"},"frontmatter":{"title":"Improving search in Vim and Neovim with FZF and Ripgrep","date":"2018-12-27 18:37:09 +0000","layout":"post"}}}},"staticQueryHashes":["290055352","2909664151"]}