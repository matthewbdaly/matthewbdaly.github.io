{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2018/07/25/better-strings-in-php/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"5e50b9d4-128e-59d5-99e9-405cc7940358","body":"var _excluded = [\"components\"];\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Better strings in PHP\",\n  \"layout\": \"post\",\n  \"date\": \"2018-07-25 22:25:17 +0100\",\n  \"categories\": [\"php\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"One of the weaknesses of PHP as a programming language is the limitations of some of the fundamental types. For instance, a string in PHP is a simple value, rather than an object, and doesn't have any methods associated with it. Instead, to manipulate a string, you have to call all manner of functions. By comparison, in Python, not only can you call methods on a string, and receive a new string as the response, making them easily chainable, but you can also iterate through a string, as in this example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \">>> a = 'foo'\\n>>> a.upper()\\n'FOO'\\n>>> a.lower()\\n'foo'\\n>>> for letter in a:\\n...   print(letter)\\n...\\nf\\no\\no\\n\")), mdx(\"p\", null, \"A little while back, I read Adam Wathan's excellent book \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Refactoring to Collections\"), \", which describes how you can use a collection implementation (such as the one included with Laravel) to replace convoluted array manipulation with simpler, chainable calls to a collection object. Using this approach, you can turn something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"$result = array_filter(\\n    array_map(function ($item) {\\n        return $item->get('foo');\\n    }, $items),\\n    function ($item) {\\n        return $item->bar == true;\\n});\\n\")), mdx(\"p\", null, \"Or, even worse, this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"$result1 = array_map(function ($item) {\\n    return $item->get('foo');\\n}, $items);\\n$result2 = array_filter($result1, function ($item) {\\n    return $item->bar == true;\\n});\\n\")), mdx(\"p\", null, \"Into this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"$result = Collection::make($items)\\n    ->map(function ($item) {\\n        return $item->get('foo');\\n    })->filter(function ($item) {\\n        return $item->bar == true;\\n    })->toArray();\\n\")), mdx(\"p\", null, \"Much cleaner, more elegant, and far easier to understand.\"), mdx(\"p\", null, \"A while back, after some frustration with PHP's native strings, I started wondering how practical it would be to produce a string implementation that was more like the string objects in languages like Python and Javascript, with inspiration from collection implementations such as that used by Laravel. I soon discovered that it was very practical, and with a bit of work it's not hard to produce your own, more elegant string class.\"), mdx(\"p\", null, \"The most fundamental functionality required is to be able to create a string object, either by passing a string to the constructor or calling a static method. Our string class should be able to do both:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nclass Str\\n{\\n    protected $string;\\n\\n    public function __construct(string $string = '')\\n    {\\n        $this->string = $string;\\n    }\\n\\n    public static function make(string $string)\\n    {\\n        return new static($string);\\n    }\\n}\\n\")), mdx(\"h2\", null, \"Making it iterable\"), mdx(\"p\", null, \"To be able to get the length of a string, it needs to implement the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://php.net/manual/en/class.countable.php\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Countable\")), \" interface:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"use Countable;\\n\\nclass Str implements Countable\\n{\\n    ...\\n    public function count()\\n    {\\n        return strlen($this->string);\\n    }\\n}\\n\")), mdx(\"p\", null, \"To access it as an array, it needs to implement the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://php.net/manual/en/class.arrayaccess.php\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"ArrayAccess\")), \" interface:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"...\\nuse ArrayAccess;\\n\\nclass Str implements Countable, ArrayAccess\\n{\\n    ...\\n    public function offsetExists($offset)\\n    {\\n        return isset($this->string[$offset]);\\n    }\\n\\n    public function offsetGet($offset)\\n    {\\n        return isset($this->string[$offset]) ? $this->string[$offset] : null;\\n    }\\n\\n    public function offsetSet($offset, $value)\\n    {\\n        if (is_null($offset)) {\\n            $this->string[] = $value;\\n        } else {\\n            $this->string[$offset] = $value;\\n        }\\n    }\\n\\n    public function offsetUnset($offset)\\n    {\\n        $this->string = substr_replace($this->string, '', $offset, 1);\\n    }\\n}\\n\")), mdx(\"p\", null, \"And to make it iterable, it needs to implement the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://php.net/manual/en/class.iterator.php\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Iterator\")), \" interface:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"use Iterator;\\n\\nclass Str implements Countable, ArrayAccess, Iterator\\n{\\n    ...\\n    public function current()\\n    {\\n        return $this->string[$this->position];\\n    }\\n\\n    public function key()\\n    {\\n        return $this->position;\\n    }\\n\\n    public function next()\\n    {\\n        ++$this->position;\\n    }\\n\\n    public function rewind()\\n    {\\n        $this->position = 0;\\n    }\\n\\n    public function valid()\\n    {\\n        return isset($this->string[$this->position]);\\n    }\\n}\\n\")), mdx(\"h2\", null, \"Making it work as a string\"), mdx(\"p\", null, \"To be useful, it also needs to be possible to actually use it as a string - for instance, you should be able to do this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"$foo = Str::make('I am the very model of a modern major general');\\necho $foo;\\n\")), mdx(\"p\", null, \"Fortunately, the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://php.net/manual/en/language.oop5.magic.php#object.tostring\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"__toString()\")), \" magic method allows this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    public function __toString()\\n    {\\n        return $this->string;\\n    }\\n\")), mdx(\"h2\", null, \"Adding methods\"), mdx(\"p\", null, \"With that functionality in place, you can then start adding support for the methods you need in your string objects. If you're looking to be able to use the same functionality as existing PHP methods, you can call those functions inside your methods. However, be sure to return a new instance of your string object from each method - that way, you can continually chain them:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    public function replace($find, $replace)\\n    {\\n        return new static(str_replace($find, $replace, $this->string));\\n    }\\n\\n    public function toUpper()\\n    {\\n        return new static(strtoupper($this->string));\\n    }\\n\\n    public function toLower()\\n    {\\n        return new static(strtolower($this->string));\\n    }\\n\\n    public function trim()\\n    {\\n        return new static(trim($this->string));\\n    }\\n\\n    public function ltrim()\\n    {\\n        return new static(ltrim($this->string));\\n    }\\n\\n    public function rtrim()\\n    {\\n        return new static(rtrim($this->string));\\n    }\\n\")), mdx(\"p\", null, \"Now, you can write something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"return Str::make('I am the very model of a modern major general  ')\\n    ->trim()\\n    ->replace('modern major general', 'scientist Salarian')\\n    ->toLower();\\n\")), mdx(\"p\", null, \"While you could do this with PHP's native string functions alone, it would be a lot less elegant. In addition, if you have other, more complex string manipulations that you often do in a particular application, it may make sense to write a method for that so that your string objects can encapsulate that functionality for easier reuse.\"), mdx(\"p\", null, \"As our string objects are iterable, we can also do this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \">>> $foo = Str::make('foo');\\n>>> foreach ($foo as $letter) { echo \\\"$letter\\\\n\\\"; }\\nf\\no\\no\\n\")), mdx(\"p\", null, \"If you have an application that does some complex string manipulation, having a string utility class like this can make for much more expressive, elegant and easy-to-comprehend code than PHP's native string functions. If you want to see a working implementation for this, check out my proof of concept collection and string utility library \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/matthewbdaly/proper\"\n  }, \"Proper\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"One of the weaknesses of PHP as a programming language is the limitations of some of the fundamental types. For instance, a string in PHP is a simple value, rather than an objectâ€¦","frontmatter":{"title":"Better strings in PHP","date":"25th July 2018 9:25 pm","isoDate":"2018-07-25T21:25:17+00:00","categories":["php"]},"fields":{"path":"/blog/2018/07/25/better-strings-in-php/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2018/06/23/forcing-ssl-in-codeigniter/"},"frontmatter":{"title":"Forcing SSL in CodeIgniter","date":"2018-06-23 13:03:28 +0100","layout":"post"}},"next":{"fields":{"path":"/blog/2018/09/09/switching-from-vim-to-neovim/"},"frontmatter":{"title":"Switching from Vim to Neovim","date":"2018-09-09 13:40:35 +0100","layout":"post"}}}},"staticQueryHashes":["1776624730","3528622268"]}