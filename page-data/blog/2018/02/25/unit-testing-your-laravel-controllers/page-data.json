{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2018/02/25/unit-testing-your-laravel-controllers/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"60ea2d06-9e7f-5b2b-b828-4a24936fe1aa","body":"var _excluded = [\"components\"];\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Unit testing your Laravel controllers\",\n  \"date\": \"2018-02-25 15:50:44 +0000\",\n  \"layout\": \"post\",\n  \"categories\": [\"php\", \"laravel\", \"tdd\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/blog/2018/02/18/put-your-laravel-controllers-on-a-diet/\"\n  }, \"my previous post\"), \" I mentioned some strategies for refactoring Laravel controllers to move unnecessary functionality elsewhere. However, I didn't cover testing them. In this post I will demonstrate the methodology I use for testing Laravel controllers.\"), mdx(\"p\", null, \"Say we have the following method in a controller:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"public function store(Request $request)\\n{    \\n        $document = new Document($request->only([\\n            'title', \\n            'text', \\n        ]));\\n        $document->save();\\n\\n        event(new DocumentCreated($document));\\n\\n        return redirect()->route('/');\\n}\\n\")), mdx(\"p\", null, \"This controller method does three things:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Return a response\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Create a model instance\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Fire an event\")), mdx(\"p\", null, \"Our tests therefore need to pass it all its external dependencies and check it carries out the required actions.\"), mdx(\"p\", null, \"First we fake the event facade:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    Event::fake();\\n\")), mdx(\"p\", null, \"Next, we create an instance of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Illuminate\\\\Http\\\\Request\"), \" to represent the HTTP request passed to the controller:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    $request = Request::create('/store', 'POST',[\\n        'title'     =>  'foo',\\n        'text'  =>  'bar',\\n    ]);\\n\")), mdx(\"p\", null, \"If you're using a custom form request class, you should instantiate that in exactly the same way.\"), mdx(\"p\", null, \"Then, instantiate the controller, and call the method, passing it the request object:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    $controller = new MyController();\\n    $response = $controller->store($request);\\n\")), mdx(\"p\", null, \"You can then test the response from the controller. You can test the status code like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    $this->assertEquals(302, $response->getStatusCode());\\n\")), mdx(\"p\", null, \"You may also need to check the content of the response matches what you expect to see, by retrieving \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$response->getBody()->getContent()\"), \".\"), mdx(\"p\", null, \"Next, retrieve the newly created model instance, and verify it exists:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    $document = Document::where('title', 'foo')->first();\\n    $this->assertNotNull($document);\\n\")), mdx(\"p\", null, \"You can also use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"assertEquals()\"), \" to check the attributes on the model if appropriate. Finally, you check the event was fired:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    Event::assertDispatched(DocumentCreated::class, function ($event) use ($document) { \\n        return $event->document->id === $document->id; \\n    });\\n\")), mdx(\"p\", null, \"This test should not concern itself with any functionality triggered by the event, only that the event gets triggered. The event should have separate unit tests in which the event is triggered, and then the test verifies it carried out the required actions.\"), mdx(\"p\", null, \"Technically, these don't quite qualify as being unit tests because they hit the database, but they should cover the controller adequately. To make them true unit tests, you'd need to implement the repository pattern for the database queries rather than using Eloquent directly, and mock the repository, so you can assert that the mocked repository receive the right data and have it return the expected response.\"), mdx(\"p\", null, \"Here is how you might do that with Mockery:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"$mock = Mockery::mock('App\\\\Contracts\\\\Repositories\\\\Document');\\n$mock->shouldReceive('create')->with([\\n    'title' =>      'foo',\\n    'text'  =>      'bar',\\n])->once()->andReturn(true);\\n$controller = new MyController($mock);\\n\")), mdx(\"p\", null, \"As long as your controllers are kept as small as possible, it's generally not too hard to test them. Unfortunately, fat controllers become almost impossible to test, which is another good reason to avoid them.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"In  my previous post  I mentioned some strategies for refactoring Laravel controllers to move unnecessary functionality elsewhere. However, I didn't cover testing them. In thisâ€¦","frontmatter":{"title":"Unit testing your Laravel controllers","date":"25th February 2018 3:50 pm","isoDate":"2018-02-25T15:50:44+00:00","categories":["php","laravel","tdd"]},"fields":{"path":"/blog/2018/02/25/unit-testing-your-laravel-controllers/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2018/02/18/put-your-laravel-controllers-on-a-diet/"},"frontmatter":{"title":"Put your Laravel controllers on a diet","date":"2018-02-18 18:10:10 +0000","layout":"post"}},"next":{"fields":{"path":"/blog/2018/02/25/check-your-code-base-is-php-7-ready-with-php-compatibility/"},"frontmatter":{"title":"Check your code base is PHP 7 ready with PHP Compatibility","date":"2018-02-25 17:22:34 +0000","layout":"post"}}}},"staticQueryHashes":["1776624730","458490740"]}