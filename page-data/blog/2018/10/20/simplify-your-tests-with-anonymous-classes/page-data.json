{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2018/10/20/simplify-your-tests-with-anonymous-classes/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"c5a940c1-ce39-5008-8f69-a7e3e5a09735","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Simplify your tests with anonymous classes\",\n  \"date\": \"2018-10-20 14:48:05 +0100\",\n  \"layout\": \"post\",\n  \"categories\": [\"php\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Anonymous classes were added in PHP7, but so far I haven't made all that much use of them. However, recently I've been working on building a simple dependency injection container for learning purposes. This uses the PHP Reflection API to determine how to resolve dependencies. For instance, if it's asked for a class for which one of the dependencies required by the constructor is an instance of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DateTime\"), \" class, it should create an instance, and then pass it into the constructor automatically when instantiating the class. Then it should return the newly created class.\"), mdx(\"p\", null, \"Mocking isn't really a suitable approach for this use case because the container needs to return a concrete class instance to do its job properly. You could just create a series of fixture classes purely for testing purposes, but that would mean either defining more than one class in a file (violating PSR-2), or defining a load of fixture classes in separate files, meaning you'd have to write a lot of boilerplate, and you'd have to move between several different files to understand what's going on in the test.\"), mdx(\"p\", null, \"Anonymous classes allow you a means to write simple classes for tests inline, as in this example for retrieving a very basic class. The tests use PHPSpec:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace spec\\\\Vendor\\\\Package;\\n\\nuse Vendor\\\\Package\\\\MyClass;\\nuse PhpSpec\\\\ObjectBehavior;\\nuse Prophecy\\\\Argument;\\nuse DateTime;\\n\\nclass MyClassSpec extends ObjectBehavior\\n{\\n    function it_can_resolve_registered_dependencies()\\n    {\\n        $toResolve = new class {\\n        };\\n        $this->set('Foo\\\\Bar', $toResolve);\\n        $this->get('Foo\\\\Bar')->shouldReturnAnInstanceOf($toResolve);\\n    }\\n}\\n\")), mdx(\"p\", null, \"You can also define your own methods inline. Here we implement the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"invoke()\"), \" magic method so that the class is a callable:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nclass MyClassSpec extends ObjectBehavior\\n{\\n    function it_can_resolve_registered_invokable()\\n    {\\n        $toResolve = new class {\\n            public function __invoke() {\\n                return new DateTime;\\n            }\\n        };\\n        $this->set('Foo\\\\Bar', $toResolve);\\n        $this->get('Foo\\\\Bar')->shouldReturnAnInstanceOf('DateTime');\\n    }\\n}\\n\")), mdx(\"p\", null, \"You can also define a constructor. Here, we're getting the class name of a newly created anonymous class that accepts an instance of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DateTime\"), \" as an argument to the constructor. Then, we can resolve a new instance out of the container:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nclass MyClassSpec extends ObjectBehavior\\n{\\n    function it_can_resolve_dependencies()\\n    {\\n        $toResolve = get_class(new class(new DateTime) {\\n            public $datetime;\\n            public function __construct(DateTime $datetime)\\n            {\\n                $this->datetime = $datetime;\\n            }\\n        });\\n        $this->set('Foo\\\\Bar', $toResolve);\\n        $this->get('Foo\\\\Bar')->shouldReturnAnInstanceOf($toResolve);\\n    }\\n}\\n\")), mdx(\"p\", null, \"For classes that will extend an existing class or implement an interface, you can define those inline too. Or you can include a trait:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nclass MyClassSpec extends ObjectBehavior\\n{\\n    function it_can_resolve_dependencies()\\n    {\\n        $toResolve = get_class(new class(new DateTime) extends Foo implements Bar {\\n            public $datetime;\\n            public function __construct(DateTime $datetime)\\n            {\\n                $this->datetime = $datetime;\\n            }\\n\\n            use MyTrait;\\n        });\\n        $this->set('Foo\\\\Bar', $toResolve);\\n        $this->get('Foo\\\\Bar')->shouldReturnAnInstanceOf($toResolve);\\n    }\\n}\\n\")), mdx(\"p\", null, \"In cases where the functionality is contained in a trait or abstract class, and you might need to add little or no additional functionality, this is a lot less verbose than creating a class the conventional way.\"), mdx(\"p\", null, \"None of this is stuff you can't do without anonymous classes, but by defining these sort of disposable fixture classes inline in your tests, you're writing the minimum amount of code necessary to implement your test, and it's logical to define it inline since it's only ever used in the tests. One thing to bear in mind is that anonymous classes are created and instantiated at the same time, so you can't easily create a class and then instantiate an instance of it separately. However, you can instantiate one, then use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get_class()\"), \" function to get its class name and use that to resolve it, which worked well for my use case.\"), mdx(\"p\", null, \"Another use case for anonymous classes is testing traits or abstract classes. I generally use Mockery as my mocking solution with PHPUnit tests, but I've sometimes missed the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getMockForTrait()\"), \" method from PHPUnit. However, another option is to instantiate an anonymous class that includes that trait for testing purposes:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\n$item = new class() {\\n    use MyTrait;\\n};\\n\")), mdx(\"p\", null, \"This way, your test class is as minimal as possible, and you can test the trait/abstract class in a fairly isolated fashion.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Anonymous classes were added in PHP7, but so far I haven't made all that much use of them. However, recently I've been working on building a simple dependency injection containerâ€¦","frontmatter":{"title":"Simplify your tests with anonymous classes","date":"20th October 2018 1:48 pm","isoDate":"2018-10-20T13:48:05+00:00","categories":["php"]},"fields":{"path":"/blog/2018/10/20/simplify-your-tests-with-anonymous-classes/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2018/10/16/adding-react-to-a-legacy-project/"},"frontmatter":{"title":"Adding React to a legacy project","date":"2018-10-16 09:00:29 +0100","layout":"post"}},"next":{"fields":{"path":"/blog/2018/12/06/decorating-service-classes/"},"frontmatter":{"title":"Decorating service classes","date":"2018-12-06 18:34:16 +0000","layout":"post"}}}},"staticQueryHashes":["290055352","3373576264"]}