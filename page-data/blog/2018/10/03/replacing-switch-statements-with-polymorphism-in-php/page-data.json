{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2018/10/03/replacing-switch-statements-with-polymorphism-in-php/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"ebbc426c-af96-5651-8056-d8e6e9a1eb13","body":"var _excluded = [\"components\"];\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Replacing switch statements with polymorphism in PHP\",\n  \"date\": \"2018-10-03 23:07:33 +0100\",\n  \"layout\": \"post\",\n  \"categories\": [\"php\", \"designpatterns\", \"refactoring\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"For the last few months, I've been making a point of picking up on certain antipatterns, and ways to avoid or remove them. One I've seen a lot recently is unnecessary large switch-case or if-else statements. For instance, here is a simplified example of one of these, which renders links to different objects:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nswitch ($item->getType()) {\\n    case 'audio':\\n        $media = new stdClass;\\n        $media->type = 'audio';\\n        $media->duration = $item->getLength();\\n        $media->name = $item->getName();\\n        $media->url = $item->getUrl();\\n    case 'video':\\n        $media = new stdClass;\\n        $media->type = 'video';\\n        $media->duration = $item->getVideoLength();\\n        $media->name = $item->getTitle();\\n        $media->url = $item->getUrl();\\n}\\nreturn '<a href=\\\"'.$media->url.'\\\" class=\\\"'.$media->type.'\\\" data-duration=\\\"'.$media->duration.'\\\">'.$media->name.'</a>';\\n\")), mdx(\"p\", null, \"There are a number of problems with this, most notably the fact that it's doing a lot of work to try and create a new set of objects that behave consistently. Instead, your objects should be polymorphic - in other words, you should be able to treat the original objects the same.\"), mdx(\"p\", null, \"While strictly speaking you don't need one, it's a good idea to create an interface that defines the required methods. That way, you can have those objects implement that interface, and be certain that they have all the required methods:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Contracts;\\n\\ninterface MediaItem\\n{\\n    public function getLength(): int;\\n\\n    public function getName(): string;\\n\\n    public function getType(): string;\\n\\n    public function getUrl(): string;\\n}\\n\")), mdx(\"p\", null, \"Then, you need to implement that interface in your objects. It doesn't matter if the implementations are different, as long as the methods exist. That way, objects can define how they return a particular value, which is simpler and more logical than defining it in a large switch-case statement elsewhere. It also helps to prevent duplication. Here's what the audio object might look like:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Models;\\n\\nuse App\\\\Contracts\\\\MediaItem;\\n\\nclass Audio implements MediaItem\\n{\\n    public function getLength(): int\\n    {\\n        return $this->length;\\n    }\\n\\n    public function getName(): string\\n    {\\n        return $this->name;\\n    }\\n\\n    public function getType(): string\\n    {\\n        return $this->type;\\n    }\\n\\n    public function getUrl(): string\\n    {\\n        return $this->url;\\n    }\\n}\\n\")), mdx(\"p\", null, \"And here's a similar example of the video object:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Models;\\n\\nuse App\\\\Contracts\\\\MediaItem;\\n\\nclass Video implements MediaItem\\n{\\n    public function getLength(): int\\n    {\\n        return $this->getVideoLength();\\n    }\\n\\n    public function getName(): string\\n    {\\n        return $this->getTitle();\\n    }\\n\\n    public function getType(): string\\n    {\\n        return $this->type;\\n    }\\n\\n    public function getUrl(): string\\n    {\\n        return $this->url;\\n    }\\n}\\n\")), mdx(\"p\", null, \"With that done, the code to render the links can be greatly simplified:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\nreturn '<a href=\\\"'.$item->getUrl().'\\\" class=\\\"'.$item->getType().'\\\" data-duration=\\\"'.$item->getLength().'\\\">'.$media->getName().'</a>';\\n\")), mdx(\"p\", null, \"Because we can use the exact same methods and get consistent responses, yet also allow for the different implementations within the objects, this approach allows for much more elegant and readable code. Different objects can be treated in the same way without the need for writing extensive if or switch statements.\"), mdx(\"p\", null, \"I haven't had the occasion to do so, but in theory this approach is applicable in other languages, such as Javascript or Python (although these languages don't have the concept of interfaces). Since discovering the switch statement antipattern and how to replace it with polymorphism, I've been able to remove a lot of overly complex code.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"For the last few months, I've been making a point of picking up on certain antipatterns, and ways to avoid or remove them. One I've seen a lot recently is unnecessary large switchâ€¦","frontmatter":{"title":"Replacing switch statements with polymorphism in PHP","date":"3rd October 2018 10:07 pm","isoDate":"2018-10-03T22:07:33+00:00","categories":["php","designpatterns","refactoring"]},"fields":{"path":"/blog/2018/10/03/replacing-switch-statements-with-polymorphism-in-php/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2018/09/25/career-direction-after-seven-years/"},"frontmatter":{"title":"Career direction after seven years","date":"2018-09-25 22:03:29 +0100","layout":"post"}},"next":{"fields":{"path":"/blog/2018/10/05/understanding-the-pipeline-pattern/"},"frontmatter":{"title":"Understanding the pipeline pattern","date":"2018-10-05 19:36:16 +0100","layout":"post"}}}},"staticQueryHashes":["1776624730","3528622268"]}