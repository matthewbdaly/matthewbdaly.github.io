{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2018/01/08/getting-the-type-of-an-unsupported-postgres-field-in-laravel/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"164c62a3-68c5-5198-a7c1-857e89da1dac","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Getting the type of an unsupported Postgres field in Laravel\",\n  \"date\": \"2018-01-08 14:00:15 +0000\",\n  \"layout\": \"post\",\n  \"categories\": [\"php\", \"laravel\", \"postgresql\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Today I've been working on a generic, reusable Laravel admin interface, loosely inspired by the Django admin, that dynamically picks up the field types and generates an appropriate input field accordingly.\"), mdx(\"p\", null, \"One problem I've run into is that getting a representation of a database table's fields relies on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"doctrine/dbal\"), \", and its support for the more unusual PostgreSQL field types is spotty at best. I've been testing it out on a Laravel-based blogging engine, which has full-text search using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TSVECTOR\"), \" field type, which isn't supported, and it threw a nasty \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Unknown database type tsvector requested\"), \" error.\"), mdx(\"p\", null, \"Fortunately, it's possible to register custom field type mappings easily enough. In this case we can safely treat a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TSVECTOR\"), \" field as a string` type anyway, so we can map it to the string type. We can do so in the boot method of a service provider:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Providers;\\n\\nuse Illuminate\\\\Support\\\\ServiceProvider;\\n\\nclass AppServiceProvider extends ServiceProvider\\n{\\n    /**\\n     * Bootstrap any application services.\\n     *\\n     * @return void\\n     */\\n    public function boot()\\n    {\\n        // Register the TSVECTOR column\\n        $conn = $this->app->make('Illuminate\\\\Database\\\\ConnectionInterface');\\n        $conn->getDoctrineSchemaManager()\\n            ->getDatabasePlatform()\\n            ->registerDoctrineTypeMapping('tsvector', 'string');\\n    }\\n\\n    /**\\n     * Register any application services.\\n     *\\n     * @return void\\n     */\\n    public function register()\\n    {\\n       //\\n    }\\n}\\n\")), mdx(\"p\", null, \"We register a Doctrine type mapping that maps the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tsvector\"), \" type to a string. Now Doctrine will just treat it as a string.\"), mdx(\"p\", null, \"We can then retrieve the field types as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"        $table = $this->model->getTable();\\n        $fields = array_values(Schema::getColumnListing($table));\\n        $fielddata = [];\\n        foreach ($fields as $field){\\n            if ($field != 'id' && $field != 'created_at' && $field != 'updated_at' && $field != 'deleted_at') {\\n                try {\\n                    $fielddata[$field] = Schema::getColumnType($table, $field);\\n                } catch (\\\\Exception $e) {\\n                    $fielddata[$field] = 'unknown';\\n                }\\n            }\\n        }\\n\")), mdx(\"p\", null, \"Note that we specifically don't want to retrieve the ID or timestamps, so we exclude them - the user should never really have the need to update them manually. We fetch the table from the model and then call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Schema::getColumnListing()\"), \" to retrieve a list of fields for that table. Finally we call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Schema::getColumnType()\"), \" to actually get the type of each column.\"), mdx(\"p\", null, \"Now, I suspect the performance of this admin interface is going to be inferior to a more specific one because it has to retrieve the fields all the time, but that's not the point here - with a non-user facing admin interface, performance isn't quite as much of an issue. For the same reason the admin doesn't do any caching at all. It's still useful under certain circumstances to be able to reverse-engineer the table structure and render an appropriate form dynamically.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Today I've been working on a generic, reusable Laravel admin interface, loosely inspired by the Django admin, that dynamically picks up the field types and generates an appropriateâ€¦","frontmatter":{"title":"Getting the type of an unsupported Postgres field in Laravel","date":"8th January 2018 2:00 pm","isoDate":"2018-01-08T14:00:15+00:00","categories":["php","laravel","postgresql"]},"fields":{"path":"/blog/2018/01/08/getting-the-type-of-an-unsupported-postgres-field-in-laravel/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2018/01/08/creating-an-artisan-task-to-set-up-a-user-account/"},"frontmatter":{"title":"Creating an Artisan task to set up a user account","date":"2018-01-08 12:52:39 +0000","layout":"post"}},"next":{"fields":{"path":"/blog/2018/01/09/creating-laravel-helpers/"},"frontmatter":{"title":"Creating Laravel Helpers","date":"2018-01-09 17:26:26 +0000","layout":"post"}}}},"staticQueryHashes":["290055352","3373576264"]}