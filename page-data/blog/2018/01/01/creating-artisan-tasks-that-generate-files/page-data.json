{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2018/01/01/creating-artisan-tasks-that-generate-files/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"a9a8adf2-e59f-564f-8561-b80858f610ac","body":"var _excluded = [\"components\"];\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Creating Artisan tasks that generate files\",\n  \"date\": \"2018-01-01 16:06:21 +0000\",\n  \"layout\": \"post\",\n  \"categories\": [\"php\", \"artisan\", \"laravel\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"While the documentation for creating Artisan tasks is generally pretty good, it doesn't really touch on creating tasks that generate new files. The only way to figure it out was to go digging through the source code. In this case, I was building an Artisan command to create Fractal transformers as part of a package I'm working on.\"), mdx(\"p\", null, \"There's a specialised class for generating files at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Illuminate\\\\Console\\\\GeneratorCommand\"), \", which your command class should extend instead of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Illuminate\\\\Console\\\\Command\"), \". In addition to the usual properties such as the signature and description, you also need to specify \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$type\"), \" to give the type of class being generated. Also, note that the constructor is different, so if you use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"php artisan make:console\"), \" to create the boilerplate for this command, you'll need to delete the constructor.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace Matthewbdaly\\\\MyPackage\\\\Console\\\\Commands;\\n\\nuse Illuminate\\\\Console\\\\GeneratorCommand;\\nuse Symfony\\\\Component\\\\Console\\\\Input\\\\InputArgument;\\n\\nclass TransformerMakeCommand extends GeneratorCommand\\n{\\n    /**\\n     * The name and signature of the console command.\\n     *\\n     * @var string\\n     */\\n    protected $signature = 'make:transformer {name : The required name of the transformer class}';\\n\\n    /**\\n     * The console command description.\\n     *\\n     * @var string\\n     */\\n    protected $description = 'Create a Fractal transformer';\\n\\n    /**\\n     * The type of class being generated.\\n     *\\n     * @var string\\n     */\\n    protected $type = 'Fractal transformer';\\n\\n    /**\\n     * Get the stub file for the generator.\\n     *\\n     * @return string\\n     */\\n    protected function getStub()\\n    {\\n        return __DIR__.'/stubs/transformer.stub';\\n    }\\n\\n    /**\\n     * Get the console command arguments.\\n     *\\n     * @return array\\n     */\\n    protected function getArguments()\\n    {\\n        return [\\n            ['name', InputArgument::REQUIRED, 'The name of the command.'],\\n        ];\\n    }\\n\\n    /**\\n     * Get the default namespace for the class.\\n     *\\n     * @param  string  $rootNamespace\\n     * @return string\\n     */\\n    protected function getDefaultNamespace($rootNamespace)\\n    {\\n        return $rootNamespace.'\\\\Transformers';\\n    }\\n}\\n\")), mdx(\"p\", null, \"Note the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getDefaultNamespace()\"), \" method. If your class will live directly under the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app\"), \" folder this is not necessary. Otherwise, it needs to return the root namespace, with the folder structure you want after it. Here my class will live under \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app\\\\Transformers\"), \", so I've set it to reflect that.\"), mdx(\"p\", null, \"Also, note the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getStub()\"), \" method. This tells Artisan that it should use the specified stub file as the basis for our class. Below you'll find the stub file I used for my transformer:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace DummyNamespace;\\n\\nuse Matthewbdaly\\\\MyPackage\\\\Transformers\\\\BaseTransformer;\\nuse Illuminate\\\\Database\\\\Eloquent\\\\Model;\\n\\nclass DummyClass extends BaseTransformer\\n{\\n    public function transform(Model $model)\\n    {\\n        return [\\n            'id'            => (int) $model->id,\\n        ];\\n    }\\n}\\n\")), mdx(\"p\", null, \"Note that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DummyNamespace\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DummyClass\"), \" fields will be overwritten with the correct values.\"), mdx(\"p\", null, \"Once this Artisan command is registered in the usual way, you can then run it as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ php artisan make:transformer Example\\n\")), mdx(\"p\", null, \"And it will generate a boilerplate class something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Transformers;\\n\\nuse Matthewbdaly\\\\MyPackage\\\\Transformers\\\\BaseTransformer;\\nuse Illuminate\\\\Database\\\\Eloquent\\\\Model;\\n\\nclass Example extends BaseTransformer\\n{\\n    public function transform(Model $model)\\n    {\\n        return [\\n            'id'            => (int) $model->id,\\n        ];\\n    }\\n}\\n\")), mdx(\"p\", null, \"You can then replace the model with your own one as necessary, and add any further content to this class.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"While the documentation for creating Artisan tasks is generally pretty good, it doesn't really touch on creating tasks that generate new files. The only way to figure it out was toâ€¦","frontmatter":{"title":"Creating Artisan tasks that generate files","date":"1st January 2018 4:06 pm","isoDate":"2018-01-01T16:06:21+00:00","categories":["php","artisan","laravel"]},"fields":{"path":"/blog/2018/01/01/creating-artisan-tasks-that-generate-files/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2017/12/29/using-uuids-as-primary-keys-with-laravel-and-postgresql/"},"frontmatter":{"title":"Using UUIDs as primary keys with Laravel and PostgreSQL","date":"2017-12-29 18:01:04 +0000","layout":"post"}},"next":{"fields":{"path":"/blog/2018/01/02/using-artisan-from-standalone-laravel-packages/"},"frontmatter":{"title":"Using Artisan from standalone Laravel packages","date":"2018-01-02 12:01:10 +0000","layout":"post"}}}},"staticQueryHashes":["1776624730","458490740"]}