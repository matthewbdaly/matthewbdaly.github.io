{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2018/01/12/creating-a-caching-user-provider-for-laravel/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"822ef343-ced8-5278-81a7-c5a9b5f03cbe","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Creating a caching user provider for Laravel\",\n  \"date\": \"2018-01-12 13:16:51 +0000\",\n  \"layout\": \"post\",\n  \"categories\": [\"php\", \"laravel\", \"caching\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"EDIT: I no longer recommend this approach - please refer \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://matthewdaly.co.uk/blog/2020/03/11/caching-the-laravel-user-provider-with-a-decorator/\"\n  }, \"here\"), \" for an alternative approach to this.\"), mdx(\"p\", null, \"If you have a Laravel application that requires users to log in and you use Clockwork or Laravel DebugBar to examine the queries that take place, you'll probably notice a query that fetches the user model occurs quite a lot. This is because the user's ID gets stored in the session, and is then used to retrieve the model.\"), mdx(\"p\", null, \"This query is a good candidate for caching because not only is that query being made often, but it's also not something that changes all that often. If you're careful, it's quite easy to set your application up to cache the user without having to worry about invalidating the cache.\"), mdx(\"p\", null, \"Laravel allows you to define your own user providers in order to fetch the user's details. These must implement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Illuminate\\\\Contracts\\\\Auth\\\\UserProvider\"), \" and must return a user model from the identifier provided. Out of the box it comes with two implementations, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Illuminate\\\\Auth\\\\EloquentUserProvider\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Illuminate\\\\Auth\\\\DatabaseUserProvider\"), \", with the former being the default. Our caching user provider can extend the Eloquent one as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Auth;\\n\\nuse Illuminate\\\\Auth\\\\EloquentUserProvider;\\nuse Illuminate\\\\Contracts\\\\Cache\\\\Repository;\\nuse Illuminate\\\\Contracts\\\\Hashing\\\\Hasher as HasherContract;\\n\\nclass CachingUserProvider extends EloquentUserProvider\\n{\\n    /**\\n     * The cache instance.\\n     *\\n     * @var Repository\\n     */\\n    protected $cache;\\n\\n    /**\\n     * Create a new database user provider.\\n     *\\n     * @param  \\\\Illuminate\\\\Contracts\\\\Hashing\\\\Hasher  $hasher\\n     * @param  string  $model\\n     * @param  Repository  $cache\\n     * @return void\\n     */\\n    public function __construct(HasherContract $hasher, $model, Repository $cache)\\n    {\\n        $this->model = $model;\\n        $this->hasher = $hasher;\\n        $this->cache = $cache;\\n    }\\n\\n    /**\\n     * Retrieve a user by their unique identifier.\\n     *\\n     * @param  mixed  $identifier\\n     * @return \\\\Illuminate\\\\Contracts\\\\Auth\\\\Authenticatable|null\\n     */\\n    public function retrieveById($identifier)\\n    {\\n        return $this->cache->tags($this->getModel())->remember('user_by_id_'.$identifier, 60, function () use ($identifier) {\\n            return parent::retrieveById($identifier);\\n        });\\n    }\\n}\\n\")), mdx(\"p\", null, \"Note that we override the constructor to accept a cache instance as well as the other arguments. We also override the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"retrieveById()\"), \" method to wrap a call to the parent's implementation inside a callback that caches the response. I usually tag anything I cache with the model name, but if you need to use a cache backend that doesn't support tagging this may not be an option. Our cache key also includes the identifier so that it's unique to that user.\"), mdx(\"p\", null, \"We then need to add our user provider to the auth service provider:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Providers;\\n\\nuse Illuminate\\\\Support\\\\Facades\\\\Gate;\\nuse Illuminate\\\\Foundation\\\\Support\\\\Providers\\\\AuthServiceProvider as ServiceProvider;\\nuse App\\\\Auth\\\\CachingUserProvider;\\nuse Illuminate\\\\Support\\\\Facades\\\\Auth;\\n\\nclass AuthServiceProvider extends ServiceProvider\\n{\\n    /**\\n     * Register any authentication / authorization services.\\n     *\\n     * @return void\\n     */\\n    public function boot()\\n    {\\n        $this->registerPolicies();\\n\\n        Auth::provider('caching', function ($app, array $config) {\\n            return new CachingUserProvider(\\n                $app->make('Illuminate\\\\Contracts\\\\Hashing\\\\Hasher'),\\n                $config['model'],\\n                $app->make('Illuminate\\\\Contracts\\\\Cache\\\\Repository')\\n            );\\n        });\\n    }\\n}\\n\")), mdx(\"p\", null, \"Note here that we call this provider \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"caching\"), \", and we pass it the hasher, the model name, and an instance of the cache. Then, we need to update \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"config/auth.php\"), \" to use this provider:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    'providers' => [\\n        'users' => [\\n            'driver' => 'caching',\\n            'model' => App\\\\Eloquent\\\\Models\\\\User::class,\\n        ],\\n    ],\\n\")), mdx(\"p\", null, \"The only issue now is that our user models will continue to be cached, even when they are updated. To be able to flush the cache, we can create a model event that fires whenever the user model is updated:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Eloquent\\\\Models;\\n\\nuse Illuminate\\\\Notifications\\\\Notifiable;\\nuse Illuminate\\\\Foundation\\\\Auth\\\\User as Authenticatable;\\nuse App\\\\Events\\\\UserAmended;\\n\\nclass User extends Authenticatable\\n{\\n    use Notifiable;\\n\\n    protected $dispatchesEvents = [\\n        'saved' => UserAmended::class,\\n        'deleted' => UserAmended::class,\\n        'restored' => UserAmended::class,\\n    ];\\n}\\n\")), mdx(\"p\", null, \"This will call the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserAmended\"), \" event when a user model is created, updated, deleted or restored. Then we can define that event:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Events;\\n\\nuse Illuminate\\\\Broadcasting\\\\Channel;\\nuse Illuminate\\\\Queue\\\\SerializesModels;\\nuse Illuminate\\\\Broadcasting\\\\PrivateChannel;\\nuse Illuminate\\\\Broadcasting\\\\PresenceChannel;\\nuse Illuminate\\\\Foundation\\\\Events\\\\Dispatchable;\\nuse Illuminate\\\\Broadcasting\\\\InteractsWithSockets;\\nuse Illuminate\\\\Contracts\\\\Broadcasting\\\\ShouldBroadcast;\\nuse App\\\\Eloquent\\\\Models\\\\User;\\n\\nclass UserAmended\\n{\\n    use Dispatchable, InteractsWithSockets, SerializesModels;\\n\\n    /**\\n     * Create a new event instance.\\n     *\\n     * @return void\\n     */\\n    public function __construct(User $model)\\n    {\\n        $this->model = $model;\\n    }\\n}\\n\")), mdx(\"p\", null, \"Note our event contains an instance of the user model. Then we set up a listener to do the work of clearing the cache:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Listeners;\\n\\nuse Illuminate\\\\Queue\\\\InteractsWithQueue;\\nuse Illuminate\\\\Contracts\\\\Queue\\\\ShouldQueue;\\nuse App\\\\Events\\\\UserAmended;\\nuse Illuminate\\\\Contracts\\\\Cache\\\\Repository;\\n\\nclass ClearUserId\\n{\\n    /**\\n     * Create the event listener.\\n     *\\n     * @return void\\n     */\\n    public function __construct(Repository $cache)\\n    {\\n        $this->cache = $cache;\\n    }\\n\\n    /**\\n     * Handle the event.\\n     *\\n     * @param  object  $event\\n     * @return void\\n     */\\n    public function handle(UserAmended $event)\\n    {\\n        $this->cache->tags(get_class($event->model))->forget('user_by_id_'.$event->model->id);\\n    }\\n}\\n\")), mdx(\"p\", null, \"Here, we get the user model's class again, and clear the cache entry for that user model.\"), mdx(\"p\", null, \"Finally, we hook up the event and listener in the event service provider:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Providers;\\n\\nuse Illuminate\\\\Support\\\\Facades\\\\Event;\\nuse Illuminate\\\\Foundation\\\\Support\\\\Providers\\\\EventServiceProvider as ServiceProvider;\\n\\nclass EventServiceProvider extends ServiceProvider\\n{\\n    /**\\n     * The event listener mappings for the application.\\n     *\\n     * @var array\\n     */\\n    protected $listen = [\\n        'App\\\\Events\\\\UserAmended' => [\\n            'App\\\\Listeners\\\\ClearUserId',\\n        ],\\n    ];\\n\\n    /**\\n     * Register any events for your application.\\n     *\\n     * @return void\\n     */\\n    public function boot()\\n    {\\n        parent::boot();\\n\\n        //\\n    }\\n}\\n\")), mdx(\"p\", null, \"With that done, our user should be cached after the first load, and flushed when the model is amended.\"), mdx(\"h2\", null, \"Handling eager-loaded data\"), mdx(\"p\", null, \"It may be that you're pulling in additional data from the user model in your application, such as roles, permissions, or a separate profile model. Under those circumstances it makes sense to treat that data in the same way by eager-loading it along with your user model.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Auth;\\n\\nuse Illuminate\\\\Auth\\\\EloquentUserProvider;\\nuse Illuminate\\\\Contracts\\\\Cache\\\\Repository;\\nuse Illuminate\\\\Contracts\\\\Hashing\\\\Hasher as HasherContract;\\n\\nclass CachingUserProvider extends EloquentUserProvider\\n{\\n    /**\\n     * The cache instance.\\n     *\\n     * @var Repository\\n     */\\n    protected $cache;\\n\\n    /**\\n     * Create a new database user provider.\\n     *\\n     * @param  \\\\Illuminate\\\\Contracts\\\\Hashing\\\\Hasher  $hasher\\n     * @param  string  $model\\n     * @param  Repository  $cache\\n     * @return void\\n     */\\n    public function __construct(HasherContract $hasher, $model, Repository $cache)\\n    {\\n        $this->model = $model;\\n        $this->hasher = $hasher;\\n        $this->cache = $cache;\\n    }\\n\\n    /**\\n     * Retrieve a user by their unique identifier.\\n     *\\n     * @param  mixed  $identifier\\n     * @return \\\\Illuminate\\\\Contracts\\\\Auth\\\\Authenticatable|null\\n     */\\n    public function retrieveById($identifier)\\n    {\\n        return $this->cache->tags($this->getModel())->remember('user_by_id_'.$identifier, 60, function () use ($identifier) {\\n          $model = $this->createModel();\\n          return $model->newQuery()\\n            ->with('roles', 'permissions', 'profile')\\n            ->where($model->getAuthIdentifierName(), $identifier)\\n            ->first();\\n        });\\n    }\\n}\\n\")), mdx(\"p\", null, \"Because we need to amend the query itself, we can't just defer to the parent implementation like we did above and must instead copy it over and amend it to eager-load the data.\"), mdx(\"p\", null, \"You'll also need to set up model events to clear the cache whenever one of the related fields is updated, but it should be fairly straightforward to do so.\"), mdx(\"h2\", null, \"Summary\"), mdx(\"p\", null, \"Fetching a user model (and possibly some relations) on every page load while logged in can be a bit much, and it makes sense to cache as much as you can without risking serving stale data. Using this technique you can potentially cache a lot of repetitive, unnecessary queries and make your application faster.\"), mdx(\"p\", null, \"This technique will also work in cases where you're using other methods of maintaining user state, such as JWT, as long as you're making use of a guard for authentication purposes, since all of these guards will still be using the same user provider. In fact, I first used this technique on a REST API that used JWT for authentication, and it's worked well in that case.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"EDIT: I no longer recommend this approach - please refer  here  for an alternative approach to this. If you have a Laravel application that requires users to log in and you useâ€¦","frontmatter":{"title":"Creating a caching user provider for Laravel","date":"12 January 2018","categories":["php","laravel","caching"]},"fields":{"path":"/blog/2018/01/12/creating-a-caching-user-provider-for-laravel/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2018/01/10/adding-opensearch-support-to-your-site/"},"frontmatter":{"title":"Adding OpenSearch support to your site","date":"2018-01-10 22:07:27 +0000","layout":"post"}},"next":{"fields":{"path":"/blog/2018/01/22/deploying-your-laravel-application-with-deployer/"},"frontmatter":{"title":"Deploying your Laravel application with Deployer","date":"2018-01-22 12:00:14 +0000","layout":"post"}}}},"staticQueryHashes":["2909664151"]}