{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2016/01/26/mocking-external-apis-in-python/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"3846f886-7989-5799-93db-b35d38722a0d","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Mocking external APIs in Python\",\n  \"date\": \"2016-01-26 23:40:25 +0000\",\n  \"layout\": \"post\",\n  \"categories\": [\"python\", \"tdd\", \"mock\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"It's quite common to have to integrate an external API into your web app for some of your functionality. However, it's a really bad idea to have requests be sent to the remote API when running your tests. At best, it means your tests may fail due to unexpected circumstances, such as a network outage. At worst, you could wind up making requests to paid services that will cost you money, or sending push notifications to clients. It's therefore a good idea to mock these requests in some way, but it can be fiddly.\"), mdx(\"p\", null, \"In this post I'll show you several ways you can mock an external API so as to prevent requests being sent when running your test suite. I'm sure there are many others, but these have worked for me recently.\"), mdx(\"h2\", null, \"Mocking the client library\"), mdx(\"p\", null, \"Nowadays many third-party services realise that providing developers with client libraries in a variety of languages is a good idea, so it's quite common to find a library for interfacing with a third-party service. Under these circumstances, the library itself is usually already thoroughly tested, so there's no point in you writing additional tests for that functionality. Instead, you can just mock the client library so that the request is never sent, and if you need a response, then you can specify one that will remain constant.\"), mdx(\"p\", null, \"I recently had to integrate Stripe with a mobile app backend, and I used their client library. I needed to ensure that I got the right result back. In this case I only needed to use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Token\"), \" object's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"create()\"), \" method. I therefore created a new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MockToken\"), \" class that inherited from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Token\"), \", and overrode its \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"create()\"), \" method so that it only accepted one card number and returned a hard-coded response for it:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from stripe.resource import Token, convert_to_stripe_object\\nfrom stripe.error import CardError\\n\\n\\nclass MockToken(Token):\\n\\n    @classmethod\\n    def create(cls, api_key=None, idempotency_key=None,\\n               stripe_account=None, **params):\\n        if params['card']['number'] != '4242424242424242':\\n            raise CardError('Invalid card number', None, 402)\\n\\n        response = {\\n            \\\"card\\\": {\\n              \\\"address_city\\\": None,\\n              \\\"address_country\\\": None,\\n              \\\"address_line1\\\": None,\\n              \\\"address_line1_check\\\": None,\\n              \\\"address_line2\\\": None,\\n              \\\"address_state\\\": None,\\n              \\\"address_zip\\\": None,\\n              \\\"address_zip_check\\\": None,\\n              \\\"brand\\\": \\\"Visa\\\",\\n              \\\"country\\\": \\\"US\\\",\\n              \\\"cvc_check\\\": \\\"unchecked\\\",\\n              \\\"dynamic_last4\\\": None,\\n              \\\"exp_month\\\": 12,\\n              \\\"exp_year\\\": 2017,\\n              \\\"fingerprint\\\": \\\"49gS1c4YhLaGEQbj\\\",\\n              \\\"funding\\\": \\\"credit\\\",\\n              \\\"id\\\": \\\"card_17XXdZGzvyST06Z022EiG1zt\\\",\\n              \\\"last4\\\": \\\"4242\\\",\\n              \\\"metadata\\\": {},\\n              \\\"name\\\": None,\\n              \\\"object\\\": \\\"card\\\",\\n              \\\"tokenization_method\\\": None\\n          },\\n            \\\"client_ip\\\": \\\"192.168.1.1\\\",\\n            \\\"created\\\": 1453817861,\\n            \\\"id\\\": \\\"tok_42XXdZGzvyST06Z0LA6h5gJp\\\",\\n            \\\"livemode\\\": False,\\n            \\\"object\\\": \\\"token\\\",\\n            \\\"type\\\": \\\"card\\\",\\n            \\\"used\\\": False\\n        }\\n        return convert_to_stripe_object(response, api_key, stripe_account)\\n\")), mdx(\"p\", null, \"Much of this was lifted straight from the source code for the library. I then wrote a test for the payment endpoint and patched the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Token\"), \" class:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class PaymentTest(TestCase):\\n    @mock.patch('stripe.Token', MockToken)\\n    def test_payments(self):\\n        data = {\\n            \\\"number\\\": '1111111111111111',\\n            \\\"exp_month\\\": 12,\\n            \\\"exp_year\\\": 2017,\\n            \\\"cvc\\\": '123'\\n        }\\n        response = self.client.post(reverse('payments'), data=data, format='json')\\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\\n\")), mdx(\"p\", null, \"This replaced \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stripe.Token\"), \" with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MockToken\"), \" so that in this test, the response from the client library was always going to be the expected one.\"), mdx(\"p\", null, \"If the response doesn't matter and all you need to do is be sure that the right method would have been called, this is easier. You can just mock the method in question using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MagicMock\"), \" and assert that it has been called afterwards, as in this example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class ReminderTest(TestCase):\\n    def test_send_reminder(self):\\n        # Mock PushService.create_message()\\n        PushService.create_message = mock.MagicMock(name=\\\"create_message\\\")\\n\\n        # Call reminder task\\n        send_reminder()\\n\\n        # Check user would have received a push notification\\n        PushService.create_message.assert_called_with([{'text': 'My push', 'conditions': ['UserID', 'EQ', 1]}])\\n\")), mdx(\"h2\", null, \"Mocking lower-level requests\"), mdx(\"p\", null, \"Sometimes, no client library is available, or it's not worth using one as you only have to make one or two requests. Under these circumstances, there are ways to mock the actual request to the external API. If you're using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"requests\"), \" module, then there's a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"responses\"), \" module that's ideal for mocking the API request.\"), mdx(\"p\", null, \"Suppose we have the following code:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"import json, requests\\n\\ndef send_request_to_api(data):\\n    # Put together the request\\n    params = {\\n        'auth': settings.AUTH_KEY,\\n        'data': data\\n    }\\n    response = requests.post(settings.API_URL, data={'params': json.dumps(params)})\\n    return response\\n\")), mdx(\"p\", null, \"Using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"responses\"), \" we can mock the response from the server in our test:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class APITest(TestCase):\\n    @responses.activate\\n    def test_send_request(self):\\n        # Mock the API\\n        responses.add(responses.POST,\\n            settings.API_URL,\\n            status=200,\\n            content_type=\\\"application/json\\\",\\n            body='{\\\"item_id\\\": \\\"12345678\\\"}')\\n\\n        # Call function\\n        data = {\\n            \\\"surname\\\": \\\"Smith\\\",\\n            \\\"location\\\": \\\"London\\\"\\n        }\\n        send_request_to_api(data)\\n\\n        # Check request went to correct URL\\n        assert responses.calls[0].request.url == settings.API_URL\\n\")), mdx(\"p\", null, \"Note the use of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@responses.activate\"), \" decorator. We use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"responses.add()\"), \" to set up each URL we want to be able to mock, and pass through details of the response we want to return. We then make the request, and check that it was made as expected.\"), mdx(\"p\", null, \"You can find more details of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"responses\"), \" module \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/getsentry/responses\"\n  }, \"here\"), \".\"), mdx(\"h2\", null, \"Summary\"), mdx(\"p\", null, \"I'm pretty certain that there are other ways you can mock an external API in Python, but these ones have worked for me recently. If you use another method, please feel free to share it in the comments.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"It's quite common to have to integrate an external API into your web app for some of your functionality. However, it's a really bad idea to have requests be sent to the remote API…","frontmatter":{"title":"Mocking external APIs in Python","date":"26th January 2016 11:40 pm","isoDate":"2016-01-26T23:40:25+00:00","categories":["python","tdd","mock"]},"fields":{"path":"/blog/2016/01/26/mocking-external-apis-in-python/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2015/11/18/learning-more-about-react-dot-js-and-flux/"},"frontmatter":{"title":"Learning more about React.js and Flux","date":"2015-11-18 19:52:48 +0000","layout":"post"}},"next":{"fields":{"path":"/blog/2016/03/18/my-experience-using-php-7-in-production/"},"frontmatter":{"title":"My experience using PHP 7 in production","date":"2016-03-18 19:42:37 +0000","layout":"post"}}}},"staticQueryHashes":["1776624730","458490740"]}