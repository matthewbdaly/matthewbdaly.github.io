{
    "componentChunkName": "component---src-templates-post-tsx",
    "path": "/blog/2016/11/29/testing-laravel-middleware/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"9dab886e-ca5f-5948-8ddd-8842782c2f65","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Testing Laravel Middleware\",\n  \"date\": \"2016-11-29 23:00:38 +0000\",\n  \"layout\": \"post\",\n  \"categories\": [\"php\", \"laravel\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"It's widely accepted that high-level integration tests alone do not make for a good test suite. Ideally each individual component of your application should have unit tests, which test that component in isolation. These unit tests are usually much quicker to run, making it easier to practice test-driven development. However, it can sometimes be hard to grasp how to test that one component on its own.\"), mdx(\"p\", null, \"The other day I had an issue with several middleware classes for a Laravel application and I wanted to verify that they were working as expected. Sounds like a job for dedicated unit tests, but I hadn't tested custom middleware in isolation before, and figuring out how to do so took a while.\"), mdx(\"p\", null, \"Laravel middleware accepts an instance of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Illuminate\\\\Http\\\\Request\"), \", itself based on the Symfony request object, as well as a closure for the action to take next. Depending on what the middleware does, it may return a redirect or simply amend the existing request or response. So in theory you can instantiate a request object, pass it to the middleware, and check the response. For middleware that does something simple, such as redirecting users based on certain conditions, this is fairly straightforward.\"), mdx(\"p\", null, \"In this example we have a fairly useless piece of middleware that checks to see what the route is for a request and redirects it if it matches a certain pattern:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Http\\\\Middleware;\\n\\nuse Closure;\\n\\nclass RedirectFromAdminMiddleware\\n{\\n    /**\\n     * Handle an incoming request.\\n     *\\n     * @param  \\\\Illuminate\\\\Http\\\\Request  $request\\n     * @param  \\\\Closure  $next\\n     * @return mixed\\n     */\\n    public function handle($request, Closure $next)\\n    {\\n        if ($request->is('admin*')) {\\n            return redirect('/');\\n        }\\n        return $next($request);\\n    }\\n}\\n\")), mdx(\"p\", null, \"While this example is of limited use, it wouldn't take much work to develop it to redirect conditionally based on an account type, and it's simple enough to demonstrate the principles involved. In these tests, we create instances of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Illuminate\\\\Http\\\\Request\"), \" and pass them to the middleware's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"handle()\"), \" method, along with an empty closure representing the response. If the middleware does not amend the request, we get the empty response from the closure. If it does amend the request, we get a redirect response.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nuse Illuminate\\\\Http\\\\Request;\\n\\nclass RedirectFromAdminMiddlewareTest extends TestCase\\n{\\n    public function testRedirectMiddlewareCalledOnAdmin()\\n    {\\n        // Create request\\n        $request = Request::create('http://example.com/admin', 'GET');\\n\\n        // Pass it to the middleware\\n        $middleware = new App\\\\Http\\\\Middleware\\\\RedirectFromAdminMiddleware();\\n        $response = $middleware->handle($request, function () {});\\n        $this->assertEquals($response->getStatusCode(), 302);\\n    }\\n\\n    public function testRedirectMiddlewareNotCalledOnNonAdmin()\\n    {\\n        // Create request\\n        $request = Request::create('http://example.com/pages', 'GET');\\n\\n        // Pass it to the middleware\\n        $middleware = new App\\\\Http\\\\Middleware\\\\RedirectFromAdminMiddleware();\\n        $response = $middleware->handle($request, function () {});\\n        $this->assertEquals($response, null);\\n    }\\n}\\n\")), mdx(\"p\", null, \"For middleware that fetches the response and acts on it, things are a little more complex. For instance, this is the Etag middleware I use on many projects:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Http\\\\Middleware;\\n\\nuse Closure;\\n\\nclass ETagMiddleware {\\n    /**\\n     * Implement Etag support\\n     *\\n     * @param  \\\\Illuminate\\\\Http\\\\Request  $request\\n     * @param  \\\\Closure  $next\\n     * @return mixed\\n     */\\n    public function handle($request, Closure $next)\\n    {\\n        // Get response\\n        $response = $next($request);\\n        // If this was a GET request...\\n        if ($request->isMethod('get')) {\\n            // Generate Etag\\n            $etag = md5($response->getContent());\\n            $requestEtag = str_replace('\\\"', '', $request->getETags());\\n            // Check to see if Etag has changed\\n            if($requestEtag && $requestEtag[0] == $etag) {\\n                $response->setNotModified();\\n            }\\n            // Set Etag\\n            $response->setEtag($etag);\\n        }\\n        // Send response\\n        return $response;\\n    }\\n}\\n\")), mdx(\"p\", null, \"This acts on the response object, so we need to pass that through as well. Fortunately, Mockery allows us to create a mock of our response object and set it up to handle only those methods we anticipate being called:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nuse Illuminate\\\\Http\\\\Request;\\n\\nclass ETagMiddlewareTest extends TestCase\\n{\\n    /**\\n     * Test new request not cached\\n     *\\n     * @return void\\n     */\\n    public function testModified()\\n    {\\n        // Create mock response\\n        $response = Mockery::mock('Illuminate\\\\Http\\\\Response')->shouldReceive('getContent')->once()->andReturn('blah')->getMock();\\n        $response->shouldReceive('setEtag')->with(md5('blah'));\\n\\n        // Create request\\n        $request = Request::create('http://example.com/admin', 'GET');\\n\\n        // Pass it to the middleware\\n        $middleware = new App\\\\Http\\\\Middleware\\\\ETagMiddleware();\\n        $middlewareResponse = $middleware->handle($request, function () use ($response) { \\n            return $response;\\n        });\\n    }\\n\\n    /**\\n     * Test repeated request not modified\\n     *\\n     * @return void\\n     */\\n    public function testNotModified()\\n    {\\n        // Create mock response\\n        $response = Mockery::mock('Illuminate\\\\Http\\\\Response')->shouldReceive('getContent')->once()->andReturn('blah')->getMock();\\n        $response->shouldReceive('setEtag')->with(md5('blah'));\\n        $response->shouldReceive('setNotModified');\\n\\n        // Create request\\n        $request = Request::create('http://example.com/admin', 'GET', [], [], [], [\\n            'ETag' => md5('blah')\\n        ]);\\n\\n        // Pass it to the middleware\\n        $middleware = new App\\\\Http\\\\Middleware\\\\ETagMiddleware();\\n        $middlewareResponse = $middleware->handle($request, function () use ($response) { \\n            return $response;\\n        });\\n    }\\n\\n    public function teardown()\\n    {\\n        Mockery::close();\\n    }\\n}\\n\")), mdx(\"p\", null, \"In the first example we mock out the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getContent()\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setEtag()\"), \" methods of our response to make sure they get called, and then pass the request to the middleware, along with a closure that returns the response. In the second example, we also mock out \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setNotModified()\"), \" to ensure that the correct status code of 304 is set, and add an ETag to our request. In this way we can easily test our middleware in isolation, rather than having to resort to building up our entire application just to test one small method.\"), mdx(\"p\", null, \"Middleware is a convenient place to put functionality that's needed for many routes, but you shouldn't neglect testing it, and ideally you shouldn't have to resort to writing a slow integration test to test it works as expected. By mocking out your dependencies, it's generally not too hard to test it in isolation, resulting in faster and more robust test suites.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"It's widely accepted that high-level integration tests alone do not make for a good test suite. Ideally each individual component of your application should have unit tests, which…","frontmatter":{"title":"Testing Laravel Middleware","date":"29th November 2016 11:00 pm","isoDate":"2016-11-29T23:00:38+00:00","categories":["php","laravel"]},"fields":{"path":"/blog/2016/11/29/testing-laravel-middleware/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2016/11/26/easy-static-asset-versioning-in-php/"},"frontmatter":{"title":"Easy static asset versioning in PHP","date":"2016-11-26 21:40:39 +0000","layout":"post"}},"next":{"fields":{"path":"/blog/2017/02/18/integrating-behat-with-laravel/"},"frontmatter":{"title":"Integrating Behat with Laravel","date":"2017-02-18 21:25:57 +0000","layout":"post"}}}},
    "staticQueryHashes": ["290055352","2909664151"]}