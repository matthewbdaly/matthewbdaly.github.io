{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2022/12/18/two-techniques-for-handling-recursive-relationships-in-mysql/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"cc372601-6065-5f2b-b3df-be527e6fddb0","body":"var _excluded = [\"components\"];\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Two techniques for handling recursive relationships in MySQL\",\n  \"date\": \"2022-12-18 14:15:00 +0000\",\n  \"layout\": \"post\",\n  \"categories\": [\"sql\", \"mysql\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"When modelling users in a hierarchical organization, it's common to need to retrieve the line manager or subordinates of a given user. In MySQL, two of the techniques that can be used to handle these recursive relationships are the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WITH RECURSIVE\"), \" common table expression and using closure tables.\"), mdx(\"h3\", null, \"Using CTEs with \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"WITH RECURSIVE\")), mdx(\"p\", null, \"A common table expression (CTE) is a temporary result set that is defined within the execution scope of a single SQL statement. In MySQL, you can use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WITH RECURSIVE\"), \" clause to define a CTE that can be used to retrieve all of the users above or below a given user in the hierarchy.\"), mdx(\"p\", null, \"Say we have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"users\"), \" table that looks like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"CREATE TABLE users (\\n  id INTEGER PRIMARY KEY,\\n  name VARCHAR(255) NOT NULL,\\n  manager_id INTEGER REFERENCES users(id)\\n);\\n\")), mdx(\"p\", null, \"To create a CTE that gets the users above a given user, you can use the following query:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"WITH RECURSIVE managers AS (\\n  SELECT id, name, manager_id\\n  FROM users\\n  WHERE id = :user_id\\nUNION ALL\\n  SELECT u.id, u.name, u.manager_id\\n  FROM users u\\n  INNER JOIN managers m ON m.manager_id = u.id\\n)\\nSELECT * FROM managers;\\n\")), mdx(\"p\", null, \"This query uses the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WITH RECURSIVE\"), \" clause to define a CTE called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"managers\"), \" that first selects the user with the given \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"user_id\"), \" and then uses the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UNION ALL\"), \" operator to combine that user with all of the users above them in the hierarchy. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INNER JOIN\"), \" clause is used to link the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"managers\"), \" CTE to the users table, so that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"managers\"), \" CTE can keep growing until it includes all of the users above the given user in the hierarchy.\"), mdx(\"p\", null, \"To get the users below a given user, you can use a similar query, but with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"manager_id\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" fields swapped in the INNER JOIN clause:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"WITH RECURSIVE subordinates AS (\\n  SELECT id, name, manager_id\\n  FROM users\\n  WHERE id = :user_id\\nUNION ALL\\n  SELECT u.id, u.name, u.manager_id\\n  FROM users u\\n  INNER JOIN subordinates s ON s.id = u.manager_id\\n)\\nSELECT * FROM subordinates;\\n\")), mdx(\"p\", null, \"This query uses the same technique as the previous example, but it retrieves the users below the given user instead of above.\"), mdx(\"h3\", null, \"Using closure tables\"), mdx(\"p\", null, \"Another technique for handling recursive relationships in MySQL is to use closure tables. A closure table is a special type of table that is used to represent hierarchical data in a relational database. It consists of two tables: one for the entities in the hierarchy (e.g. users) and one for the relationships between those entities.\"), mdx(\"p\", null, \"To create a closure table for a hierarchy of users, you can use the following DDL statement:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"CREATE TABLE users (\\n  id INTEGER PRIMARY KEY,\\n  name VARCHAR(255) NOT NULL\\n);\\n\\nCREATE TABLE hierarchy (\\n  ancestor INTEGER NOT NULL REFERENCES users(id),\\n  descendant INTEGER NOT NULL REFERENCES users(id),\\n  PRIMARY KEY (ancestor, descendant),\\n  CHECK (ancestor != descendant)\\n);\\n\")), mdx(\"p\", null, \"The users table is similar to the one in the previous example, but it only contains the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" fields. The relationships between the users are defined in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hierarchy\"), \" table.\"), mdx(\"p\", null, \"To insert data into these tables, you would first need to insert rows into the users table for each user in the hierarchy, and then insert rows into the hierarchy table to define the relationships between those users. Here is an example of how this could be done:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"INSERT INTO users (id, name) VALUES\\n  (1, 'Alice'),\\n  (2, 'Bob'),\\n  (3, 'Carol'),\\n  (4, 'Dave'),\\n  (5, 'Eve');\\n\\nINSERT INTO hierarchy (ancestor, descendant) VALUES\\n  (1, 1),\\n  (1, 2),\\n  (1, 3),\\n  (1, 4),\\n  (1, 5),\\n  (2, 2),\\n  (2, 3),\\n  (2, 4),\\n  (3, 3),\\n  (4, 4);\\n\")), mdx(\"p\", null, \"This inserts five users into the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"users\"), \" table and then inserts rows into the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hierarchy\"), \" table to define the relationships between those users. The ancestor and descendant values are both set to the same id for each user, which indicates that each user is a descendant of themselves. The hierarchy table also defines the relationships between the users, with each user being a descendant of the user above them in the hierarchy.\"), mdx(\"p\", null, \"To get all of the users above a given user using a closure table, you can use the following query:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT u.*\\nFROM users u\\nINNER JOIN hierarchy h ON h.descendant = :user_id\\nWHERE u.id = h.ancestor\\n\")), mdx(\"p\", null, \"This query uses an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INNER JOIN\"), \" to link the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"users\"), \" table to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hierarchy\"), \" table, and then filters the results to only include users that are ancestors of the user with the given \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"user_id\"), \". This query will return a list of all of the users above the given user in the hierarchy.\"), mdx(\"p\", null, \"To get the users below a given user, you can use a similar query, but with the ancestor and descendant fields swapped in the INNER JOIN clause:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT u.*\\nFROM users u\\nINNER JOIN hierarchy h ON h.ancestor = :user_id\\nWHERE u.id = h.descendant\\n\")), mdx(\"p\", null, \"This query will return a list of all of the users below the given user in the hierarchy.\"), mdx(\"p\", null, \"One downside of the closure table approach is that when the hierarchical structure changes, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hierarchy\"), \" table needs to be updated to reflect the changes. There are a number of approaches you can take to handle this, including:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Creating MySQL triggers to update the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"hierarchy\"), \" table automatically when a user is inserted, updated or deleted\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using events, such as Eloquent model events, to apply the changes in application code\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Truncating and repopulating the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"hierarchy\"), \" table from scratch\")), mdx(\"p\", null, \"The first approach is generally the most efficient, but has the downside that triggers aren't generally exported from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mysqldump\"), \", making it difficult to manage when importing the production database locally. The last approach often makes the most sense in cases where users are populated from some kind of regular import, in which case the hierarchy will only ever change as a result of that import.\"), mdx(\"h3\", null, \"Which one should I use?\"), mdx(\"p\", null, \"Which of these approaches you should choose in a given situation is highly dependent on the specific needs of your application, since each has advantages and limitations.\"), mdx(\"p\", null, \"Using a closure table results in a smaller, simpler, and generally more efficient query that is easy to express using an ORM or query builder, but requires that you take steps to update the separate closure table when the hierarchy changes. Using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WITH RECURSIVE\"), \" CTE doesn't require a separate table, eliminating the need to populate said table, but for some queries it may not be as efficient. In addition, it can be difficult to express with some ORMs and query builders, necessitating either additional third party packages or falling back to raw queries. If you're stuck using an older version of MySQL, such as on a legacy application, and can't upgrade, you might also not be able to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WITH RECURSIVE\"), \" (though at this point you \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"really\"), \" shouldn't be using a version that old).\"), mdx(\"p\", null, \"At times I've found it necessary to combine both techniques. One application I maintain has a nightly import process for all the users and derives the permissions to view various pieces of content in part from the hierarchy - the only way to determine the hierarchy is by following the line managers back all the way to the managing director for each individual user, but permissions can be assigned to individual business units within the company and cascade down to child business units, and so to know what permissions a user has, we need to know where they sit in the hierarchy. This query would be too cumbersome to perform on the fly for each user, so we use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WITH RECURSIVE\"), \" CTE to detetermine a user's place within the hierarchy, and then populate a closure table from it, as a part of the nightly import.\"), mdx(\"h3\", null, \"Conclusion\"), mdx(\"p\", null, \"In MySQL, there are a number of techniques that can be used to handle recursive relationships in hierarchical data, but two of the most performant and flexible are the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WITH RECURSIVE\"), \" CTE and using closure tables. Both techniques have their own benefits and drawbacks, and the best choice will depend on the specific requirements of your application.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"When modelling users in a hierarchical organization, it's common to need to retrieve the line manager or subordinates of a given user. In MySQL, two of the techniques that can beâ€¦","frontmatter":{"title":"Two techniques for handling recursive relationships in MySQL","date":"18th December 2022 2:15 pm","isoDate":"2022-12-18T14:15:00+00:00","categories":["sql","mysql"]},"fields":{"path":"/blog/2022/12/18/two-techniques-for-handling-recursive-relationships-in-mysql/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2022/12/11/what-i-think-chatgpt-means-for-developers/"},"frontmatter":{"title":"What I think ChatGPT means for developers","date":"2022-12-11 19:20:00 +0000","layout":"post"}},"next":{"fields":{"path":"/blog/2023/08/13/why-nearly-every-php-class-you-write-should-be-abstract-or-final/"},"frontmatter":{"title":"Why (nearly) every PHP class you write should be abstract or final","date":"2023-08-13 15:00:00 +0000","layout":"post"}}}},"staticQueryHashes":["1776624730","3528622268"]}