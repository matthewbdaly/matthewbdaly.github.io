{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2022/10/02/everythings-potentially-a-callable/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"a0c0deef-79e6-57d1-bada-1f4382f40479","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Everything's (potentially) a callable\",\n  \"date\": \"2022-10-02 19:30:00 +0000\",\n  \"layout\": \"post\",\n  \"categories\": [\"php\"],\n  \"comments\": true\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Notice = makeShortcode(\"Notice\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I'm a big fan of callables in PHP in general. They're an extremely powerful way to build applications out of many different reusable components, in a way that combines the best aspects of object-oriented and functional programming.\"), mdx(\"p\", null, \"If you're not familiar with the idea, consider this class:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\ndeclare(strict_types=1);\\n\\nnamespace App\\\\Jobs;\\n\\nuse Illuminate\\\\Database\\\\ConnectionInterface;\\nuse Illuminate\\\\Support\\\\Benchmark;\\n\\nfinal class Printer\\n{\\n    public function __invoke(string $value): void\\n    {\\n        echo $value;\\n    }\\n}\\n\")), mdx(\"p\", null, \"Note the use of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__invoke()\"), \" magic method. This gets called if you try to call the object as a function, eg:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\n// Will echo \\\"Hello, World!\\\"\\n$printer = new Printer();\\n$printer(\\\"Hello, World!\\\");\\n\")), mdx(\"p\", null, \"Now, this may not seem like a terribly big deal, but it's only once you start putting them together that their real power becomes apparent. They're essentially \\\"closures on steroids\\\" in that they can do basically anything a closure can, and a lot of stuff they can't:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"An invokable class passes the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"callable\"), \" type hint, so you can generally use it in most of the same places you would a closure. As such, if you have a closure whose functionality needs to be reused elsewhere, it may make sense to refactor it into an invokable class.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Because they're classes, if they get large enough for it to be worthwhile, you can refactor part of the functionality into private methods. You can also pull in additional functionality through inheritance or traits if need be, but as this approach makes composition more achievable, you may find you don't often need to do so.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"You can use constructor injection to pull in any dependencies the class has in a way you can't with closures.\")), mdx(\"p\", null, \"As such, invokables let you chain functionality in the same way you would with closures, but with more capabilities and a higher level of abstraction. For instance, imagine you work on an e-commerce application, where each order is represented by an ORM model called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Order\"), \", and the job to process an order is implemented in an invokable class called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ProcessOrder\"), \", which accepts an instance of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Order\"), \". Now, imagine a third party want to place multiple orders by sending a CSV file over FTP. Because you implemented \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ProcessOrder\"), \" as an invokable, all you need to do is get the CSV data, generate an instance of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Order\"), \" from each row, and pass it into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ProcessOrder\"), \", without changing a single existing line of code. You might do something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\n$data = file_get_contents($remote_url);\\n$result = Collection::make($data)\\n    ->map(App::make(ConvertToOrder::class))\\n    ->each(App::make(ProcessOrder::class));\\n\")), mdx(\"p\", null, \"All \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ConvertToOrder\"), \" has to do is take the array data and create the model instance, then pass it on. Orders are processed consistently between those on the e-commerce site and those received via FTP, and the amount of new code required is minimal, limited to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ConvertToOrder\"), \" class and whatever command class is being triggered (in this case, it might be an Artisan command). As long as you've picked an appropriate name for each class, it's really obvious how this pipeline works and what each step does, without the developer having to even open the class in question.\"), mdx(\"p\", null, \"Using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__invoke()\"), \" as the defined method for doing something when the class only carries out a single action also makes sense as a general convention. If the class name, by itself, defines what the class is meant to do, then a method name is largely superfluous, and you end up making your method something like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"process()\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"execute()\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"handle()\"), \". Using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__invoke()\"), \" instead is both more concise and more consistent, because it allows you to use the shorter syntax, without the need to either choose or remember an actual method name.\"), mdx(\"p\", null, \"Assuming you're working with a framework like Laravel, then as long as you're working on a class that's not one of the class types explicitly required by the framework, then you should be fine to use invokables however you like. For instance, if you have something like the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ProcessOrder\"), \" service class above, then its only real dependency on Laravel itself would be that it takes in an ORM instance, plus whatever is pulled in via constructor injection. However, classes generated by the framework itself are more dependent on a particular, predefined structure. That said, there are some parts of the framework that are amenable to using invokables.\"), mdx(\"h2\", null, \"Controllers\"), mdx(\"p\", null, \"For a while now, Laravel has supported \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://laravel.com/docs/9.x/controllers#single-action-controllers\"\n  }, \"single action controllers\"), \", which implement a single \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__invoke()\"), \" method, as in this example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\ndeclare(strict_types=1);\\n\\nnamespace App\\\\Http\\\\Controllers;\\n\\nuse App\\\\Models\\\\User;\\n\\nfinal class FooController extends Controller\\n{\\n    /**\\n     * Return a view\\n     *\\n     * @return \\\\Illuminate\\\\Http\\\\Response\\n     */\\n    public function __invoke()\\n    {\\n        return view('foo');\\n    }\\n}\\n\")), mdx(\"p\", null, \"This has the following advantages:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Injecting dependencies into a controller's constructor adds to the time taken to process the request, and if you have a controller which handles multiple actions, then you may often be injecting dependencies for a route which aren't required for that route, which can have a noticeable performance impact. By breaking larger controllers down into single action controllers, you can prevent that from happening.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Setting up routing for the controller is simpler - it just needs to accept the class name, not the method name.\")), mdx(\"p\", null, \"Using callables as controllers doesn't make sense for every use case. For instance, if you're building an API that exposes CRUD functionality for multiple resource types, it probably makes more sense to use a resource controller which defines all the actions for a given resource type, particularly if they're similar enough that you're extending a base resource controller with common functionality. But for any reasonably complex route, it may make sense to use a single action controller.\"), mdx(\"h2\", null, \"Middleware\"), mdx(\"p\", null, \"Middleware is something else that only really has one public method and could therefore be implemented as an invokable, at least in theory. Some frameworks, such as Laminas, explicitly support it. The Laravel documentation doesn't appear to mention it, but after some experimentation I've discovered that it's possible to use callables as middleware in Laravel. For instance, take this callable middleware class I wrote:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\ndeclare(strict_types=1);\\n\\nnamespace App\\\\Http\\\\Middleware;\\n\\nuse Illuminate\\\\Http\\\\Request;\\nuse Illuminate\\\\Http\\\\Response;\\n\\nfinal class CallableDemo\\n{\\n    public function __invoke(Request $request, $next): Response\\n    {\\n        $response = $next($request);\\n        $response->header('X-Clacks-Overhead', 'GNU Terry Pratchett');\\n        return $response;\\n    }\\n}\\n\")), mdx(\"p\", null, \"This is a relatively simple middleware class which adds the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://www.gnuterrypratchett.com/\"\n  }, \"X-Clacks-Overhead header\"), \" to the response. At least in a recent version of Laravel 9, the following method of adding middleware in the router works:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\n...\\nuse App\\\\Http\\\\Middleware\\\\CallableDemo;\\n\\n...\\n\\nRoute::resource('foo', FooController::class)\\n->middleware(CallableDemo::class);\\n\")), mdx(\"p\", null, \"As does declaring it as global middleware in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app\\\\Http\\\\Kernel.php\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Http;\\n...\\n\\nclass Kernel extends HttpKernel\\n{\\n    protected $middleware = [\\n        ...\\n        \\\\App\\\\Http\\\\Middleware\\\\CallableDemo::class,\\n    ];\\n\")), mdx(\"p\", null, \"Or in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"web\"), \" group:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\n...\\n    /**\\n     * The application's route middleware groups.\\n     *\\n     * @var array<string, array<int, class-string|string>>\\n     */\\n    protected $middlewareGroups = [\\n        'web' => [\\n            ...\\n            \\\\App\\\\Http\\\\Middleware\\\\CallableDemo::class,\\n        ],\\n\")), mdx(\"p\", null, \"Or as route middleware:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n    protected $routeMiddleware = [\\n        ...\\n        'gnu'   => \\\\App\\\\Http\\\\Middleware\\\\CallableDemo::class,\\n    ];\\n\")), mdx(\"p\", null, \"This example doesn't cover middleware that accepts dependencies from the container, however. So what if we amend our middleware class to accept a raw database connection as a constructor dependency and use that in the middleware body to add a header giving the total number of users, as in this example?\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\ndeclare(strict_types=1);\\n\\nnamespace App\\\\Http\\\\Middleware;\\n\\nuse Illuminate\\\\Database\\\\ConnectionInterface;\\nuse Illuminate\\\\Http\\\\Request;\\nuse Illuminate\\\\Http\\\\Response;\\n\\nfinal class CallableDemo\\n{\\n    public function __construct(private ConnectionInterface $db)\\n    {\\n    }\\n\\n    public function __invoke(Request $request, $next): Response\\n    {\\n        $response = $next($request);\\n        $response->header('X-Clacks-Overhead', 'GNU Terry Pratchett');\\n        $response->header('X-Total-Users', $this->db->table('users')->count());\\n        return $response;\\n    }\\n}\\n\")), mdx(\"p\", null, \"Yes, looks like this works fine too.\"), mdx(\"h2\", null, \"Queue jobs\"), mdx(\"p\", null, \"Job classes are something else that do only one thing, and thus it potentially makes sense to use an invokable class for them. Consider this job class which uses the Benchmark helper to benchmark a query and dump the results to the screen:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\ndeclare(strict_types=1);\\n\\nnamespace App\\\\Jobs;\\n\\nuse Illuminate\\\\Database\\\\ConnectionInterface;\\nuse Illuminate\\\\Support\\\\Benchmark;\\n\\nfinal class ThingDoer\\n{\\n    public function __construct(private ConnectionInterface $db)\\n    {\\n    }\\n\\n    public function __invoke()\\n    {\\n        Benchmark::dd(fn() => $this->db->table('users')->get());\\n    }\\n}\\n\")), mdx(Notice, {\n    mdxType: \"Notice\"\n  }, \"This example will work if you're using the sync queue connection type, but likely not with any others, because the intent is to run a query and dump it out. Obviously, that isn't really the main use case of job classes, but it's fine for demonstrating the principle of using invokable classes for tasks that do one thing only.\"), mdx(\"p\", null, \"If we try the following in a route closure:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"Route::get('/', function () {\\n    dispatch(ThingDoer::class);\\n\")), mdx(\"p\", null, \"We see the error \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get_class(): Argument #1 ($object) must be of type object, string given\"), \". So instead, we need to fetch \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ThingDoer\"), \" from the container and pass it to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dispatch()\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"Route::get('/', function (ThingDoer $doer) {\\n    dispatch($doer);\\n\")), mdx(\"p\", null, \"In a controller, it may well make more sense to do this via method injection.\"), mdx(\"h2\", null, \"Event listeners\"), mdx(\"p\", null, \"Event listeners are yet another example of something that only really does one thing. This invokable listener is based on the one used to send notifications in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://bootcamp.laravel.com/inertia/notifications-and-events\"\n  }, \"Laravel Bootcamp\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Listeners;\\n\\nuse App\\\\Events\\\\ChirpCreated;\\nuse App\\\\Models\\\\User;\\nuse App\\\\Notifications\\\\NewChirp;\\nuse Illuminate\\\\Contracts\\\\Queue\\\\ShouldQueue;\\nuse Illuminate\\\\Queue\\\\InteractsWithQueue;\\n\\nclass SendChirpCreatedNotifications implements ShouldQueue\\n{\\n    /**\\n     * Create the event listener.\\n     *\\n     * @return void\\n     */\\n    public function __construct()\\n    {\\n        //\\n    }\\n\\n    /**\\n     * Handle the event.\\n     *\\n     * @param  \\\\App\\\\Events\\\\ChirpCreated  $event\\n     * @return void\\n     */\\n    public function __invoke(ChirpCreated $event)\\n    {\\n        foreach (User::cursor() as $user) {\\n            $user->notify(new NewChirp($event->chirp));\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"This works in exactly the same way as a standard listener class. If you map it to an event class in the usual way, it works entirely as expected. However, as with some of the other examples, it's not clear if it supports constructor injection, so it's best to check. If we amend the listener as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Listeners;\\n\\nuse App\\\\Events\\\\ChirpCreated;\\nuse App\\\\Models\\\\User;\\nuse App\\\\Notifications\\\\NewChirp;\\nuse Illuminate\\\\Contracts\\\\Queue\\\\ShouldQueue;\\nuse Illuminate\\\\Database\\\\ConnectionInterface;\\nuse Illuminate\\\\Queue\\\\InteractsWithQueue;\\n\\nclass SendChirpCreatedNotifications implements ShouldQueue\\n{\\n    /**\\n     * Create the event listener.\\n     *\\n     * @return void\\n     */\\n    public function __construct(private ConnectionInterface $db)\\n    {\\n    }\\n\\n    /**\\n     * Handle the event.\\n     *\\n     * @param  \\\\App\\\\Events\\\\ChirpCreated  $event\\n     * @return void\\n     */\\n    public function __invoke(ChirpCreated $event)\\n    {\\n        foreach ($this->db->table('users')->cursor() as $user) {\\n            dd($user);\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"Now, if we trigger the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ChirpCreated\"), \" event, it breaks at the right point and spits out the user data as expected, thus demonstrating that it works.\"), mdx(\"h2\", null, \"Limitations\"), mdx(\"p\", null, \"There are some limitations of using invokable classes which you should bear in mind when deciding whether to make a class an invokable or not. For instance, accessing an invokable as as property of another class can be awkward - take this controller class:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace AppServiceProvider\\n\\nuse App\\\\Jobs\\\\ThingDoer;\\n\\nfinal class FooController extends Controller\\n{\\n    public function __construct(private ThingDoer $thingDoer)\\n    {\\n    }\\n\\n    /**\\n     * Return a view\\n     *\\n     * @return \\\\Illuminate\\\\Http\\\\Response\\n     */\\n    public function __invoke()\\n    {\\n        // Call $this->thingDoer...\\n        return view('foo');\\n    }\\n}\\n\")), mdx(\"p\", null, \"We can't call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$this->thingDoer()\"), \" because \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$this\"), \" refers to the instance of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FooController\"), \", and so we're referring to a non-existing method of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FooController\"), \" called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"thingDoer\"), \" rather than the property \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$this->thingDoer\"), \". There are a couple of ways to do it. You can call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__invoke()\"), \" explicitly, which isn't very elegant:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nfinal class FooController extends Controller\\n{\\n    ...\\n    /**\\n     * Return a view\\n     *\\n     * @return \\\\Illuminate\\\\Http\\\\Response\\n     */\\n    public function __invoke()\\n    {\\n        $this->thingDoer->__invoke();\\n        return view('foo');\\n    }\\n}\\n\")), mdx(\"p\", null, \"Or you can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"call_user_func()\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nfinal class FooController extends Controller\\n{\\n    ...\\n    /**\\n     * Return a view\\n     *\\n     * @return \\\\Illuminate\\\\Http\\\\Response\\n     */\\n    public function __invoke()\\n    {\\n        call_user_func($this->thingDoer);\\n        return view('foo');\\n    }\\n}\\n\")), mdx(\"p\", null, \"Or, my personal favourite approach:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nfinal class FooController extends Controller\\n{\\n    ...\\n    /**\\n     * Return a view\\n     *\\n     * @return \\\\Illuminate\\\\Http\\\\Response\\n     */\\n    public function __invoke()\\n    {\\n        ($this->thingDoer)();\\n        return view('foo');\\n    }\\n}\\n\")), mdx(\"p\", null, \"In the context of Laravel controllers, you also have the option to use method injection:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nfinal class FooController extends Controller\\n{\\n    ...\\n    /**\\n     * Return a view\\n     *\\n     * @return \\\\Illuminate\\\\Http\\\\Response\\n     */\\n    public function __invoke(ThingDoer $thingDoer)\\n    {\\n        $thingDoer();\\n        return view('foo');\\n    }\\n}\\n\")), mdx(\"h2\", null, \"Summary\"), mdx(\"p\", null, \"Using invokable classes for any part of your application that does one thing only, and could potentially be reused, makes a lot of sense. It allows for more elegant code, giving you the advantages of functional programming without losing the benefits of OOP, and allows you to break your application down into a selection of easily reusable parts. While I've not been in a position to try it before, I also suspect that it makes decorating components simpler, to the point that certain tasks like logging and caching can be done with a single closure or invokable. Next time you write a class to do something, give serious thought to the idea of whether it should be an invokable - the answer may be \\\"yes\\\" more often than you think, and it'll often help make your code simpler and more reusable.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"I'm a big fan of callables in PHP in general. They're an extremely powerful way to build applications out of many different reusable components, in a way that combines the best…","frontmatter":{"title":"Everything's (potentially) a callable","date":"2nd October 2022 7:30 pm","isoDate":"2022-10-02T19:30:00+00:00","categories":["php"]},"fields":{"path":"/blog/2022/10/02/everythings-potentially-a-callable/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2022/06/05/the-orm-delusion/"},"frontmatter":{"title":"The ORM Delusion","date":"2022-06-05 18:00:00 +0000","layout":"post"}},"next":{"fields":{"path":"/blog/2022/10/26/why-i-no-longer-use-the-repository-pattern/"},"frontmatter":{"title":"Why I no longer use the repository pattern","date":"2022-10-26 17:30:00 +0000","layout":"post"}}}},"staticQueryHashes":["290055352","2909664151"]}