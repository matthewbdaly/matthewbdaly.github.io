{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2015/07/04/handling-images-as-base64-strings-with-django-rest-framework/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"e855382b-7926-5e69-ad15-40ce93848e60","body":"var _excluded = [\"components\"];\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Handling images as base64 strings with Django REST Framework\",\n  \"date\": \"2015-07-04 13:01:40 +0100\",\n  \"layout\": \"post\",\n  \"categories\": [\"python\", \"django\", \"djangorestframework\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I'm currently working on a Phonegap app that involves taking pictures and uploading them via a REST API. I've done this before, and I found at that time that the best way to do so was to fetch the image as a base-64 encoded string and push that up, rather than the image file itself. However, the last time I did so, I was using Tastypie to build the API, and I've since switched over to Django REST Framework as my API toolkit of choice.\"), mdx(\"p\", null, \"It didn't take long to find \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://gist.github.com/yprez/7704036\"\n  }, \"this gist\"), \" giving details of how to do so, but it didn't work as is, partly because I was using Python 3, and partly because the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"from_native\"), \" method has gone as at Django REST Framework 3.0. It was, however, straightforward to adapt it to work. Here's my solution:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"import base64, uuid\\nfrom django.core.files.base import ContentFile\\nfrom rest_framework import serializers\\n\\n\\n# Custom image field - handles base 64 encoded images\\nclass Base64ImageField(serializers.ImageField):\\n    def to_internal_value(self, data):\\n        if isinstance(data, str) and data.startswith('data:image'):\\n            # base64 encoded image - decode\\n            format, imgstr = data.split(';base64,') # format ~= data:image/X,\\n            ext = format.split('/')[-1] # guess file extension\\n            id = uuid.uuid4()\\n            data = ContentFile(base64.b64decode(imgstr), name = id.urn[9:] + '.' + ext)\\n        return super(Base64ImageField, self).to_internal_value(data)\\n\")), mdx(\"p\", null, \"This solution will handle both base 64 encoded strings and image files. Then, just use this field as normal.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"I'm currently working on a Phonegap app that involves taking pictures and uploading them via a REST API. I've done this before, and I found at that time that the best way to do soâ€¦","frontmatter":{"title":"Handling images as base64 strings with Django REST Framework","date":"4th July 2015 12:01 pm","isoDate":"2015-07-04T12:01:40+00:00","categories":["python","django","djangorestframework"]},"fields":{"path":"/blog/2015/07/04/handling-images-as-base64-strings-with-django-rest-framework/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2015/06/17/getting-django-behave-and-celery-to-work-together/"},"frontmatter":{"title":"Getting django-behave and Celery to work together","date":"2015-06-17 20:34:08 +0100","layout":"post"}},"next":{"fields":{"path":"/blog/2015/07/21/new-laptop/"},"frontmatter":{"title":"New laptop","date":"2015-07-21 21:15:52 +0100","layout":"post"}}}},"staticQueryHashes":["1776624730","458490740"]}