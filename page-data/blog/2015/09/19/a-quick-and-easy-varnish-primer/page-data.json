{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2015/09/19/a-quick-and-easy-varnish-primer/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"9ffd25b3-7939-5dcf-9da0-51ac20244ef8","body":"var _excluded = [\"components\"];\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"A quick and easy Varnish primer\",\n  \"date\": \"2015-09-19 19:42:17 +0100\",\n  \"layout\": \"post\",\n  \"categories\": [\"varnish\", \"performance\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"As I \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/blog/2015/08/22/when-you-should-not-use-wordpress/\"\n  }, \"mentioned in an earlier post\"), \", I recently had the occasion to use Varnish to improve the performance of a website that otherwise would have been unreliable and unusably slow due to WordPress making an excessive number of queries. The difference it made was nothing short of staggering, and I'm not exaggerating when I say it saved the day. I now use Ansible for provisioning new WordPress sites, and Varnish is now a standard part of my WordPress site setup playbook.\"), mdx(\"p\", null, \"However, Varnish can be quite fiddly to configure, and it was something of a baptism of fire for me to learn how to configure it appropriately for this use case. I did make a few mistakes that caused problems down the line, so I thought I'd share the details of how I got it working for that particular site.\"), mdx(\"h2\", null, \"What is Varnish?\"), mdx(\"p\", null, \"From \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.varnish-cache.org/about\"\n  }, \"the website\"), \":\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Varnish Cache is a web application accelerator also known as a caching HTTP reverse proxy. You install it in front of any server that speaks HTTP and configure it to cache the contents. Varnish Cache is really, really fast. It typically speeds up delivery with a factor of 300 - 1000x, depending on your architecture.\")), mdx(\"p\", null, \"In other words, you run it on the usual HTTP or HTTPS port, move your usual web server to a different port, and configure it, and it will cache web pages so they can be served more quickly to subsequent visitors.\"), mdx(\"p\", null, \"Be warned - Varnish is not something where you can generally stick with the default settings. The default behaviour does make a lot of sense, but in practice almost no-one will be able to get away with leaving the configuration unchanged.\"), mdx(\"h2\", null, \"Installing Varnish\"), mdx(\"p\", null, \"If you're using Debian or a derivative such as Ubuntu, Varnish is available via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"apt-get\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ sudo apt-get install varnish\\n\")), mdx(\"p\", null, \"You may also want to install the documentation:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ sudo apt-get install varnish-doc\\n\")), mdx(\"p\", null, \"If you're using Apache I'd also recommend installing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"libapache2-mod-rpaf\"), \" and enabling it with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sudo a2enmod rpaf\"), \" - without this, Apache will log all incoming requests as coming from the same server.\"), mdx(\"p\", null, \"I'm assuming you already have a normal web server installed. I'll assume you're using Apache, but it shouldn't be hard to adapt these instructions to work with Nginx. I'm also assuming that the site you want to use Varnish for is a WordPress site with WooCommerce and W3 Total Cache installed. However, this is only for example purposes. If you want to use Varnish for a different web app, you'll need to plan your caching strategy around that web app yourself.\"), mdx(\"p\", null, \"Please also note that this is using Varnish 4.0, which is the version available with Debian Jessie. If you're using an older operating system, you may have Varnish 3.0 in the repositories - be warned, the configuration language changed in Varnish 4.0, so the examples here will not work with older versions of Varnish.\"), mdx(\"p\", null, \"By default, Varnish runs on port 6081, which is fine for testing it out, but once you want to go live it's not what you want. When it's time to go live, you'll need to open up \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/etc/default/varnish\"), \" and edit the value of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DAEMON_OPTS\"), \" to something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"DAEMON_OPTS=\\\"-a :80 \\\\\\n             -T localhost:6082 \\\\\\n             -f /etc/varnish/default.vcl \\\\\\n             -S /etc/varnish/secret \\\\\\n             -s malloc,256m\\\"\\n\")), mdx(\"p\", null, \"Note that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-a\"), \" flag represents the port Varnish is running on.\"), mdx(\"p\", null, \"If you're using an operating system that uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"systemd\"), \", such as Debian Jessie, this alone won't be sufficient. Create a new file at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/etc/systemd/system/varnish.service\"), \" and enter the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"[Unit]\\nDescription=Varnish HTTP accelerator\\n\\n[Service]\\nType=forking\\nLimitNOFILE=131072\\nLimitMEMLOCK=82000\\nExecStartPre=/usr/sbin/varnishd -C -f /etc/varnish/default.vcl\\nExecStart=/usr/sbin/varnishd -a :80 -T localhost:6082 -f /etc/varnish/default.vcl -S /etc/varnish/secret -s malloc,256m\\nExecReload=/usr/share/varnish/reload-vcl\\n\\n[Install]\\nWantedBy=multi-user.target\\n\")), mdx(\"p\", null, \"Next, we need to move our web server to a different port. We'll use port 8080. Replace the contents of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/etc/apache2/ports.conf\"), \" with this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-apache\"\n  }, \"# If you just change the port or add more ports here, you will likely also\\n# have to change the VirtualHost statement in\\n# /etc/apache2/sites-enabled/000-default\\n# This is also true if you have upgraded from before 2.2.9-3 (i.e. from\\n# Debian etch). See /usr/share/doc/apache2.2-common/NEWS.Debian.gz and\\n# README.Debian.gz\\n\\nNameVirtualHost *:8080\\nListen 8080\\n\\n<IfModule mod_ssl.c>\\n    # If you add NameVirtualHost *:443 here, you will also have to change\\n    # the VirtualHost statement in /etc/apache2/sites-available/default-ssl\\n    # to <VirtualHost *:443>\\n    # Server Name Indication for SSL named virtual hosts is currently not\\n    # supported by MSIE on Windows XP.\\n    Listen 443\\n</IfModule>\\n\\n<IfModule mod_gnutls.c>\\n    Listen 443\\n</IfModule>\\n\")), mdx(\"p\", null, \"You'll also need to change the ports for the individual site files under \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/etc/apache2/sites-available\"), \", as in this example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-apache\"\n  }, \"<VirtualHost *:8080>\\n    ServerAdmin webmaster@localhost\\n\\n    DocumentRoot /var/www\\n    <Directory />\\n        Options FollowSymLinks\\n        AllowOverride All\\n    </Directory>\\n    <Directory /var/www/>\\n        Options FollowSymLinks MultiViews\\n        AllowOverride All\\n        Order allow,deny\\n        allow from all\\n    </Directory>\\n\\n    ScriptAlias /cgi-bin/ /usr/lib/cgi-bin/\\n    <Directory \\\"/usr/lib/cgi-bin\\\">\\n        AllowOverride None\\n        Options +ExecCGI -MultiViews +SymLinksIfOwnerMatch\\n        Order allow,deny\\n        Allow from all\\n    </Directory>\\n\\n    ErrorLog ${APACHE_LOG_DIR}/error.log\\n\\n    # Possible values include: debug, info, notice, warn, error, crit,\\n    # alert, emerg.\\n    LogLevel warn\\n\\n    CustomLog ${APACHE_LOG_DIR}/access.log combined\\n</VirtualHost>\\n\")), mdx(\"h2\", null, \"Writing our VCL file\"), mdx(\"p\", null, \"Next, we come to our Varnish configuration proper, which resides at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/etc/varnish/default.vcl\"), \". The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"vcl\"), \" stands for Varnish Configuration Language, and it has a syntax somewhat reminiscent of C.\"), mdx(\"p\", null, \"The default behaviour for Varnish is as follows:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It does not cache requests that contain cookie or authorisation headers\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It does not cache requests which the backend HTTP server indicates should not be cached\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It will only cache GET and HEAD requests\")), mdx(\"p\", null, \"This behaviour is unlikely to meet your needs. We'll therefore work through the Varnish config file I wrote for this WordPress site in the hope that it will teach you enough to adapt it to your own needs.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"vcl 4.0;\\n\\nbackend default {\\n    .host = \\\"127.0.0.1\\\";\\n    .port = \\\"8080\\\";\\n}\\n\\nacl purge {\\n    \\\"127.0.0.1\\\";\\n    \\\"localhost\\\";\\n}\\n\\nsub vcl_recv {\\n\\n    # Never cache PUT, PATCH, DELETE or POST requests\\n    if (req.method == \\\"PUT\\\" || req.method == \\\"PATCH\\\" || req.method == \\\"DELETE\\\" || req.method == \\\"POST\\\") {\\n        return (pass);\\n    }\\n\\n    # Never cache cart, account, checkout or addons\\n    if (req.url ~ \\\"^/(cart|my-account|checkout|addons)\\\") {\\n        return (pass);\\n    }\\n\\n    # Never cache adding to cart\\n    if ( req.url ~ \\\"\\\\?add-to-cart=\\\" ) {\\n        return (pass);\\n    }\\n\\n    # Never cache admin or login\\n    if ( req.url ~ \\\"^/wp-(admin|login|cron)\\\" ) {\\n        return (pass);\\n    }\\n\\n    # Never cache WooCommerce API\\n    if ( req.url ~ \\\"wc-api\\\" ) {\\n        return (pass);\\n    }\\n\\n    # Remove has_js and CloudFlare/Google Analytics __* cookies and statcounter is_unique\\n    set req.http.Cookie = regsuball(req.http.Cookie, \\\"(^|;\\\\s*)(_[_a-z]+|has_js|is_unique)=[^;]*\\\", \\\"\\\");\\n    # Remove a \\\";\\\" prefix, if present.\\n    set req.http.Cookie = regsub(req.http.Cookie, \\\"^;\\\\s*\\\", \\\"\\\");\\n\\n    # Remove the wp-settings-1 cookie\\n    set req.http.Cookie = regsuball(req.http.Cookie, \\\"wp-settings-1=[^;]+(; )?\\\", \\\"\\\");\\n\\n    # Remove the wp-settings-time-1 cookie\\n    set req.http.Cookie = regsuball(req.http.Cookie, \\\"wp-settings-time-1=[^;]+(; )?\\\", \\\"\\\");\\n\\n    # Remove the wp test cookie\\n    set req.http.Cookie = regsuball(req.http.Cookie, \\\"wordpress_test_cookie=[^;]+(; )?\\\", \\\"\\\");\\n\\n    # Static content unique to the theme can be cached (so no user uploaded images)\\n    # The reason I don't take the wp-content/uploads is because of cache size on bigger blogs\\n    # that would fill up with all those files getting pushed into cache\\n    if (req.url ~ \\\"wp-content/themes/\\\" && req.url ~ \\\"\\\\.(css|js|png|gif|jp(e)?g)\\\") {\\n        unset req.http.cookie;\\n    }\\n\\n    # Even if no cookies are present, I don't want my \\\"uploads\\\" to be cached due to their potential size\\n    if (req.url ~ \\\"/wp-content/uploads/\\\") {\\n        return (pass);\\n    }\\n\\n    # any pages with captchas need to be excluded\\n    if (req.url ~ \\\"^/contact/\\\")\\n    {\\n        return(pass);\\n    }\\n\\n    # Check the cookies for wordpress-specific items\\n    if (req.http.Cookie ~ \\\"wordpress_\\\" || req.http.Cookie ~ \\\"comment_\\\") {\\n        # A wordpress specific cookie has been set\\n        return (pass);\\n    }\\n\\n    # allow PURGE from localhost\\n    if (req.method == \\\"PURGE\\\") {\\n        if (!client.ip ~ purge) {\\n            return(synth(405, \\\"Not allowed.\\\"));\\n        }\\n        return (purge);\\n    }\\n\\n    # Force lookup if the request is a no-cache request from the client\\n    if (req.http.Cache-Control ~ \\\"no-cache\\\") {\\n        return (pass);\\n    }\\n\\n    # Try a cache-lookup\\n    return (hash);\\n}\\n\\nsub vcl_backend_response {\\n    set beresp.grace = 5m;\\n}\\n\")), mdx(\"p\", null, \"Let's take a closer look at the first part of the config:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"vcl 4.0;\\n\\nbackend default {\\n    .host = \\\"127.0.0.1\\\";\\n    .port = \\\"8080\\\";\\n}\\n\")), mdx(\"p\", null, \"Here we define that we're using version 4.0 of VCL, and that the host to use as a back end is port 8080 on the same server. If your normal HTTP server is running on a different port, you will need to set it here. Also, note that you can use a different host as the backend.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"acl purge {\\n    \\\"127.0.0.1\\\";\\n    \\\"localhost\\\";\\n}\\n\")), mdx(\"p\", null, \"We also set which hosts can trigger a purge of the cache, namely \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"localhost\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"127.0.0.1\"), \". The web app hosted on the server can then make an HTTP \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PURGE\"), \" request to a given path, which will clear that path from the cache. In our case, W3 Total Cache supports this - if it's a custom web app, you'll need to implement this functionality yourself to clear the cache when new content is added.\"), mdx(\"p\", null, \"Next, we start the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"vcl_recv\"), \" subroutine. This is where we define our rules for deciding whether or not to serve content from the cache. Let's look at our first rule:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"sub vcl_recv {\\n\\n    # Never cache PUT, PATCH, DELETE or POST requests\\n    if (req.method == \\\"PUT\\\" || req.method == \\\"PATCH\\\" || req.method == \\\"DELETE\\\" || req.method == \\\"POST\\\") {\\n        return (pass);\\n    }\\n\")), mdx(\"p\", null, \"Here, we declare that we should never cache any \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PUT\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PATCH\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DELETE\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"POST\"), \" requests, on the basis that these change the state of the application. This ensures that things like contact forms will work as expected.\"), mdx(\"p\", null, \"Note that we're getting the value of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"req.method\"), \" to determine the HTTP verb used. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"req\"), \" object has many other properties we'll see being used.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"    # Never cache cart, account, checkout or addons\\n    if (req.url ~ \\\"^/(cart|my-account|checkout|addons)\\\") {\\n        return (pass);\\n    }\\n\\n    # Never cache adding to cart\\n    if ( req.url ~ \\\"\\\\?add-to-cart=\\\" ) {\\n        return (pass);\\n    }\\n\\n    # Never cache admin or login\\n    if ( req.url ~ \\\"^/wp-(admin|login|cron)\\\" ) {\\n        return (pass);\\n    }\\n\\n    # Never cache WooCommerce API\\n    if ( req.url ~ \\\"wc-api\\\" ) {\\n        return (pass);\\n    }\\n\")), mdx(\"p\", null, \"Next, we define a series of regular expressions, and if the URL (represented by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"req.url\"), \") matches that regex, then the request is passed straight through to Apache without Varnish getting involved. In this case, we never want to cache the following sections:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The shopping cart, checkout, addons page or account page\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The Add to cart button\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The WordPress admin and login screen, and cron requests\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The WooCommerce API\")), mdx(\"p\", null, \"You'll need to consider which parts of your site must always serve the latest content and which don't need everything to be fully up to date. Typically admin areas any anything interactive must not be cached, while the front page is usually fine.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"    # Remove has_js and CloudFlare/Google Analytics __* cookies and statcounter is_unique\\n    set req.http.Cookie = regsuball(req.http.Cookie, \\\"(^|;\\\\s*)(_[_a-z]+|has_js|is_unique)=[^;]*\\\", \\\"\\\");\\n    # Remove a \\\";\\\" prefix, if present.\\n    set req.http.Cookie = regsub(req.http.Cookie, \\\"^;\\\\s*\\\", \\\"\\\");\\n\\n    # Remove the wp-settings-1 cookie\\n    set req.http.Cookie = regsuball(req.http.Cookie, \\\"wp-settings-1=[^;]+(; )?\\\", \\\"\\\");\\n\\n    # Remove the wp-settings-time-1 cookie\\n    set req.http.Cookie = regsuball(req.http.Cookie, \\\"wp-settings-time-1=[^;]+(; )?\\\", \\\"\\\");\\n\\n    # Remove the wp test cookie\\n    set req.http.Cookie = regsuball(req.http.Cookie, \\\"wordpress_test_cookie=[^;]+(; )?\\\", \\\"\\\");\\n\\n\")), mdx(\"p\", null, \"Cookies, even ones set on the client side such as those for Google Analytics, can prevent content from being cached. To prevent this, you need to configure Varnish to discard these cookies before passing them on to Apache. In this case, we want to exclude Google Analytics and various WordPress cookies.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"    # Static content unique to the theme can be cached (so no user uploaded images)\\n    if (req.url ~ \\\"wp-content/themes/\\\" && req.url ~ \\\"\\\\.(css|js|png|gif|jp(e)?g)\\\") {\\n        unset req.http.cookie;\\n    }\\n\")), mdx(\"p\", null, \"Here we allow static content that's part of the site theme to be cached since that doesn't change often, so we unset the cookies for that request.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"    # Even if no cookies are present, I don't want my \\\"uploads\\\" to be cached due to their potential size\\n    if (req.url ~ \\\"/wp-content/uploads/\\\") {\\n        return (pass);\\n    }\\n\")), mdx(\"p\", null, \"Here we prevent any user-uploaded content from being cached, since that can change often.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"    # any pages with captchas need to be excluded\\n    if (req.url ~ \\\"^/contact/\\\")\\n    {\\n        return(pass);\\n    }\\n\")), mdx(\"p\", null, \"Captchas must obviously never be cached since that will break them. In this case, we assume that the contact form has a captcha, so it gets excluded from the cache.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"    # Check the cookies for wordpress-specific items\\n    if (req.http.Cookie ~ \\\"wordpress_\\\" || req.http.Cookie ~ \\\"comment_\\\") {\\n        # A wordpress specific cookie has been set\\n        return (pass);\\n    }\\n\")), mdx(\"p\", null, \"Here we check for remaining WordPress-specific cookies. These would indicate that a user is signed in, in which case we may want to serve them all the latest content rather than displaying content from the cache.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"    # allow PURGE from localhost\\n    if (req.method == \\\"PURGE\\\") {\\n        if (!client.ip ~ purge) {\\n            return(synth(405, \\\"Not allowed.\\\"));\\n        }\\n        return (purge);\\n    }\\n\")), mdx(\"p\", null, \"Remember where we allowed the local server to clear the cache? This section actually carries out the purge when it receives a request from an authorised client.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"    # Force lookup if the request is a no-cache request from the client\\n    if (req.http.Cache-Control ~ \\\"no-cache\\\") {\\n        return (pass);\\n    }\\n\")), mdx(\"p\", null, \"Here we check to see if the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Cache-Control\"), \" HTTP header is set to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"no-cache\"), \". If so, we pass it straight through to Apache.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"    # Try a cache-lookup\\n    return (hash);\\n}\\n\")), mdx(\"p\", null, \"This is the last rule under \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"vcl_recv\"), \", because it only reaches this point if the request has got past all the other rules. It tries to fetch the page from the cache. If the page is not in the cache, it passes it on to Apache and will cache the response.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"sub vcl_backend_response {\\n    set beresp.grace = 5m;\\n}\\n\")), mdx(\"p\", null, \"This is where we set how long responses are cached for. Here we've set it to 5 minutes.\"), mdx(\"p\", null, \"With that done, we should be ready to restart Varnish and Apache. If you are using an operating system with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"systemd\"), \", then the following commands should restart Apache and Varnish:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ sudo systemctl reload apache2.service\\n$ sudo systemctl reload varnish.service\\n\")), mdx(\"p\", null, \"For those not yet using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"systemd\"), \", try this instead:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ sudo service apache2 restart\\n$ sudo service varnish restart\\n\")), mdx(\"p\", null, \"If you then visit your site and inspect the HTTP headers using your browser's dev tools, you'll notice the new HTTP header \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"X-Varnish\"), \" in the response. This tells you that Varnish is up and running. If you make sure you're logged out, you should hopefully see that if you load a page, and then load it again, the second response is noticeably quicker.\"), mdx(\"p\", null, \"Installing and configuring Varnish is a relatively quick and easy way of helping your website scale to be able to serve many more users, and if the site becomes popular all of a sudden, it can make a huge difference as to whether the site can stand up to the load or not. If you need more information on how to configure Varnish for your own needs, I recommend consulting the excellent \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.varnish-cache.org/docs/4.0/\"\n  }, \"documentation\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"As I  mentioned in an earlier post , I recently had the occasion to use Varnish to improve the performance of a website that otherwise would have been unreliable and unusably slow…","frontmatter":{"title":"A quick and easy Varnish primer","date":"19th September 2015 6:42 pm","isoDate":"2015-09-19T18:42:17+00:00","categories":["varnish","performance"]},"fields":{"path":"/blog/2015/09/19/a-quick-and-easy-varnish-primer/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2015/08/22/when-you-should-not-use-wordpress/"},"frontmatter":{"title":"When you should not use Wordpress","date":"2015-08-22 19:32:34 +0100","layout":"post"}},"next":{"fields":{"path":"/blog/2015/09/28/building-a-real-time-twitter-stream-with-node-dot-js-react-dot-js-and-redis/"},"frontmatter":{"title":"Building a real-time Twitter stream with Node.js, React.js and Redis","date":"2015-09-28 20:00:55 +0100","layout":"post"}}}},"staticQueryHashes":["1776624730","458490740"]}