{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2013/12/28/django-blog-tutorial-the-next-generation-part-1/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"8bc26fdd-9124-5309-a41f-eef9891d26ab","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"layout\": \"post\",\n  \"title\": \"Django blog tutorial - the next generation - part 1\",\n  \"date\": \"2013-12-28 15:00:32 +0000\",\n  \"comments\": true,\n  \"categories\": [\"python\", \"django\", \"tdd\", \"django-blog-tutorial\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"My series of Django tutorials for building a blogging engine are by far the most popular posts I've ever written on here. I've had a lot of people contact me with questions or just to express their thanks, for which I'm very grateful!\"), mdx(\"p\", null, \"However, these tutorials haven't really aged well. I've since had the opportunity to use Django in a professional capacity, which has significantly improved my understanding of the framework and the whole Python ecosystem, and there's a lot of best practices that I didn't follow and now wish I had. There's also been a few gotchas that have hindered a few people in the past that I'd like to have the opportunity to correct.\"), mdx(\"p\", null, \"So, I'm therefore creating a brand new series of tutorials to remedy this situation. This series will cover exactly the same basic idea of using Django to build a blogging engine, but will expand on what the original series did in many ways. We will cover such additional topics as:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using Twitter Bootstrap to make your blog look good without too much hassle\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using Virtualenv to sandbox your blog application\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using South to effectively manage changes to your database structure\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Writing some simple unit tests\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Deploying the finished application to Heroku\")), mdx(\"p\", null, \"Ready? Let's get started!\"), mdx(\"h2\", null, \"Getting everything set up\"), mdx(\"p\", null, \"Now, first of all, I'm going to assume you're using some variant of Unix, such as Linux or Mac OS X. I'm not saying you can't follow this tutorial with Windows, but you'll have a harder time, because Windows just isn't as developer-friendly as Unix in general. A modern Linux distro like Ubuntu is generally pretty easy to use, and you can easily run it in Virtualbox, so if you use Windows I would recommend you use that to make things easier.\"), mdx(\"p\", null, \"You should also have at least a basic grasp of the command line, such as how to create and navigate directories. You don't have to be a wizard with it, though.\"), mdx(\"p\", null, \"You also need a proper programmer's text editor. I use Vim, but I freely admit that Vim has a very steep learning curve and you may have trouble picking it up at the same time as following this tutorial. Emacs is also a very powerful text editor, and if you like it, feel free to use it. If you haven't yet found a programmer's text editor you like, I suggest you check out \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://www.sublimetext.com/\"\n  }, \"Sublime Text\"), \", which is easy to get started with, but also very powerful, and can be used without purchasing a license. Don't worry too much about your text editor - it's not vitally import that you use what I use, just find one that works for you. That said, I will say one thing - DON'T use an IDE. IDE's hide too many details from new users and make it harder to figure out what's going on.\"), mdx(\"p\", null, \"You will also need to ensure you have the following installed:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Python. I recommend installing Python 2.7, because you may have issues with Python 2.6, and Python 3 isn't universally supported yet so you might have some issues with that\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Virtualenv\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Pip\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Git\")), mdx(\"p\", null, \"On most Linux distros, you can find packages for all of these items easily enough using your package manager. On Mac OS X, I recommend using Homebrew to install them, though if you have another package manager installed you can use that too. If you have issues with installing any of these, a quick Google search should be sufficient to resolve the issue.\"), mdx(\"h2\", null, \"Beginning work\"), mdx(\"p\", null, \"With all that done, we're ready to get started. Create a folder in a suitable place on your file system and switch into it. I generally keep a dedicated folder in my home directory called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Projects\"), \" to use for all of my projects, and give each project a folder within it - in this case the project is called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"django_tutorial_blog_ng\"), \".\"), mdx(\"p\", null, \"Now, we'll use Git to keep track of our source code. If you prefer Mercurial, feel free to use that, but this tutorial will assume use of Git, so you'll want to adapt the commands used accordingly. Start tracking your project with the following command from the shell, when you're in the project directory:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ git init\\n\")), mdx(\"p\", null, \"If you haven't used Git before, you'll also want to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://git-scm.com/book/en/Getting-Started-First-Time-Git-Setup\"\n  }, \"configure it\"), \".\"), mdx(\"p\", null, \"Next, we set up our virtualenv. Run the following command:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ virtualenv venv --distribute\\n\")), mdx(\"p\", null, \"Followed by:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ source venv/bin/activate\\n\")), mdx(\"p\", null, \"Every time you come back to work on this project, you'll need to run the previous command to make sure you're running the version of Python installed under venv/ rather than your system Python. You can tell it's using this because your shell prompt will be prefixed with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(venv)\"), \".\"), mdx(\"p\", null, \"Why do this? Well, it means you can install whatever version of a Python module you like, without having root access, and means the Python install you're using will only have those modules you explicitly install, rather than all of those ones available with your operating system. For instance, you could have multiple projects using different versions of Django, rather than having to update a global installation of Django and potentially break existing applications.\"), mdx(\"p\", null, \"Now that our virtualenv is set up, we'll install Django, as well as several other useful Python modules. Run the following command:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ pip install django-toolbelt South\\n\")), mdx(\"p\", null, \"A little explanation is called for here. The package \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"django-toolbelt\"), \" includes a number of packages we'll be using, including Django, as well as Gunicorn (a simple web server we'll use when the time comes to deploy the app to Heroku). South is a migration tool that is commonly used with Django - basically, if you make changes to existing models, Django doesn't natively have the capacity to apply those changes (yet - native migrations are planned at some point in the future), so South can be used to apply those changes for you without having to either manually change the database structure or dump the database and rebuild it.\"), mdx(\"p\", null, \"Please note that one of the packages, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"psycopg2\"), \", may fail if you don't have PostgreSQL installed, but don't worry about installing it. We'll be using SQLite for developing the application locally, and we'll be deploying the finished product to Heroku, which does have it installed.\"), mdx(\"p\", null, \"Once the installation is complete, run the following command to record the new modules installed:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ pip freeze > requirements.txt\\n\")), mdx(\"p\", null, \"The file \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"requirements.txt\"), \" will be created, which stores the packages and versions you have installed so that they can be easily recreated. If you had issues installing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"psycopg2\"), \", then here's what your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"requirements.txt\"), \" should look like - feel free to edit it manually to look like this, as when we deploy it to Heroku, it will need to be correct to ensure that our application can be deployed successfully:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"Django==1.6.1\\nSouth==0.8.4\\ndj-database-url==0.2.2\\ndj-static==0.0.5\\ndjango-toolbelt==0.0.1\\ngunicorn==18.0\\npsycopg2==2.5.1\\nstatic==0.4\\nwsgiref==0.1.2\\n\")), mdx(\"p\", null, \"Next, we'll commit these changes with Git:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ git add requirements.txt\\n$ git commit -m 'Committed requirements'\\n\")), mdx(\"p\", null, \"Next we'll add a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".gitignore\"), \" file to ignore our virtualenv - we want to keep this out of version control because it's something specific to that install. We have all we need to recreate it so we don't want to store it. In addition, we also want to ignore any compiled Python files (identifiable by the .pyc suffix):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"venv/\\n*.pyc\\n\")), mdx(\"p\", null, \"Let's commit that too:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ git add .gitignore\\n$ git commit -m 'Added a gitignore file'\\n\")), mdx(\"p\", null, \"Now, let's generate our project's basic skeleton:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ django-admin.py startproject django_tutorial_blog_ng .\\n\")), mdx(\"p\", null, \"This application skeleton includes a basic configuration which will be sufficient for now, but you will also want to add the SQLite database file to your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".gitignore\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"env/\\n*.pyc\\ndb.sqlite3\\n\")), mdx(\"p\", null, \"Let's commit what we've done:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ git add .gitignore django_tutorial_blog_ng/ manage.py\\n$ git commit -m 'Created project skeleton'\\n\")), mdx(\"p\", null, \"Now, before we create our database, we need to ensure we are using South. Go into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"django_tutorial_blog_ng/settings.py\"), \" and find \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INSTALLED_APPS\"), \". Edit it to look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"INSTALLED_APPS = (\\n    'django.contrib.admin',\\n    'django.contrib.auth',\\n    'django.contrib.contenttypes',\\n    'django.contrib.sessions',\\n    'django.contrib.messages',\\n    'django.contrib.staticfiles',\\n    'south',\\n)\\n\")), mdx(\"p\", null, \"Now, you can create your database. Run the following command:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ python manage.py syncdb\\n\")), mdx(\"p\", null, \"You'll be prompted to create a superuser - go ahead and fill in the details. Now, run the following command:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ python manage.py runserver\\n\")), mdx(\"p\", null, \"This will run Django's built-in web server on port 8000, and if you click \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://127.0.0.1:8000\"\n  }, \"here\"), \", you should see a page congratulating you on your first Django-powered page. Once you're finished with it, you can stop the web server with \", mdx(\"kbd\", null, \"Ctrl-C\"), \".\"), mdx(\"p\", null, \"Don't forget to commit your changes:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ git add django_tutorial_blog_ng/settings.py\\n$ git commit -m 'Added South to installed apps'\\n\")), mdx(\"h2\", null, \"Your first app\"), mdx(\"p\", null, \"Django distinguishes between the concepts of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"projects\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"apps\"), \". A project is a specific project that may consist of one or more apps, such as a web app, whereas an app is a set of functionality within a project. For instance, one website might include some flat pages, an admin interface, and a blogging engine, and these could easily be different apps. By encouraging you to separate different types of functionality into different apps, Django makes it easier for you to reuse existing content elsewhere.\"), mdx(\"p\", null, \"We're going to create our first app, which is the blogging engine. Run the following command to create a basic skeleton for this app:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ python manage.py startapp blogengine\\n\")), mdx(\"p\", null, \"Next, we need to amend our settings to install this app:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"INSTALLED_APPS = (\\n    'django.contrib.admin',\\n    'django.contrib.auth',\\n    'django.contrib.contenttypes',\\n    'django.contrib.sessions',\\n    'django.contrib.messages',\\n    'django.contrib.staticfiles',\\n    'south',\\n    'blogengine',\\n)\\n\")), mdx(\"p\", null, \"Now, before we can use this app, we want to let South know about it so that changes to your database structure will be managed right from the start by South. Run the following command to create your initial migration:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ python manage.py schemamigration --initial blogengine\\n\")), mdx(\"p\", null, \"That creates the file for your first migration,but doesn't run it. To migrate your database structure to the latest version, run the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ python manage.py migrate\\n\")), mdx(\"p\", null, \"This won't actually make any changes, but it will ensure that all future changes to your models for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blogengine\"), \" app are handled by South. Let's commit our app skeleton:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ git add django_tutorial_blog_ng/settings.py blogengine/\\n$ git commit -m 'Added blogengine app skeleton'\\n\")), mdx(\"p\", null, \"So, we now have our first app set up, but it doesn't do anything much.\"), mdx(\"p\", null, \"Remember that I mentioned how Django differentiates between projects and apps? Well, Django actually ships with a number of useful apps, and one of those is the admin interface. I consider the Django admin to be one of the framework's killer features because it's easy to use and customise, and saves you a lot of grief.\"), mdx(\"p\", null, \"In the past, the admin interface needed a little work to get it working, but in Django 1.6 it's configured to work out of the box, so if you click \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://127.0.0.1:8000/admin/\"\n  }, \"here\"), \", you should see the login screen for it. You should be able to sign in using the username and password you set when you ran \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"syncdb\"), \".\"), mdx(\"p\", null, \"Next, we'll set up our first model.\"), mdx(\"h2\", null, \"An introduction to MVC\"), mdx(\"p\", null, \"MVC is a common pattern used in web development. Many web development frameworks can be loosely described as MVC, including Django, Rails, CodeIgniter, Laravel and Symfony, as well as some client-side frameworks like Backbone.js. The basic concept is that a web app is divided into three basic components:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Models\"), \" - the data managed with the application\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Views\"), \" - the presentation of the data\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Controllers\"), \" - an intermediary between the models and the views\")), mdx(\"p\", null, \"Now, Django's interpretation of MVC is slightly different to many other frameworks. While in most frameworks the views are HTML templates for rendering the data, in Django this role is taken by the templates, and the views are functions or objects that render data from the models using a template. Effectively, you can think of Django's views as being like controllers in other frameworks, and Django templates as being views.\"), mdx(\"p\", null, \"In Django, you create your models as Python classes that represent your data, and you use the Django ORM to query the database. As a result, it's rare to have to directly query your database using SQL, making it more portable between different databases.\"), mdx(\"p\", null, \"Now, our first model is going to be of a blog post. At least initially, each post will have the following attributes:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A title\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A publication date and time\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Some text\")), mdx(\"p\", null, \"Now, we could just jump straight into creating our first model, but we're going to make a point of following the practices of test-driven development here. The basic concept of TDD is that you write a failing test before writing any code, then you write the code to pass that test afterwards. It does make things a bit slower, but it's all too easy to neglect writing tests at all if you leave it till later.\"), mdx(\"p\", null, \"If you take a look in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blogengine\"), \" folder you'll notice there's a file called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tests.py\"), \". Open it up and you should see the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from django.test import TestCase\\n\\n# Create your tests here.\\n\")), mdx(\"p\", null, \"It's worth taking a little time to plan out what we want to test from our post model. Each post object will have the attributes I mentioned above, and what we want to be able to do is test that we can:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Set the title\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Set the publication date and time\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Set the text\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Save it successfully\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Retrieve it successfully\")), mdx(\"p\", null, \"So, let's create a test for our post model. We'll go through the relevant sections of the test bit by bit:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from django.test import TestCase\\nfrom django.utils import timezone\\nfrom blogengine.models import Post\\n\\n\")), mdx(\"p\", null, \"Here we're importing the required functionality. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TestCase\"), \" is provided by Django, and is an object all of your tests should inherit from. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timezone\"), \" is a utility for handling dates and times correctly. Finally, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Post\"), \" is our model, which we have yet to implement.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"# Create your tests here.\\nclass PostTest(TestCase):\\n    def test_create_post(self):\\n        # Create the post\\n        post = Post()\\n\")), mdx(\"p\", null, \"Here we create the PostTest class, which represents a test for your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Post\"), \" model. So far it only has one method, but you can add additional ones if required.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"\\n        # Set the attributes\\n        post.title = 'My first post'\\n        post.text = 'This is my first blog post'\\n        post.pub_date = timezone.now()\\n\")), mdx(\"p\", null, \"Here we set the post's attributes.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"\\n        # Save it\\n        post.save()\\n\")), mdx(\"p\", null, \"Now we save it. At this point it has been added to the database, and the rest of the test involves us ensuring it has been saved correctly and can be retrieved.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"\\n        # Check we can find it\\n        all_posts = Post.objects.all()\\n        self.assertEquals(len(all_posts), 1)\\n        only_post = all_posts[0]\\n        self.assertEquals(only_post, post)\\n\")), mdx(\"p\", null, \"Here we use the Django database API to fetch all of the Post objects, assert that there is only 1 post object, retrieve that post object, and assert that it is the same object as the post object we just saved.\"), mdx(\"p\", null, \"If unit testing is new to you, assertions may be new to you. Essentially you're saying to the Python interpreter, \\\"I assert that X is true, so please raise an error if this is not true\\\". Here we assert that the length of the variable \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"all_posts\"), \" is 1, and that that post is the same object as the previously saved object, so that the test will fail if that is not the case.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"\\n        # Check attributes\\n        self.assertEquals(only_post.title, 'My first post')\\n        self.assertEquals(only_post.text, 'This is my first blog post')\\n        self.assertEquals(only_post.pub_date.day, post.pub_date.day)\\n        self.assertEquals(only_post.pub_date.month, post.pub_date.month)\\n        self.assertEquals(only_post.pub_date.year, post.pub_date.year)\\n        self.assertEquals(only_post.pub_date.hour, post.pub_date.hour)\\n        self.assertEquals(only_post.pub_date.minute, post.pub_date.minute)\\n        self.assertEquals(only_post.pub_date.second, post.pub_date.second)\\n\")), mdx(\"p\", null, \"Finally, we assert that the values of each of the post's attributes as stored in the database match up with those in the post object we set. For the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"title\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"text\"), \" fields, these are easy to validate as we can just check the values against those we set. For the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pub_date\"), \" field, things are a bit more complex, since this will be an object in its own right, so you need to check the day, month, year, hour, minute and second attributes separately.\"), mdx(\"p\", null, \"The whole thing should look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from django.test import TestCase\\nfrom django.utils import timezone\\nfrom blogengine.models import Post\\n\\n# Create your tests here.\\nclass PostTest(TestCase):\\n    def test_create_post(self):\\n        # Create the post\\n        post = Post()\\n\\n        # Set the attributes\\n        post.title = 'My first post'\\n        post.text = 'This is my first blog post'\\n        post.pub_date = timezone.now()\\n\\n        # Save it\\n        post.save()\\n\\n        # Check we can find it\\n        all_posts = Post.objects.all()\\n        self.assertEquals(len(all_posts), 1)\\n        only_post = all_posts[0]\\n        self.assertEquals(only_post, post)\\n\\n        # Check attributes\\n        self.assertEquals(only_post.title, 'My first post')\\n        self.assertEquals(only_post.text, 'This is my first blog post')\\n        self.assertEquals(only_post.pub_date.day, post.pub_date.day)\\n        self.assertEquals(only_post.pub_date.month, post.pub_date.month)\\n        self.assertEquals(only_post.pub_date.year, post.pub_date.year)\\n        self.assertEquals(only_post.pub_date.hour, post.pub_date.hour)\\n        self.assertEquals(only_post.pub_date.minute, post.pub_date.minute)\\n        self.assertEquals(only_post.pub_date.second, post.pub_date.second)\\n\")), mdx(\"p\", null, \"With that in place, the time has come to run our test with the following command:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ python manage.py test\\n\")), mdx(\"p\", null, \"You should see something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"(venv)Smith:django_tutorial_blog_ng matthewdaly$ python manage.py test\\nCreating test database for alias 'default'...\\nE\\n======================================================================\\nERROR: blogengine.tests (unittest.loader.ModuleImportFailure)\\n----------------------------------------------------------------------\\nImportError: Failed to import test module: blogengine.tests\\nTraceback (most recent call last):\\n  File \\\"/usr/local/Cellar/python/2.7.6/Frameworks/Python.framework/Versions/2.7/lib/python2.7/unittest/loader.py\\\", line 254, in _find_tests\\n    module = self._get_module_from_name(name)\\n  File \\\"/usr/local/Cellar/python/2.7.6/Frameworks/Python.framework/Versions/2.7/lib/python2.7/unittest/loader.py\\\", line 232, in _get_module_from_name\\n    __import__(name)\\n  File \\\"/Users/matthewdaly/Projects/django_tutorial_blog_ng/blogengine/tests.py\\\", line 3, in <module>\\n    from blogengine.models import Post\\nImportError: cannot import name Post\\n\\n\\n----------------------------------------------------------------------\\nRan 1 test in 0.000s\\n\\nFAILED (errors=1)\\nDestroying test database for alias 'default'...\\n\")), mdx(\"p\", null, \"Don't worry about the error - this is exactly what we expect to see because we haven't implemented our Post model yet. Now that we have a failing test in place, we can implement our model to make the test pass. Open up \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blogengine/models.py\"), \" and enter the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from django.db import models\\n\\n# Create your models here.\\nclass Post(models.Model):\\n    title = models.CharField(max_length=200)\\n    pub_date = models.DateTimeField()\\n    text = models.TextField()\\n\")), mdx(\"p\", null, \"Save the file and run the test again:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"(venv)Smith:django_tutorial_blog_ng matthewdaly$ python manage.py test\\nCreating test database for alias 'default'...\\nE\\n======================================================================\\nERROR: test_create_post (blogengine.tests.PostTest)\\n----------------------------------------------------------------------\\nTraceback (most recent call last):\\n  File \\\"/Users/matthewdaly/Projects/django_tutorial_blog_ng/blogengine/tests.py\\\", line 17, in test_create_post\\n    post.save()\\n  File \\\"/Users/matthewdaly/Projects/django_tutorial_blog_ng/venv/lib/python2.7/site-packages/django/db/models/base.py\\\", line 545, in save\\n    force_update=force_update, update_fields=update_fields)\\n  File \\\"/Users/matthewdaly/Projects/django_tutorial_blog_ng/venv/lib/python2.7/site-packages/django/db/models/base.py\\\", line 573, in save_base\\n    updated = self._save_table(raw, cls, force_insert, force_update, using, update_fields)\\n  File \\\"/Users/matthewdaly/Projects/django_tutorial_blog_ng/venv/lib/python2.7/site-packages/django/db/models/base.py\\\", line 654, in _save_table\\n    result = self._do_insert(cls._base_manager, using, fields, update_pk, raw)\\n  File \\\"/Users/matthewdaly/Projects/django_tutorial_blog_ng/venv/lib/python2.7/site-packages/django/db/models/base.py\\\", line 687, in _do_insert\\n    using=using, raw=raw)\\n  File \\\"/Users/matthewdaly/Projects/django_tutorial_blog_ng/venv/lib/python2.7/site-packages/django/db/models/manager.py\\\", line 232, in _insert\\n    return insert_query(self.model, objs, fields, **kwargs)\\n  File \\\"/Users/matthewdaly/Projects/django_tutorial_blog_ng/venv/lib/python2.7/site-packages/django/db/models/query.py\\\", line 1511, in insert_query\\n    return query.get_compiler(using=using).execute_sql(return_id)\\n  File \\\"/Users/matthewdaly/Projects/django_tutorial_blog_ng/venv/lib/python2.7/site-packages/django/db/models/sql/compiler.py\\\", line 898, in execute_sql\\n    cursor.execute(sql, params)\\n  File \\\"/Users/matthewdaly/Projects/django_tutorial_blog_ng/venv/lib/python2.7/site-packages/django/db/backends/util.py\\\", line 53, in execute\\n    return self.cursor.execute(sql, params)\\n  File \\\"/Users/matthewdaly/Projects/django_tutorial_blog_ng/venv/lib/python2.7/site-packages/django/db/utils.py\\\", line 99, in __exit__\\n    six.reraise(dj_exc_type, dj_exc_value, traceback)\\n  File \\\"/Users/matthewdaly/Projects/django_tutorial_blog_ng/venv/lib/python2.7/site-packages/django/db/backends/util.py\\\", line 53, in execute\\n    return self.cursor.execute(sql, params)\\n  File \\\"/Users/matthewdaly/Projects/django_tutorial_blog_ng/venv/lib/python2.7/site-packages/django/db/backends/sqlite3/base.py\\\", line 450, in execute\\n    return Database.Cursor.execute(self, query, params)\\nOperationalError: no such table: blogengine_post\\n\\n----------------------------------------------------------------------\\nRan 1 test in 0.059s\\n\\nFAILED (errors=1)\\nDestroying test database for alias 'default'...\\n\")), mdx(\"p\", null, \"Our test still fails, but if we take a look at this error message, we can see why - there is no database table for the posts (called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blogengine_post\"), \"). Using South, we can easily remedy that by creating a new migration to create this table:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ python manage.py schemamigration --auto blogengine\\n\")), mdx(\"p\", null, \"That creates the new migration. Now let's run it:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ python manage.py migrate\\n\")), mdx(\"p\", null, \"Now, let's run our tests to check it's working as expected:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"(venv)Smith:django_tutorial_blog_ng matthewdaly$ python manage.py test\\nCreating test database for alias 'default'...\\n.\\n----------------------------------------------------------------------\\nRan 1 test in 0.001s\\n\\nOK\\nDestroying test database for alias 'default'...\\n\")), mdx(\"p\", null, \"Success! We now have a model in place that passes our test. Let's commit our changes:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ git add blogengine/\\n$ git commit -m 'Added post model with passing test'\\n\")), mdx(\"p\", null, \"Now, Django's ORM is basically a layer on top of SQL that abstracts away differences between different relational databases, but the underlying queries are still being run. You can view the SQL created to generate the table by using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sqlall\"), \" command. Just run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"python manage.py sqlall blogengine\"), \" and you should see something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"BEGIN;\\nCREATE TABLE \\\"blogengine_post\\\" (\\n    \\\"id\\\" integer NOT NULL PRIMARY KEY,\\n    \\\"title\\\" varchar(200) NOT NULL,\\n    \\\"pub_date\\\" datetime NOT NULL,\\n    \\\"text\\\" text NOT NULL\\n)\\n;\\n\\nCOMMIT;\\n\")), mdx(\"p\", null, \"Note the addition of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" field as the primary key. If you're at all familiar with relational databases, you'll know that every table must have one field, called a primary key, that is a unique reference to that row. This can be overridden, but here it's exactly the behaviour we want.\"), mdx(\"h2\", null, \"Creating blog posts via the admin\"), mdx(\"p\", null, \"Now, we need a way to be able to create, edit and delete blog posts. Django's admin interface allows us to do so easily. However, before we do so, we want to create automated acceptance tests for this functionality, in order to test the ability to create posts from an end-user's perspective. While unit tests are for testing sections of an application's functionality from the perspective of other sections of the application, acceptance tests are testing from the user's perspective. In other words, they test what the application needs to do to be acceptable.\"), mdx(\"p\", null, \"First, we will test logging into the admin. Open up \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blogengine/tests.py\"), \" and amend it as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from django.test import TestCase, LiveServerTestCase, Client\\nfrom django.utils import timezone\\nfrom blogengine.models import Post\\n\\n# Create your tests here.\\nclass PostTest(TestCase):\\n    def test_create_post(self):\\n        # Create the post\\n        post = Post()\\n\\n        # Set the attributes\\n        post.title = 'My first post'\\n        post.text = 'This is my first blog post'\\n        post.pub_date = timezone.now()\\n\\n        # Save it\\n        post.save()\\n\\n        # Check we can find it\\n        all_posts = Post.objects.all()\\n        self.assertEquals(len(all_posts), 1)\\n        only_post = all_posts[0]\\n        self.assertEquals(only_post, post)\\n\\n        # Check attributes\\n        self.assertEquals(only_post.title, 'My first post')\\n        self.assertEquals(only_post.text, 'This is my first blog post')\\n        self.assertEquals(only_post.pub_date.day, post.pub_date.day)\\n        self.assertEquals(only_post.pub_date.month, post.pub_date.month)\\n        self.assertEquals(only_post.pub_date.year, post.pub_date.year)\\n        self.assertEquals(only_post.pub_date.hour, post.pub_date.hour)\\n        self.assertEquals(only_post.pub_date.minute, post.pub_date.minute)\\n        self.assertEquals(only_post.pub_date.second, post.pub_date.second)\\n\\nclass AdminTest(LiveServerTestCase):\\n    def test_login(self):\\n        # Create client\\n        c = Client()\\n\\n        # Get login page\\n        response = c.get('/admin/')\\n\\n        # Check response code\\n        self.assertEquals(response.status_code, 200)\\n\")), mdx(\"p\", null, \"First of all, we import two new objects from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"django.test\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LiveServerTestCase\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Client\"), \". Then we create the first part of our first test for the admin, named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AdminTest\"), \". Eventually, this will test that we can log successfully into the admin interface. For now, we're just doing the following:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Creating a Client object\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Fetching the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"/admin/\"), \" route\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Asserting that the status code for this HTTP request is 200, (in other words, that the page was fetched successfully).\")), mdx(\"p\", null, \"If you run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"python manage.py test\"), \", you should see that both tests pass successfully. Now we'll extend \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AdminTest\"), \" - we'll verify that the response contains the string 'Log in', which in the Django admin interface, appears on the login page:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class AdminTest(LiveServerTestCase):\\n    def test_login(self):\\n        # Create client\\n        c = Client()\\n\\n        # Get login page\\n        response = c.get('/admin/')\\n\\n        # Check response code\\n        self.assertEquals(response.status_code, 200)\\n\\n        # Check 'Log in' in response\\n        self.assertTrue('Log in' in response.content)\\n\")), mdx(\"p\", null, \"Here \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"response.content\"), \" is a string containing the content of the HTTP response - we're asserting that the substring 'Log in' appears in there. If you run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"python manage.py test\"), \" again, it should pass.\"), mdx(\"p\", null, \"Now, we need to actually log in. This could be fiddly, but Django has a handy convenience method to log you in when testing:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class AdminTest(LiveServerTestCase):\\n    def test_login(self):\\n        # Create client\\n        c = Client()\\n\\n        # Get login page\\n        response = c.get('/admin/')\\n\\n        # Check response code\\n        self.assertEquals(response.status_code, 200)\\n\\n        # Check 'Log in' in response\\n        self.assertTrue('Log in' in response.content)\\n\\n        #\\xA0Log the user in\\n        c.login(username='bobsmith', password=\\\"password\\\")\\n\\n        # Check response code\\n        response = c.get('/admin/')\\n        self.assertEquals(response.status_code, 200)\\n\\n        #\\xA0Check 'Log out' in response\\n        self.assertTrue('Log out' in response.content)\\n\")), mdx(\"p\", null, \"Here, we use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"login\"), \" method of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Client\"), \" object to log into the admin interface, and then we fetch the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/admin/\"), \" route again. We assert that we get a 200 status code, and we assert that the response contains the string 'Log out' - in other words, that we are logged in.\"), mdx(\"p\", null, \"Try running \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"python manage.py test\"), \" and we'll get an error., because the user details we've used to log in don't exist. Let's resolve that.\"), mdx(\"p\", null, \"Now, you could put your own credentials in there, but that's not a good idea because it's a security risk. Instead, we'll create a fixture for the test user that will be loaded when the tests are run. Run the following command:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ python manage.py createsuperuser\\n\")), mdx(\"p\", null, \"Give the username as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bobsmith\"), \", the email address as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bob@example.com\"), \", and the password as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"password\"), \". Once that's done, run these commands to dump the existing users to a fixture:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ mkdir blogengine/fixtures\\n$ python manage.py dumpdata auth.User --indent=2 > blogengine/fixtures/users.json\\n\")), mdx(\"p\", null, \"This will dump all of the existing users to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blogengine/fixtures/users.json\"), \". You may wish to edit this file to remove your own superuser account and leave only the newly created one in there.\"), mdx(\"p\", null, \"Next we need to amend our test to load this fixture:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class AdminTest(LiveServerTestCase):\\n    fixtures = ['users.json']\\n\\n    def test_login(self):\\n        # Create client\\n        c = Client()\\n\\n        # Get login page\\n        response = c.get('/admin/')\\n\\n        # Check response code\\n        self.assertEquals(response.status_code, 200)\\n\\n        # Check 'Log in' in response\\n        self.assertTrue('Log in' in response.content)\\n\\n        # Log the user in\\n        c.login(username='bobsmith', password=\\\"password\\\")\\n\\n        # Check response code\\n        response = c.get('/admin/')\\n        self.assertEquals(response.status_code, 200)\\n\\n        # Check 'Log out' in response\\n        self.assertTrue('Log out' in response.content)\\n\")), mdx(\"p\", null, \"Now, if you run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"python manage.py test\"), \", you should find that the test passes. Next, we'll test that we can log out:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class AdminTest(LiveServerTestCase):\\n    fixtures = ['users.json']\\n\\n    def test_login(self):\\n        # Create client\\n        c = Client()\\n\\n        # Get login page\\n        response = c.get('/admin/')\\n\\n        # Check response code\\n        self.assertEquals(response.status_code, 200)\\n\\n        # Check 'Log in' in response\\n        self.assertTrue('Log in' in response.content)\\n\\n        # Log the user in\\n        c.login(username='bobsmith', password=\\\"password\\\")\\n\\n        # Check response code\\n        response = c.get('/admin/')\\n        self.assertEquals(response.status_code, 200)\\n\\n        # Check 'Log out' in response\\n        self.assertTrue('Log out' in response.content)\\n\\n    def test_logout(self):\\n        # Create client\\n        c = Client()\\n\\n        # Log in\\n        c.login(username='bobsmith', password=\\\"password\\\")\\n\\n        # Check response code\\n        response = c.get('/admin/')\\n        self.assertEquals(response.status_code, 200)\\n\\n        # Check 'Log out' in response\\n        self.assertTrue('Log out' in response.content)\\n\\n        # Log out\\n        c.logout()\\n\\n        # Check response code\\n        response = c.get('/admin/')\\n        self.assertEquals(response.status_code, 200)\\n\\n        # Check 'Log in' in response\\n        self.assertTrue('Log in' in response.content)\\n\")), mdx(\"p\", null, \"This test works along very similar lines. We log in, verify that 'Log out' is in the response, then we log out, and verify that 'Log in' is in the response. Run the tests again, and they should pass. Assuming they do, let's commit our changes again:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ git add blogengine/\\n$ git commit -m 'Added tests for admin auth'\\n\")), mdx(\"p\", null, \"This code is a little repetitive. We create the client twice, when we could do so only once. Amend the AdminTest class as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class AdminTest(LiveServerTestCase):\\n    fixtures = ['users.json']\\n\\n    def setUp(self):\\n        self.client = Client()\\n\\n    def test_login(self):\\n        # Get login page\\n        response = self.client.get('/admin/')\\n\\n        # Check response code\\n        self.assertEquals(response.status_code, 200)\\n\\n        # Check 'Log in' in response\\n        self.assertTrue('Log in' in response.content)\\n\\n        # Log the user in\\n        self.client.login(username='bobsmith', password=\\\"password\\\")\\n\\n        # Check response code\\n        response = self.client.get('/admin/')\\n        self.assertEquals(response.status_code, 200)\\n\\n        # Check 'Log out' in response\\n        self.assertTrue('Log out' in response.content)\\n\\n    def test_logout(self):\\n        # Log in\\n        self.client.login(username='bobsmith', password=\\\"password\\\")\\n\\n        # Check response code\\n        response = self.client.get('/admin/')\\n        self.assertEquals(response.status_code, 200)\\n\\n        # Check 'Log out' in response\\n        self.assertTrue('Log out' in response.content)\\n\\n        # Log out\\n        self.client.logout()\\n\\n        # Check response code\\n        response = self.client.get('/admin/')\\n        self.assertEquals(response.status_code, 200)\\n\\n        # Check 'Log in' in response\\n        self.assertTrue('Log in' in response.content)\\n\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setUp()\"), \" method is automatically run when the test runs, and ensures we only need to start up the client once. Run your tests to make sure they pass, then commit your changes:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ git add blogengine/\\n$ git commit -m 'Refactored admin test'\\n\")), mdx(\"p\", null, \"Now, we'll implement a test for creating a new post. The admin interface implements URLs for creating new instances of a model in a consistent format of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/admin/app_name/model_name/add/\"), \", so the URL for adding a new post will be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/admin/blogengine/post/add/\"), \".\"), mdx(\"p\", null, \"Add this method to the AdminTest class:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"    def test_create_post(self):\\n        # Log in\\n        self.client.login(username='bobsmith', password=\\\"password\\\")\\n\\n        #\\xA0Check response code\\n        response = self.client.get('/admin/blogengine/post/add/')\\n        self.assertEquals(response.status_code, 200)\\n\")), mdx(\"p\", null, \"Try running it and this will fail, because we haven't registered the Post model in the Django admin. So we need to do that. To do so, open a new file at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blogengine/admin.py\"), \" and add the following code:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"import models\\nfrom django.contrib import admin\\n\\nadmin.site.register(models.Post)\\n\")), mdx(\"p\", null, \"Now, run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"python manage.py test\"), \" and the test should pass. If you want to confirm that the post model appears in the admin, run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"python manage.py runserver\"), \" and click \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://127.0.0.1:8000/admin/\"\n  }, \"here\"), \".\"), mdx(\"p\", null, \"So now we can reach the page for adding a post, but we haven't yet tested that we can submit one. Let's remedy that:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"    def test_create_post(self):\\n        # Log in\\n        self.client.login(username='bobsmith', password=\\\"password\\\")\\n\\n        #\\xA0Check response code\\n        response = self.client.get('/admin/blogengine/post/add/')\\n        self.assertEquals(response.status_code, 200)\\n\\n        # Create the new post\\n        response = self.client.post('/admin/blogengine/post/add/', {\\n            'title': 'My first post',\\n            'text': 'This is my first post',\\n            'pub_date_0': '2013-12-28',\\n            'pub_date_1': '22:00:04'\\n        },\\n        follow=True\\n        )\\n        self.assertEquals(response.status_code, 200)\\n\\n        # Check added successfully\\n        self.assertTrue('added successfully' in response.content)\\n\\n        # Check new post now in database\\n        all_posts = Post.objects.all()\\n        self.assertEquals(len(all_posts), 1)\\n\")), mdx(\"p\", null, \"Here we submit the new post via HTTP POST, with all the data passed through. This mirrors the form created by the Django admin interface - if you take a look at the HTML generated by the admin, you'll see that the inputs are given names that match these. Note that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pub_date\"), \" field, because it represents a datetime object, is split up into a separate date and time field. Also note the parameter \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"follow=True\"), \" - this denotes that the test client should follow any HTTP redirect.\"), mdx(\"p\", null, \"We confirm that the POST request responded with a 200 code, denoting success. We also confirm that the response included the phrase 'added successfully'. Finally we confirm that there is now a single Post object in the database. Don't worry about any existing content - Django creates a dedicated test database and destroys it after the tests are done, so you can be sure that no posts are present unless you explicitly load them from a fixture.\"), mdx(\"p\", null, \"We can now test creating a post, but we also need to ensure we can test editing and deleting them. First we'll add a test for editing posts:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"    def test_edit_post(self):\\n        # Create the post\\n        post = Post()\\n        post.title = 'My first post'\\n        post.text = 'This is my first blog post'\\n        post.pub_date = timezone.now()\\n        post.save()\\n\\n        # Log in\\n        self.client.login(username='bobsmith', password=\\\"password\\\")\\n\\n        # Edit the post\\n        response = self.client.post('/admin/blogengine/post/1/', {\\n            'title': 'My second post',\\n            'text': 'This is my second blog post',\\n            'pub_date_0': '2013-12-28',\\n            'pub_date_1': '22:00:04'\\n        },\\n        follow=True\\n        )\\n        self.assertEquals(response.status_code, 200)\\n\\n        # Check changed successfully\\n        self.assertTrue('changed successfully' in response.content)\\n\\n        # Check post amended\\n        all_posts = Post.objects.all()\\n        self.assertEquals(len(all_posts), 1)\\n        only_post = all_posts[0]\\n        self.assertEquals(only_post.title, 'My second post')\\n        self.assertEquals(only_post.text, 'This is my second blog post')\\n\")), mdx(\"p\", null, \"Here we create a new blog post, then verify we can edit it by resubmitting it with different values, and checking that we get the expected response, and that the data in the database has been updated. Run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"python manage.py test\"), \", and this should pass.\"), mdx(\"p\", null, \"Finally, we'll set up a test for deleting posts:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"    def test_delete_post(self):\\n        # Create the post\\n        post = Post()\\n        post.title = 'My first post'\\n        post.text = 'This is my first blog post'\\n        post.pub_date = timezone.now()\\n        post.save()\\n\\n        # Check new post saved\\n        all_posts = Post.objects.all()\\n        self.assertEquals(len(all_posts), 1)\\n\\n        # Log in\\n        self.client.login(username='bobsmith', password=\\\"password\\\")\\n\\n        # Delete the post\\n        response = self.client.post('/admin/blogengine/post/1/delete/', {\\n            'post': 'yes'\\n        }, follow=True)\\n        self.assertEquals(response.status_code, 200)\\n\\n        # Check deleted successfully\\n        self.assertTrue('deleted successfully' in response.content)\\n\\n        # Check post amended\\n        all_posts = Post.objects.all()\\n        self.assertEquals(len(all_posts), 0)\\n\")), mdx(\"p\", null, \"Again, this is pretty similar to what we did before. We create a new post, verify that it is the sole post in the database, and log into the admin. Then we delete the post via the admin, and confirm that the admin interface confirmed it has been deleted, and the post is gone from the database.\"), mdx(\"p\", null, \"I think it's now time to commit again:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ git add blogengine/\\n$ git commit -m 'Post admin tests in place'\\n\")), mdx(\"p\", null, \"So we now know that we can create, edit and delete posts, and we have tests in place to confirm this. So our next task is to be able to display our posts.\"), mdx(\"p\", null, \"For now, to keep things simple, we're only going to implement the index view - in other words, all the posts in reverse chronological order. We'll use Django's generic views to keep things really easy.\"), mdx(\"p\", null, \"Django's generic views are another really handy feature. As mentioned earlier, a view is a function or class that describes how a specific route should render an object. Now, there are many tasks that recur in web development. For instance, many web pages you may have seen may be a list of objects - in this case, the index page for a blog is a list of blog posts. For that reason, Django has the ListView generic view, which makes it easy to render a list of objects.\"), mdx(\"p\", null, \"Now, like before, we want to have a test in place. Open up \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blogengine/tests.py\"), \" and add the following class at the end of the file:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class PostViewTest(LiveServerTestCase):\\n    def setUp(self):\\n        self.client = Client()\\n\\n    def test_index(self):\\n        # Create the post\\n        post = Post()\\n        post.title = 'My first post'\\n        post.text = 'This is my first blog post'\\n        post.pub_date = timezone.now()\\n        post.save()\\n\\n        # Check new post saved\\n        all_posts = Post.objects.all()\\n        self.assertEquals(len(all_posts), 1)\\n\\n        # Fetch the index\\n        response = self.client.get('/')\\n        self.assertEquals(response.status_code, 200)\\n\\n        # Check the post title is in the response\\n        self.assertTrue(post.title in response.content)\\n\\n        # Check the post text is in the response\\n        self.assertTrue(post.text in response.content)\\n\\n        # Check the post date is in the response\\n        self.assertTrue(str(post.pub_date.year) in response.content)\\n        self.assertTrue(post.pub_date.strftime('%b') in response.content)\\n        self.assertTrue(str(post.pub_date.day) in response.content)\\n\")), mdx(\"p\", null, \"Here we create the post, and assert that it is the sole post object. We then fetch the index page, and assert that the HTTP status code is 200 (ie. the page exists and is returned). We then verify that the response contains the post title, text and publication date.\"), mdx(\"p\", null, \"Note that for the month, we need to do a bit of jiggery-pokery to get the month name. By default Django will return short month names (eg Jan, Feb etc), but Python stores months as numbers, so we need to format it as a short month name using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"%b\"), \".\"), mdx(\"p\", null, \"If you run this, you will get an error because the index route isn't implemented. So let's fix that. Open up the existing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"django_tutorial_blog_ng/urls.py\"), \" file and amend it to look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from django.conf.urls import patterns, include, url\\n\\nfrom django.contrib import admin\\nadmin.autodiscover()\\n\\nurlpatterns = patterns('',\\n    # Examples:\\n    # url(r'^$', 'django_tutorial_blog_ng.views.home', name='home'),\\n    # url(r'^blog/', include('blog.urls')),\\n\\n    url(r'^admin/', include(admin.site.urls)),\\n\\n    # Blog URLs\\n    url(r'^.*$', include('blogengine.urls')),\\n)\\n\")), mdx(\"p\", null, \"Then, create a new file at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blogengine/urls.py\"), \" and edit it as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from django.conf.urls import patterns, url\\nfrom django.views.generic import ListView\\nfrom blogengine.models import Post\\n\\nurlpatterns = patterns('',\\n    # Index\\n    url('^$', ListView.as_view(\\n        model=Post,\\n        )),\\n)\\n\")), mdx(\"p\", null, \"A little explanation is called for. The project has its own \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"urls.py\"), \" file that handles routing throughout the project. However, because Django encourages you to make your apps reusable, we want to keep the routes in the individual apps as far as possible. So, in the project file, we include the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blogengine/urls.py\"), \" file.\"), mdx(\"p\", null, \"In the app-specific \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"urls.py\"), \", we import the Post model and the ListView generic view. We then define a route for the index page - the regular expression \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"^$\"), \" will match only an empty string, so that page will be the index. For this route, we then call the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"as_view()\"), \" method of the ListView object, and set the model as Post.\"), mdx(\"p\", null, \"Now, if you either run the tests, or run the development server and visit \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://127.0.0.1:8000\"\n  }, \"the index page\"), \", you'll see that it isn't working yet - you should see the error \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TemplateDoesNotExist: blogengine/post_list.html\"), \". This tells us that we need to create a template called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blogengine/post_list.html\"), \", so let's do that. First of all, add the following at the end of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"django_tutorial_blog_ng/settings.py\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"\\n# Template directory\\nTEMPLATE_DIRS = [os.path.join(BASE_DIR, 'templates')]\\n\")), mdx(\"p\", null, \"Next, create the folders for the templates, and a blank \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"post_list.html\"), \" file:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ mkdir templates\\n$ mkdir templates/blogengine\\n$ touch templates/blogengine/post_list.html\\n\")), mdx(\"p\", null, \"Now, run your tests again, and you'll see that the template now exists, but a new error is showing up:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"Creating test database for alias 'default'...\\n......F\\n======================================================================\\nFAIL: test_index (blogengine.tests.PostViewTest)\\n----------------------------------------------------------------------\\nTraceback (most recent call last):\\n  File \\\"/Users/matthewdaly/Projects/django_tutorial_blog_ng/blogengine/tests.py\\\", line 189, in test_index\\n    self.assertTrue(post.title in response.content)\\nAssertionError: False is not true\\n\\n----------------------------------------------------------------------\\nRan 7 tests in 2.162s\\n\\nFAILED (failures=1)\\nDestroying test database for alias 'default'...\\n\")), mdx(\"p\", null, \"To fix this, we make sure the template shows the data we want. Open up \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"templates/blogengine/post_list.html\"), \" and enter the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-django\"\n  }, \"<html>\\n    <head>\\n        <title>My Django Blog</title>\\n    </head>\\n    <body>\\n        {% for post in object_list %}\\n        <h1>{{ post.title }}</h1>\\n        <h3>{{ post.pub_date }}</h3>\\n        {{ post.text }}\\n        {% endfor %}\\n    </body>\\n</html>\\n\")), mdx(\"p\", null, \"This is only a very basic template, and we'll expand upon it in future.\"), mdx(\"p\", null, \"With that done, you can run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"python manage.py test\"), \", and it should pass. Well done! Don't forget to commit your changes:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ git add django_tutorial_blog_ng/ templates/ blogengine/\\n$ git commit -m 'Implemented list view for posts'\\n\")), mdx(\"p\", null, \"And that's all for this lesson! We've done a hell of a lot in this lesson - set up our project, created a comprehensive test suite for it, and implemented the basic functionality. Next time we'll make it a bit prettier using Twitter Bootstrap, as well as implementing more of the basic functionality for the blog.\"), mdx(\"p\", null, \"You can find the source code \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/matthewbdaly/django_tutorial_blog_ng\"\n  }, \"on Github\"), \". For your convenience, I've tagged this lesson as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"lesson-1\"), \", so you can just clone the repository and switch to the end of this lesson with the following commands:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ git clone https://github.com/matthewbdaly/django_tutorial_blog_ng.git\\n$ cd django_tutorial_blog_ng\\n$ git checkout lesson-1\\n\")), mdx(\"p\", null, \"That way, you can easily check that what you've done matches up with the repository. Future lessons will be similarly tagged to make them easy to navigate.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"My series of Django tutorials for building a blogging engine are by far the most popular posts I've ever written on here. I've had a lot of people contact me with questions or just…","frontmatter":{"title":"Django blog tutorial - the next generation - part 1","date":"28th December 2013 3:00 pm","isoDate":"2013-12-28T15:00:32+00:00","categories":["python","django","tdd","django-blog-tutorial"]},"fields":{"path":"/blog/2013/12/28/django-blog-tutorial-the-next-generation-part-1/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2013/08/16/a-starting-boilerplate-for-php-development-with-vagrant/"},"frontmatter":{"title":"A starting boilerplate for PHP development with Vagrant","date":"2013-08-16 21:49","layout":"post"}},"next":{"fields":{"path":"/blog/2014/01/02/django-blog-tutorial-the-next-generation-part-2/"},"frontmatter":{"title":"Django blog tutorial - the next generation - part 2","date":"2014-01-02 11:28:48 +0000","layout":"post"}}}},"staticQueryHashes":["290055352","2909664151"]}