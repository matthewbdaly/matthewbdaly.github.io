{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2019/09/07/setting-private-properties-in-tests/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"6a7d06d7-9d9b-5cab-ae87-3ee9764c55d9","body":"var _excluded = [\"components\"];\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Setting private properties in tests\",\n  \"date\": \"2019-09-07 20:16:47 +0100\",\n  \"layout\": \"post\",\n  \"categories\": [\"php\", \"tdd\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Sometimes when writing a test, you come across a situation where you need to set a private field that's not accessible through any existing route. For instance, I've been working with Doctrine a bit lately, and since the ID on an entity is generated automatically, it should not be possible to change it via a setter, but at the same time, we sometimes have the need to set it in a test.\"), mdx(\"p\", null, \"Fortunately, there is a way to do that. Using PHP's reflection API, you can temporarily mark a property on an object as accessible, so as to be able to set it without either passing it to the constructor or creating a setter method that will only ever be used by the test. We first create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ReflectionClass\"), \" instance from the object, then get the property. We mark it as accessible, and then set the value on the instance, as shown below:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php declare(strict_types = 1);\\n\\nnamespace Tests\\\\Unit;\\n\\nuse Tests\\\\TestCase;\\nuse Project\\\\Document;\\nuse ReflectionClass;\\n\\nfinal class DocumentTest extends TestCase\\n{\\n    public function testGetId()\\n    {\\n        $doc = new Document();\\n        $reflect = new ReflectionClass($doc);\\n        $id = $reflect->getProperty('id');\\n        $id->setAccessible(true);\\n        $id->setValue($doc, 1);\\n        $this->assertEquals(1, $doc->getId());\\n    }\\n}\\n\")), mdx(\"p\", null, \"If you're likely to need this in more than one place, you may want to pull this functionality out into a trait for reuse:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php declare(strict_types = 1);\\n\\nnamespace Tests\\\\Traits;\\n\\nuse ReflectionClass;\\n\\ntrait SetsPrivateProperties\\n{\\n    /**\\n     * Sets a private property\\n     *\\n     * @param mixed $object\\n     * @param string $property\\n     * @param mixed $value\\n     * @return void\\n     */\\n    public function setPrivateProperty($object, string $property, $value)\\n    {\\n        $reflect = new ReflectionClass($object);\\n        $prop = $reflect->getProperty($property);\\n        $prop->setAccessible(true);\\n        $prop->setValue($object, $value);\\n        $prop->setAccessible(false);\\n    }\\n}\\n\")), mdx(\"p\", null, \"Then your test can be simplified as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php declare(strict_types = 1);\\n\\nnamespace Tests\\\\Unit;\\n\\nuse Tests\\\\TestCase;\\nuse Project\\\\Document;\\nuse Tests\\\\Traits\\\\SetsPrivateProperties;\\n\\nfinal class DocumentTest extends TestCase\\n{\\n    use SetsPrivateProperties;\\n\\n    public function testGetId()\\n    {\\n        $doc = new Document();\\n        $this->setPrivateProperty($doc, 'id', 1);\\n        $this->assertEquals(1, $doc->getId());\\n    }\\n}\\n\")), mdx(\"p\", null, \"While this is a slightly contrived and limited example, and this situation is quite rare, I've found it to be a useful technique under certain circumstances.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Sometimes when writing a test, you come across a situation where you need to set a private field that's not accessible through any existing route. For instance, I've been workingâ€¦","frontmatter":{"title":"Setting private properties in tests","date":"7th September 2019 7:16 pm","isoDate":"2019-09-07T19:16:47+00:00","categories":["php","tdd"]},"fields":{"path":"/blog/2019/09/07/setting-private-properties-in-tests/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2019/07/28/skipping-environment-specific-phpunit-tests/"},"frontmatter":{"title":"Skipping environment specific PHPUnit tests","date":"2019-07-28 20:55:14 +0100","layout":"post"}},"next":{"fields":{"path":"/blog/2019/09/21/using-mix-versioning-outside-laravel/"},"frontmatter":{"title":"Using Mix versioning outside Laravel","date":"2019-09-21 11:30:50 +0100","layout":"post"}}}},"staticQueryHashes":["1776624730","3528622268"]}