{
    "componentChunkName": "component---src-templates-post-tsx",
    "path": "/blog/2019/02/02/creating-your-own-dependency-injection-container-in-php/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"09031318-473a-5780-88de-de6abb2fa2cc","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Creating your own dependency injection container in PHP\",\n  \"layout\": \"post\",\n  \"date\": \"2019-02-02 21:45:52 +0100\",\n  \"categories\": [\"php\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Dependency injection can be a difficult concept to understand in the early stages. Even when you're using it all the time, it can often seem like magic. However, it's really not all that complicated once you actually get into the nuts and bolts of it, and building your own container is a good way to learn more about how it works and how to use it.\"), mdx(\"p\", null, \"In this tutorial, I'll walk you through creating a simple, minimal dependency injection container, using PHPSpec as part of a TDD workflow. While the end result isn't necessarily something I'd be happy using in a production environment, it's sufficient to understand the basic concept and make it feel less like a black box. Our container will be called Ernie (if you want to know why, it's a reference to a 90's era video game that had a character based on Eric Cantona called Ernie Container).\"), mdx(\"p\", null, \"The first thing we need to do is set up our dependencies. Our container will implement PSR-11, so we need to include the interface that defines that. We'll also use PHP CodeSniffer to ensure code quality, and PHPSpec for testing. Your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"composer.json\"), \" should look something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"{\\n    \\\"name\\\": \\\"matthewbdaly/ernie\\\",\\n    \\\"description\\\": \\\"Simple DI container\\\",\\n    \\\"type\\\": \\\"library\\\",\\n    \\\"require-dev\\\": {\\n        \\\"squizlabs/php_codesniffer\\\": \\\"^3.3\\\",\\n        \\\"phpspec/phpspec\\\": \\\"^5.0\\\",\\n        \\\"psr/container\\\": \\\"^1.0\\\"\\n    },\\n    \\\"license\\\": \\\"MIT\\\",\\n    \\\"authors\\\": [\\n        {\\n            \\\"name\\\": \\\"Matthew Daly\\\",\\n            \\\"email\\\": \\\"450801+matthewbdaly@users.noreply.github.com\\\"\\n        }\\n    ],\\n    \\\"require\\\": {},\\n    \\\"autoload\\\": {\\n        \\\"psr-4\\\": {\\n            \\\"Matthewbdaly\\\\\\\\Ernie\\\\\\\\\\\": \\\"src/\\\"\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"We also need to put this in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"phpspec.yml\"), \" file:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yml\"\n  }, \"suites:\\n    test_suite:\\n        namespace: Matthewbdaly\\\\Ernie\\n        psr4_prefix: Matthewbdaly\\\\Ernie\\n\")), mdx(\"p\", null, \"With that done, we can start working on our implementation.\"), mdx(\"h2\", null, \"Creating the exceptions\"), mdx(\"p\", null, \"The PSR-11 specification defines two interfaces for exceptions, which we will implement before actually moving on to the container itself. The first of these is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Psr\\\\Container\\\\ContainerExceptionInterface\"), \". Run the following command to create a basic spec for the exception:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec desc Matthewbdaly/Ernie/Exceptions/ContainerException\\n\")), mdx(\"p\", null, \"The generated specification for it at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spec/Exceptions/ContainerExceptionSpec.php\"), \" will look something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace spec\\\\Matthewbdaly\\\\Ernie;\\n\\nuse Matthewbdaly\\\\Ernie\\\\ContainerException;\\nuse PhpSpec\\\\ObjectBehavior;\\nuse Prophecy\\\\Argument;\\n\\nclass ContainerExceptionSpec extends ObjectBehavior\\n{\\n    function it_is_initializable()\\n    {\\n        $this->shouldHaveType(ContainerException::class);\\n    }\\n}\\n\")), mdx(\"p\", null, \"This is not sufficient for our needs. Our exception must also implement two interfaces:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Throwable\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Psr\\\\Container\\\\ContainerExceptionInterface\"))), mdx(\"p\", null, \"The former can be resolved by inheriting from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Exception\"), \", while the latter doesn't require any additional methods. Let's expand our spec to check for these:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace spec\\\\Matthewbdaly\\\\Ernie\\\\Exceptions;\\n\\nuse Matthewbdaly\\\\Ernie\\\\Exceptions\\\\ContainerException;\\nuse PhpSpec\\\\ObjectBehavior;\\nuse Prophecy\\\\Argument;\\n\\nclass ContainerExceptionSpec extends ObjectBehavior\\n{\\n    function it_is_initializable()\\n    {\\n        $this->shouldHaveType(ContainerException::class);\\n    }\\n\\n    function it_implements_interface()\\n    {\\n        $this->shouldImplement('Psr\\\\Container\\\\ContainerExceptionInterface');\\n    }\\n\\n    function it_implements_throwable()\\n    {\\n        $this->shouldImplement('Throwable');\\n    }\\n}\\n\")), mdx(\"p\", null, \"Now run the spec and PHPSpec will generate the boilerplate exception for you:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec run\\nMatthewbdaly/Ernie/Exceptions/ContainerException\\n  11  - it is initializable\\n      class Matthewbdaly\\\\Ernie\\\\Exceptions\\\\ContainerException does not exist.\\n\\nMatthewbdaly/Ernie/Exceptions/ContainerException\\n  16  - it implements interface\\n      class Matthewbdaly\\\\Ernie\\\\Exceptions\\\\ContainerException does not exist.\\n\\nMatthewbdaly/Ernie/Exceptions/ContainerException\\n  21  - it implements throwable\\n      class Matthewbdaly\\\\Ernie\\\\Exceptions\\\\ContainerException does not exist.\\n\\n                                      100%                                       3\\n1 specs\\n3 examples (3 broken)\\n23ms\\n\\n\\n  Do you want me to create `Matthewbdaly\\\\Ernie\\\\Exceptions\\\\ContainerException`\\n  for you?\\n                                                                         [Y/n]\\ny\\nClass Matthewbdaly\\\\Ernie\\\\Exceptions\\\\ContainerException created in /home/matthew/Projects/ernie-clone/src/Exceptions/ContainerException.php.\\n\\nMatthewbdaly/Ernie/Exceptions/ContainerException\\n  16  - it implements interface\\n      expected an instance of Psr\\\\Container\\\\ContainerExceptionInterface, but got\\n      [obj:Matthewbdaly\\\\Ernie\\\\Exceptions\\\\ContainerException].\\n\\nMatthewbdaly/Ernie/Exceptions/ContainerException\\n  21  - it implements throwable\\n      expected an instance of Throwable, but got\\n      [obj:Matthewbdaly\\\\Ernie\\\\Exceptions\\\\ContainerException].\\n\\n            33%                                     66%                          3\\n1 specs\\n3 examples (1 passed, 2 failed)\\n36ms\\n\")), mdx(\"p\", null, \"It's failing, but we expect that. We need to update our exception to extend the base PHP exception, and implement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Psr\\\\Container\\\\ContainerExceptionInterface\"), \". Let's do that now:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace Matthewbdaly\\\\Ernie\\\\Exceptions;\\n\\nuse Psr\\\\Container\\\\ContainerExceptionInterface;\\nuse Exception;\\n\\nclass ContainerException extends Exception implements ContainerExceptionInterface\\n{\\n}\\n\")), mdx(\"p\", null, \"Let's re-run the spec:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec run\\n                                      100%                                       3\\n1 specs\\n3 examples (3 passed)\\n24ms\\n\")), mdx(\"p\", null, \"The second exception we need to implement is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Psr\\\\Container\\\\NotFoundExceptionInterface\"), \" and it's a similar story. Run the following command to create the spec:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec desc Matthewbdaly/Ernie/Exceptions/NotFoundException\\n\")), mdx(\"p\", null, \"Again, the spec needs to be amended to verify that it's a throwable and implements the required interface:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace spec\\\\Matthewbdaly\\\\Ernie\\\\Exceptions;\\n\\nuse Matthewbdaly\\\\Ernie\\\\Exceptions\\\\NotFoundException;\\nuse PhpSpec\\\\ObjectBehavior;\\nuse Prophecy\\\\Argument;\\n\\nclass NotFoundExceptionSpec extends ObjectBehavior\\n{\\n    function it_is_initializable()\\n    {\\n        $this->shouldHaveType(NotFoundException::class);\\n    }\\n\\n    function it_implements_interface()\\n    {\\n        $this->shouldImplement('Psr\\\\Container\\\\NotFoundExceptionInterface');\\n    }\\n\\n    function it_implements_throwable()\\n    {\\n        $this->shouldImplement('Throwable');\\n    }\\n}\\n\")), mdx(\"p\", null, \"For the sake of brevity I've left out the output, but if you run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"vendor/bin/phpspec run\"), \" you'll see it fail due to the fact that the generated class doesn't implement the required interfaces. Amend \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src/Exceptions/NotFoundException\"), \" as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace Matthewbdaly\\\\Ernie\\\\Exceptions;\\n\\nuse Psr\\\\Container\\\\NotFoundExceptionInterface;\\nuse Exception;\\n\\nclass NotFoundException extends Exception implements NotFoundExceptionInterface\\n{\\n}\\n\")), mdx(\"p\", null, \"Running \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"vendor/bin/phpspec run\"), \" should now see it pass. Now let's move on to the container class...\"), mdx(\"h2\", null, \"Building the container\"), mdx(\"p\", null, \"Run the following command to create the container spec:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec desc Matthewbdaly/Ernie/Container\\n\")), mdx(\"p\", null, \"However, the default generated spec isn't sufficient. We need to check it implements the required interface:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace spec\\\\Matthewbdaly\\\\Ernie;\\n\\nuse Matthewbdaly\\\\Ernie\\\\Container;\\nuse PhpSpec\\\\ObjectBehavior;\\nuse Prophecy\\\\Argument;\\n\\nclass ContainerSpec extends ObjectBehavior\\n{\\n    function it_is_initializable()\\n    {\\n        $this->shouldHaveType(Container::class);\\n    }\\n\\n    function it_implements_interface()\\n    {\\n        $this->shouldImplement('Psr\\\\Container\\\\ContainerInterface');\\n    }\\n}\\n\")), mdx(\"p\", null, \"Now, if we run PHPSpec, we'll generate our class:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec run\\nMatthewbdaly/Ernie/Container\\n  11  - it is initializable\\n      class Matthewbdaly\\\\Ernie\\\\Container does not exist.\\n\\nMatthewbdaly/Ernie/Container\\n  16  - it implements interface\\n      class Matthewbdaly\\\\Ernie\\\\Container does not exist.\\n\\n                            75%                                     25%          8\\n3 specs\\n8 examples (6 passed, 2 broken)\\n404ms\\n\\n\\n  Do you want me to create `Matthewbdaly\\\\Ernie\\\\Container` for you?\\n                                                                         [Y/n]\\ny\\nClass Matthewbdaly\\\\Ernie\\\\Container created in /home/matthew/Projects/ernie-clone/src/Container.php.\\n\\nMatthewbdaly/Ernie/Container\\n  16  - it implements interface\\n      expected an instance of Psr\\\\Container\\\\ContainerInterface, but got\\n      [obj:Matthewbdaly\\\\Ernie\\\\Container].\\n\\n                                 87%                                     12%     8\\n3 specs\\n8 examples (7 passed, 1 failed)\\n40ms\\n\")), mdx(\"p\", null, \"Now, as we can see, this class doesn't implement the interface. Let's remedy that:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace Matthewbdaly\\\\Ernie;\\n\\nuse Psr\\\\Container\\\\ContainerInterface;\\n\\nclass Container implements ContainerInterface\\n{\\n}\\n\")), mdx(\"p\", null, \"Now, if we run the tests, they should fail because the class needs to add the required methods:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec run\\n\\u2718 Fatal error happened while executing the following\\n    it is initializable\\n    Class Matthewbdaly\\\\Ernie\\\\Container contains 2 abstract methods and must therefore be declared abstract or implement the remaining methods (Psr\\\\Container\\\\ContainerInterface::get, Psr\\\\Container\\\\ContainerInterface::has) in /home/matthew/Projects/ernie-clone/src/Container.php on line 7\\n\")), mdx(\"p\", null, \"If you use an editor or IDE that allows you to implement an interface automatically, you can run it to add the required methods. I use PHPActor with Neovim, and used the option in the Transform menu to implement the contract:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace Matthewbdaly\\\\Ernie;\\n\\nuse Psr\\\\Container\\\\ContainerInterface;\\n\\nclass Container implements ContainerInterface\\n{\\n    /**\\n     * {@inheritDoc}\\n     */\\n    public function get($id)\\n    {\\n    }\\n\\n    /**\\n     * {@inheritDoc}\\n     */\\n    public function has($id)\\n    {\\n    }\\n}\\n\")), mdx(\"p\", null, \"Running \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"vendor/bin/phpspec run\"), \" should now make the spec pass, but the methods don't actually do anything yet. If you read the spec for PSR-11, you'll see that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"has()\"), \" returns a boolean to indicate whether a class can be instantiated or not, while \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get()\"), \" will either return an instance of the specified class, or throw an exception. We will add specs that check that built-in classes can be returned by both, and unknown classes display the expected behaviour. We'll do both at once, because in both cases, the functionality to actually resolve the required class will be deferred to a single resolver method, and these methods will not do all that much as a result:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    function it_has_simple_classes()\\n    {\\n        $this->has('DateTime')->shouldReturn(true);\\n    }\\n\\n    function it_does_not_have_unknown_classes()\\n    {\\n        $this->has('UnknownClass')->shouldReturn(false);\\n    }\\n\\n    function it_can_get_simple_classes()\\n    {\\n        $this->get('DateTime')->shouldReturnAnInstanceOf('DateTime');\\n    }\\n\\n    function it_returns_not_found_exception_if_class_cannot_be_found()\\n    {\\n        $this->shouldThrow('Matthewbdaly\\\\Ernie\\\\Exceptions\\\\NotFoundException')\\n            ->duringGet('UnknownClass');\\n    }\\n\")), mdx(\"p\", null, \"These tests verify that:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"has()\"), \" returns \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"true\"), \" when called with the always-present \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"DateTime\"), \" class\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"has()\"), \" returns \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"false\"), \" for the undefined \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"UnknownClass\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"get()\"), \" successfully instantiates an instance of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"DateTime\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"get()\"), \" throws an exception if you try to instantiate the undefined \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"UnknownClass\"))), mdx(\"p\", null, \"Running the specs will raise errors:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec run\\nMatthewbdaly/Ernie/Container\\n  21  - it has simple classes\\n      expected true, but got null.\\n\\nMatthewbdaly/Ernie/Container\\n  26  - it does not have unknown classes\\n      expected false, but got null.\\n\\nMatthewbdaly/Ernie/Container\\n  31  - it can get simple classes\\n      expected an instance of DateTime, but got null.\\n\\nMatthewbdaly/Ernie/Container\\n  36  - it returns not found exception if class cannot be found\\n      expected to get exception / throwable, none got.\\n\\n                         66%                                     33%             12\\n3 specs\\n12 examples (8 passed, 4 failed)\\n98ms\\n\")), mdx(\"p\", null, \"Let's populate these empty methods:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace Matthewbdaly\\\\Ernie;\\n\\nuse Psr\\\\Container\\\\ContainerInterface;\\nuse Matthewbdaly\\\\Ernie\\\\Exceptions\\\\NotFoundException;\\nuse ReflectionClass;\\nuse ReflectionException;\\n\\nclass Container implements ContainerInterface\\n{\\n    /**\\n     * {@inheritDoc}\\n     */\\n    public function get($id)\\n    {\\n        $item = $this->resolve($id);\\n        return $this->getInstance($item);\\n    }\\n\\n    /**\\n     * {@inheritDoc}\\n     */\\n    public function has($id)\\n    {\\n        try {\\n            $item = $this->resolve($id);\\n        } catch (NotFoundException $e) {\\n            return false;\\n        }\\n        return $item->isInstantiable();\\n    }\\n\\n    private function resolve($id)\\n    {\\n        try {\\n            return (new ReflectionClass($id));\\n        } catch (ReflectionException $e) {\\n            throw new NotFoundException($e->getMessage(), $e->getCode(), $e);\\n        }\\n    }\\n\\n    private function getInstance(ReflectionClass $item)\\n    {\\n        return $item->newInstance();\\n    }\\n}\\n\")), mdx(\"p\", null, \"As you can see, both the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"has()\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get()\"), \" methods need to resolve a string ID to an actual class, so that common functionality is stored in a private method called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resolve()\"), \". This uses the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://php.net/manual/en/book.reflection.php\"\n  }, \"PHP Reflection API\"), \" to resolve the class name to an actual class. We pass the string ID into a constructor of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ReflectionClass\"), \", and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resolve()\"), \" method will either return the created instance of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ReflectionClass\"), \", or throw an exception.\"), mdx(\"p\", null, \"For the uninitiated, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ReflectionClass\"), \" allows you to reflect on the object whose fully qualified class name is passed to the constructor, in order to interact with that class programmatically. The methods we will use include:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"isInstantiable\"), \" - confirms whether or not the class can be instantiated (for instance, traits and abstract classes can't)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"newInstance\"), \" - creates a new instance of the item in question, as long as it has no dependencies in the constructor\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"newInstanceArgs\"), \" - creates a new instance, using the arguments passed in\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"getConstructor\"), \" - allows you to get information about the constructor\")), mdx(\"p\", null, \"The Reflection API is pretty comprehensive, and I would recommend reading the documentation linked to above if you want to know more.\"), mdx(\"p\", null, \"For the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"has()\"), \" method, we check that the resolved class is instantiable, and return the result of that. For the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get()\"), \" method, we use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getInstance()\"), \" to instantiate the item and return that, throwing an exception if that fails.\"), mdx(\"h2\", null, \"Registering objects\"), mdx(\"p\", null, \"In its current state, the container doesn't allow you to set an item. To be useful, we need to be able to specify that an interface or string should be resolved to a given class, or for cases where we need to pass in scalar parameters, such as a database object, to specify how a concrete instance of that class should be instantiated. To that end, we'll create a new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"set()\"), \" public method that will allow a dependency to be set. Here are the revised specs including this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace spec\\\\Matthewbdaly\\\\Ernie;\\n\\nuse Matthewbdaly\\\\Ernie\\\\Container;\\nuse PhpSpec\\\\ObjectBehavior;\\nuse Prophecy\\\\Argument;\\nuse DateTime;\\n\\nclass ContainerSpec extends ObjectBehavior\\n{\\n    function it_is_initializable()\\n    {\\n        $this->shouldHaveType(Container::class);\\n    }\\n\\n    function it_implements_interface()\\n    {\\n        $this->shouldImplement('Psr\\\\Container\\\\ContainerInterface');\\n    }\\n\\n    function it_has_simple_classes()\\n    {\\n        $this->has('DateTime')->shouldReturn(true);\\n    }\\n\\n    function it_does_not_have_unknown_classes()\\n    {\\n        $this->has('UnknownClass')->shouldReturn(false);\\n    }\\n\\n    function it_can_get_simple_classes()\\n    {\\n        $this->get('DateTime')->shouldReturnAnInstanceOf('DateTime');\\n    }\\n\\n    function it_returns_not_found_exception_if_class_cannot_be_found()\\n    {\\n        $this->shouldThrow('Matthewbdaly\\\\Ernie\\\\Exceptions\\\\NotFoundException')\\n            ->duringGet('UnknownClass');\\n    }\\n\\n    function it_can_register_dependencies()\\n    {\\n        $toResolve = new class {\\n        };\\n        $this->set('Foo\\\\Bar', $toResolve)->shouldReturn($this);\\n    }\\n\\n    function it_can_resolve_registered_dependencies()\\n    {\\n        $toResolve = new class {\\n        };\\n        $this->set('Foo\\\\Bar', $toResolve);\\n        $this->get('Foo\\\\Bar')->shouldReturnAnInstanceOf($toResolve);\\n    }\\n\\n    function it_can_resolve_registered_invokable()\\n    {\\n        $toResolve = new class {\\n            public function __invoke() {\\n                return new DateTime;\\n            }\\n        };\\n        $this->set('Foo\\\\Bar', $toResolve);\\n        $this->get('Foo\\\\Bar')->shouldReturnAnInstanceOf('DateTime');\\n    }\\n\\n    function it_can_resolve_registered_callable()\\n    {\\n        $toResolve = function () {\\n            return new DateTime;\\n        };\\n        $this->set('Foo\\\\Bar', $toResolve);\\n        $this->get('Foo\\\\Bar')->shouldReturnAnInstanceOf('DateTime');\\n    }\\n\\n    function it_can_resolve_if_registered_dependencies_instantiable()\\n    {\\n        $toResolve = new class {\\n        };\\n        $this->set('Foo\\\\Bar', $toResolve);\\n        $this->has('Foo\\\\Bar')->shouldReturn(true);\\n    }\\n}\\n\")), mdx(\"p\", null, \"This needs to handle quite a few scenarios, so there are several tests we have in place. These verify that:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"set()\"), \" method returns an instance of the container class, to allow for method chaining\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When a dependency is set, calling \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"get()\"), \" returns an instance of that class\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When a concrete class that has the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"__invoke()\"), \" magic method set is passed to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"set()\"), \", it is invoked and the response returned.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When the value passed through is a callback, the callback is resolved and the response returned\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When a dependency is set, calling \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"has()\"), \" for it returns the right value\")), mdx(\"p\", null, \"Note that we use anonymous classes for testing - I've written about these before and they're very useful in this context because they allow us to create a simple class inline for testing purposes.\"), mdx(\"p\", null, \"Running the specs should result in us being prompted to generate the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"set()\"), \" method, and failing afterwards:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec run\\nMatthewbdaly/Ernie/Container\\n  42  - it can register dependencies\\n      method Matthewbdaly\\\\Ernie\\\\Container::set not found.\\n\\nMatthewbdaly/Ernie/Container\\n  49  - it can resolve registered dependencies\\n      method Matthewbdaly\\\\Ernie\\\\Container::set not found.\\n\\nMatthewbdaly/Ernie/Container\\n  57  - it can resolve registered invokable\\n      method Matthewbdaly\\\\Ernie\\\\Container::set not found.\\n\\nMatthewbdaly/Ernie/Container\\n  68  - it can resolve registered callable\\n      method Matthewbdaly\\\\Ernie\\\\Container::set not found.\\n\\nMatthewbdaly/Ernie/Container\\n  77  - it can resolve if registered dependencies instantiable\\n      method Matthewbdaly\\\\Ernie\\\\Container::set not found.\\n\\n                          70%                                     29%            17\\n3 specs\\n17 examples (12 passed, 5 broken)\\n316ms\\n\\n  Do you want me to create `Matthewbdaly\\\\Ernie\\\\Container::set()` for you?\\n                                                                         [Y/n]\\ny\\n  Method Matthewbdaly\\\\Ernie\\\\Container::set() has been created.\\n\\nMatthewbdaly/Ernie/Container\\n  42  - it can register dependencies\\n      expected [obj:Matthewbdaly\\\\Ernie\\\\Container], but got null.\\n\\nMatthewbdaly/Ernie/Container\\n  49  - it can resolve registered dependencies\\n      exception [exc:Matthewbdaly\\\\Ernie\\\\Exceptions\\\\NotFoundException(\\\"Class Foo\\\\Bar does not exist\\\")] has been thrown.\\n\\nMatthewbdaly/Ernie/Container\\n  57  - it can resolve registered invokable\\n      exception [exc:Matthewbdaly\\\\Ernie\\\\Exceptions\\\\NotFoundException(\\\"Class Foo\\\\Bar does not exist\\\")] has been thrown.\\n\\nMatthewbdaly/Ernie/Container\\n  68  - it can resolve registered callable\\n      exception [exc:Matthewbdaly\\\\Ernie\\\\Exceptions\\\\NotFoundException(\\\"Class Foo\\\\Bar does not exist\\\")] has been thrown.\\n\\nMatthewbdaly/Ernie/Container\\n  77  - it can resolve if registered dependencies instantiable\\n      expected true, but got false.\\n\\n                          70%                              11%        17%        17\\n3 specs\\n17 examples (12 passed, 2 failed, 3 broken)\\n90ms\\n\")), mdx(\"p\", null, \"First, we need to set up the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"set()\"), \" method properly, and define a property to contain the stored services:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    private $services = [];\\n\\n    public function set(string $key, $value)\\n    {\\n        $this->services[$key] = $value;\\n        return $this;\\n    }\\n\")), mdx(\"p\", null, \"This fixes the first spec, but the resolver needs to be amended to handle cases where the ID is set manually:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    private function resolve($id)\\n    {\\n        try {\\n            $name = $id;\\n            if (isset($this->services[$id])) {\\n                $name = $this->services[$id];\\n                if (is_callable($name)) {\\n                    return $name();\\n                }\\n            }\\n            return (new ReflectionClass($name));\\n        } catch (ReflectionException $e) {\\n            throw new NotFoundException($e->getMessage(), $e->getCode(), $e);\\n        }\\n    }\\n\")), mdx(\"p\", null, \"This will allow us to resolve classes set with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"set()\"), \". However, we also want to resolve any callables, such as callbacks or classes that implement the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__invoke()\"), \" magic method, which means that sometimes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resolve()\"), \" will return the result of the callable instead of an instance of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ReflectionClass\"), \". Under those circumstances we should return the item directly:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    public function get($id)\\n    {\\n        $item = $this->resolve($id);\\n        if (!($item instanceof ReflectionClass)) {\\n            return $item;\\n        }\\n        return $this->getInstance($item);\\n    }\\n\")), mdx(\"p\", null, \"Note that because the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__invoke()\"), \" method is automatically called in any concrete class specified in the second argument to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"set()\"), \", it's only possible to resolve classes that define an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__invoke()\"), \" method if they are passed in as string representations. The following PsySh session should make it clear what this means:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \">>> use Matthewbdaly\\\\Ernie\\\\Container;\\n>>> $c = new Container;\\n=> Matthewbdaly\\\\Ernie\\\\Container {#2307}\\n>>> class TestClass { public function __invoke() { return \\\"Called\\\"; }}\\n>>> $c->get('TestClass');\\n=> TestClass {#2319}\\n>>> $c->set('Foo\\\\Bar', 'TestClass');\\n=> Matthewbdaly\\\\Ernie\\\\Container {#2307}\\n>>> $c->get('Foo\\\\Bar');\\n=> TestClass {#2309}\\n>>> $c->set('Foo\\\\Bar', new TestClass);\\n=> Matthewbdaly\\\\Ernie\\\\Container {#2307}\\n>>> $c->get('Foo\\\\Bar');\\n=> \\\"Called\\\"\\n\")), mdx(\"p\", null, \"As you can see, if we pass in the fully qualified class name of a class that defines an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__invoke()\"), \" method, it can be resolved as expected. However, if we pass a concrete instance of it to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"set()\"), \", it will be called and will return the response from that. This may not be the behaviour you want for your own container.\"), mdx(\"p\", null, \"According to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/thephpleague/container/issues/113\"\n  }, \"this issue on the PHP League's Container implementation\"), \", it was also an issue for them, so seeing as this is just a toy example I'm not going to lose any sleep over it. Just something to be aware of if you use this post as the basis for writing your own container.\"), mdx(\"h2\", null, \"Resolving dependencies\"), mdx(\"p\", null, \"One thing is missing from our container. Right now it should be able to instantiate pretty much any class that has no dependencies, but these are quite firmly in the minority. To be useful, a container should be able to resolve all of the dependencies for a class automatically.\"), mdx(\"p\", null, \"Let's add a spec for that:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    function it_can_resolve_dependencies()\\n    {\\n        $toResolve = get_class(new class(new DateTime) {\\n            public $datetime;\\n            public function __construct(DateTime $datetime)\\n            {\\n                $this->datetime = $datetime;\\n            }\\n        });\\n        $this->set('Foo\\\\Bar', $toResolve);\\n        $this->get('Foo\\\\Bar')->shouldReturnAnInstanceOf($toResolve);\\n    }\\n\")), mdx(\"p\", null, \"Here we have to be a bit crafty. Anonymous classes are defined and instantiated at the same time, so we can't pass it in as an anonymous class in the test. Instead, we call the anonymous class and get its name, then set that as the second argument to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"set()\"), \". Then we can verify that the returned object is an instance of the same class.\"), mdx(\"p\", null, \"Running this throws an error:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"$ vendor/bin/phpspec run\\nMatthewbdaly/Ernie/Container\\n  86  - it can resolve dependencies\\n      exception [err:ArgumentCountError(\\\"Too few arguments to function class@anonymous::__construct(), 0 passed and exactly 1 expected\\\")] has been thrown.\\n\\n                                    94%                                          18\\n3 specs\\n18 examples (17 passed, 1 broken)\\n60ms\\n\")), mdx(\"p\", null, \"This is expected. Our test class accepts an instance of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DateTime\"), \" in the constructor as a mandatory dependency, so instantiating it fails. We need to update the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getInstance()\"), \" method so that it can handle pulling in any dependencies:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    private function getInstance(ReflectionClass $item)\\n    {\\n        $constructor = $item->getConstructor();\\n        if (is_null($constructor) || $constructor->getNumberOfRequiredParameters() == 0) {\\n            return $item->newInstance();\\n        }\\n        $params = [];\\n        foreach ($constructor->getParameters() as $param) {\\n            if ($type = $param->getType()) {\\n                $params[] = $this->get($type->getName());\\n            }\\n        }\\n        return $item->newInstanceArgs($params);\\n    }\\n\")), mdx(\"p\", null, \"Here, we use the Reflection API to get the constructor. If there's no constructor, or it has no required parameters, we just return a new instance of the reflected class as before.\"), mdx(\"p\", null, \"Otherwise, we loop through the required parameters. For each parameter, we get the string representation of the type specified for that parameter, and retrieve an instance of it from the container. Afterwards, we use those parameters to instantiate the object.\"), mdx(\"p\", null, \"Let's run the specs again:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ vendor/bin/phpspec run\\n                                      100%                                       18\\n3 specs\\n18 examples (18 passed)\\n51ms\\n\")), mdx(\"p\", null, \"Our container is now complete. We can:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Resolve simple classes out of the box\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Set arbitrary keys to resolve to particular classes, or the result of callables, so as to enable mapping interfaces to concrete implementations, or resolve classes that require specific non-object parameters, such as PDO\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Resolve complex classes with multiple dependencies\")), mdx(\"p\", null, \"Not too bad for just over 100 lines of PHP...\"), mdx(\"h2\", null, \"Final thoughts\"), mdx(\"p\", null, \"As I've said, this is a pretty minimal example of a dependency injection container, and I wouldn't advise using this in production when there are so many existing, mature solutions available. I have no idea how the performance would stack up against existing solutions, or whether there are any issues with it, and quite frankly that's besides the point - this is intended as a learning exercise to understand how dependency injection containers in general work, not as an actual useful piece of code for production. If you want an off-the-shelf container, I'd point you in the direction of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"league/container\"), \", which has served me well.\"), mdx(\"p\", null, \"You can find the code for this tutorial on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/matthewbdaly/ernie\"\n  }, \"GitHub\"), \", so if you have any problems, you should take a look there to see where the problem lies. Of course, if you go on to create your own kick-ass container based on this, do let me know!\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Dependency injection can be a difficult concept to understand in the early stages. Even when you're using it all the time, it can often seem like magic. However, it's really not…","frontmatter":{"title":"Creating your own dependency injection container in PHP","date":"2nd February 2019 8:45 pm","isoDate":"2019-02-02T20:45:52+00:00","categories":["php"]},"fields":{"path":"/blog/2019/02/02/creating-your-own-dependency-injection-container-in-php/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2019/01/27/understanding-query-objects/"},"frontmatter":{"title":"Understanding query objects","date":"2019-01-27 23:10:39 +0000","layout":"post"}},"next":{"fields":{"path":"/blog/2019/02/16/higher-order-components-in-react/"},"frontmatter":{"title":"Higher-order components in React","date":"2019-02-16 19:00:30 +0000","layout":"post"}}}},
    "staticQueryHashes": ["290055352","2909664151"]}