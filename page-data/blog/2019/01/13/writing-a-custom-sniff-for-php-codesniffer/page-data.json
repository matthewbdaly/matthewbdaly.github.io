{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2019/01/13/writing-a-custom-sniff-for-php-codesniffer/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"b06e3d24-bb92-5d7a-8e58-f71618a36720","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Writing a custom sniff for PHP CodeSniffer\",\n  \"date\": \"2019-01-13 18:50:45 +0000\",\n  \"layout\": \"post\",\n  \"categories\": [\"php\", \"codesniffer\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I've recently come around to the idea that \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://matthiasnoback.nl/2018/09/final-classes-by-default-why/\"\n  }, \"in PHP all classes should be final by default\"), \", and have started doing so as a matter of course. However, when you start doing something like this it's easy to miss a few files that haven't been updated, or forget to do it, so I wanted a way to detect PHP classes that are not set as either abstract or final, and if possible, set them as final automatically. I've mentioned before that I use PHP CodeSniffer extensively, and that has the capability to both find and resolve deviations from a coding style, so last night I started looking into the possibility of creating a coding standard for this. It took a little work to understand how to do this so I thought I'd use this sniff as a simple example.\"), mdx(\"p\", null, \"The first part is to set out the directory structure. There's a very specific layout you have to follow for PHP CodeSniffer:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The folder for the standard must have the name of the standard, and be in the source folder set by Composer (in this case, \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"src/AbstractOrFinalClassesOnly\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This folder must contain a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ruleset.xml\"), \" file defining the name and description of the standard, and any other required content.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Any defined sniffs must be in a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Sniffs\"), \" folder.\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ruleset.xml\"), \" file was fairly simple in this case, as this is a very simple standard:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-xml\"\n  }, \"<?xml version=\\\"1.0\\\"?>\\n<ruleset name=\\\"AbstractOrFinalClassesOnly\\\">\\n    <description>Checks all classes are marked as either abstract or final.</description>\\n</ruleset>\\n\")), mdx(\"p\", null, \"The sniff is intended to do the following:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Check all classes have either the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"final\"), \" keyword or the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"abstract\"), \" keyword set\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When running the fixer, make all classes without the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"abstract\"), \" keyword final\")), mdx(\"p\", null, \"First of all, our class must implement the interface \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PHP_CodeSniffer\\\\Sniffs\\\\Sniff\"), \", which requires the following methods:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    public function register(): array;\\n\\n    public function process(File $file, $position): void;\\n\")), mdx(\"p\", null, \"Note that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"File\"), \" here is an instance of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PHP_CodeSniffer\\\\Files\\\\File\"), \". The first method registers the code the sniff should operate on. Here we're only interested in classes, so we return an array containing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"T_CLASS\"), \". This is defined in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://secure.php.net/manual/en/tokens.php\"\n  }, \"list of parser tokens used by PHP\"), \", and represents classes and objects:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    public function register(): array\\n    {\\n        return [T_CLASS];\\n    }\\n\")), mdx(\"p\", null, \"For the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"process()\"), \" method, we receive two arguments, the file itself, and the position. We need to keep a record of the tokens we check for, so we do so in a private property:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    private $tokens = [\\n        T_ABSTRACT,\\n        T_FINAL,\\n    ];\\n\")), mdx(\"p\", null, \"Then, we need to find the error:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"        if (!$file->findPrevious($this->tokens, $position)) {\\n            $file->addFixableError(\\n                'All classes should be declared using either the \\\"abstract\\\" or \\\"final\\\" keyword',\\n                $position - 1,\\n                self::class\\n            );\\n        }\\n\")), mdx(\"p\", null, \"We use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$file\"), \" to get the token before \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"class\"), \", and pass the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$tokens\"), \" property as a list of acceptable values. If the preceding token is not either \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"abstract\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"final\"), \", we add a fixable error. The first argument is the string error message, the second is the location, and the third is the class of the sniff that has failed.\"), mdx(\"p\", null, \"That will catch the issue, but won't actually fix it. To do that, we need to get the fixer from the file object, and call its \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"addContent()\"), \" method to add the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"final\"), \" keyword. We amend \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"process()\"), \" to extract the fixer, add it as a property, and then call the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fix()\"), \" method when we come across a fixable error:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    public function process(File $file, $position): void\\n    {\\n        $this->fixer = $file->fixer;\\n        $this->position = $position;\\n\\n        if (!$file->findPrevious($this->tokens, $position)) {\\n            $file->addFixableError(\\n                'All classes should be declared using either the \\\"abstract\\\" or \\\"final\\\" keyword',\\n                $position - 1,\\n                self::class\\n            );\\n            $this->fix();\\n        }\\n    }\\n\")), mdx(\"p\", null, \"Then we define the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fix()\"), \" method:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"    private function fix(): void\\n    {\\n        $this->fixer->addContent($this->position - 1, 'final ');\\n    }\\n\")), mdx(\"p\", null, \"Here's the finished class:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php declare(strict_types=1);\\n\\nnamespace Matthewbdaly\\\\AbstractOrFinalClassesOnly\\\\Sniffs;\\n\\nuse PHP_CodeSniffer\\\\Sniffs\\\\Sniff;\\nuse PHP_CodeSniffer\\\\Files\\\\File;\\n\\n/**\\n * Sniff for catching classes not marked as abstract or final\\n */\\nfinal class AbstractOrFinalSniff implements Sniff\\n{\\n    private $tokens = [\\n        T_ABSTRACT,\\n        T_FINAL,\\n    ];\\n\\n    private $fixer;\\n\\n    private $position;\\n\\n    public function register(): array\\n    {\\n        return [T_CLASS];\\n    }\\n\\n    public function process(File $file, $position): void\\n    {\\n        $this->fixer = $file->fixer;\\n        $this->position = $position;\\n\\n        if (!$file->findPrevious($this->tokens, $position)) {\\n            $file->addFixableError(\\n                'All classes should be declared using either the \\\"abstract\\\" or \\\"final\\\" keyword',\\n                $position - 1,\\n                self::class\\n            );\\n            $this->fix();\\n        }\\n    }\\n\\n    private function fix(): void\\n    {\\n        $this->fixer->addContent($this->position - 1, 'final ');\\n    }\\n}\\n\")), mdx(\"p\", null, \"I've made the resulting standard \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/matthewbdaly/abstract-or-final-sniff\"\n  }, \"available via Github\"), \".\"), mdx(\"p\", null, \"This is a bit rough and ready and I'll probably refactor it a bit when I have time. In addition, it's not quite displaying the behaviour I want as it should, since ideally it should only be looking for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"abstract\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"final\"), \" keywords in classes that implement an interface. However, it's proven fairly easy to create this sniff, except for the fact I had to go rooting around various tutorials that weren't all that clear. Hopefully this example is a bit simpler and easier to follow.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"I've recently come around to the idea that  in PHP all classes should be final by default , and have started doing so as a matter of course. However, when you start doing somethingâ€¦","frontmatter":{"title":"Writing a custom sniff for PHP CodeSniffer","date":"13 January 2019","categories":["php","codesniffer"]},"fields":{"path":"/blog/2019/01/13/writing-a-custom-sniff-for-php-codesniffer/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2019/01/03/you-dont-need-that-module-package/"},"frontmatter":{"title":"You don't need that module package","date":"2019-01-03 23:55:49 +0000","layout":"post"}},"next":{"fields":{"path":"/blog/2019/01/27/understanding-query-objects/"},"frontmatter":{"title":"Understanding query objects","date":"2019-01-27 23:10:39 +0000","layout":"post"}}}},"staticQueryHashes":["290055352","2909664151"]}