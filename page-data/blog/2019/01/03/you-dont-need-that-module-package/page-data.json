{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2019/01/03/you-dont-need-that-module-package/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"be0845ef-7552-591c-8720-5972559fd6c0","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"You don't need that module package\",\n  \"date\": \"2019-01-03 23:55:49 +0000\",\n  \"layout\": \"post\",\n  \"categories\": [\"php\", \"composer\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Lately I've seen a number of Laravel packages being posted on places like Reddit that offer ways to make your project more modular by letting you break their classes out of the usual structure and place them in a separate folder called something like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"packages/\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"modules/\"), \". However, these packages are completely redundant, and it requires very little work to achieve the same thing with Composer alone. In addition, much of it is not specific to Laravel and can also be applied to any other framework that uses Composer.\"), mdx(\"p\", null, \"There are two main approaches I'm aware of - keeping it in a single project, and moving the modules to separate Composer packages.\"), mdx(\"h1\", null, \"Single project\"), mdx(\"p\", null, \"Suppose we have a brand new Laravel project with the namespace left as the default \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App\"), \". This is what the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"autoload\"), \" section of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"composer.json\"), \" file will look like:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"    \\\"autoload\\\": {\\n        \\\"psr-4\\\": {\\n            \\\"App\\\\\\\\\\\": \\\"app/\\\"\\n        },\\n        \\\"classmap\\\": [\\n            \\\"database/seeds\\\",\\n            \\\"database/factories\\\"\\n        ]\\n    },\\n\")), mdx(\"p\", null, \"Composer allows for numerous ways to autoload classes and you can add additional namespaces as you wish. Probably the best approach is to use PSR-4 autoloading, as in this example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"    \\\"autoload\\\": {\\n        \\\"psr-4\\\": {\\n            \\\"App\\\\\\\\\\\": \\\"app/\\\",\\n            \\\"Packages\\\\\\\\\\\": \\\"packages\\\"\\n        },\\n        \\\"classmap\\\": [\\n            \\\"database/seeds\\\",\\n            \\\"database/factories\\\"\\n        ]\\n    },\\n\")), mdx(\"p\", null, \"Now, if you put the model \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Post.php\"), \" in the folder, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"packages/Blog/Models/\"), \", then this will map to the namespace \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Packages\\\\Blog\\\\Models\\\\Post\"), \", and if you set the namespace to this in the file, and run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"composer dump-autoload\"), \", you should be able to import it from that namespace without trouble. As with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App\\\\\"), \" namespace, because it's using PSR-4 you're only specifying the top-level namespace and the folders and files underneath have to mirror the namespace, so for instance, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Packages\\\\Foo\\\\Bar\"), \" maps to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"packages/Foo/Bar.php\"), \". If for some reason PSR-4 autoloading doesn't map well to what you want to do, then there are other methods you can use - refer to the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://getcomposer.org/doc/04-schema.md#autoload\"\n  }, \"relevant section of the Composer documentation\"), \" for the other methods available.\"), mdx(\"p\", null, \"The controllers are the toughest part, because by default Laravel's routing works on the assumption that the controllers are all under the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App\\\\Http\\\\Controllers\"), \" namespace, so you can shorten the namespace used. There are two ways around this I'm aware of. One is to specify the full namespace when referencing each controller:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"Route::get('/', '\\\\App\\\\Modules\\\\Http\\\\Controllers\\\\FooController@index');\\n\")), mdx(\"p\", null, \"The other option is to update the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RouteServiceProvider.php\"), \"'s namespace property. It defaults to this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"protected $namespace = 'App\\\\Http\\\\Controllers';\\n\")), mdx(\"p\", null, \"If there's a more convenient namespace you want to place all your controllers under, then you can replace this, and it will become the default namespace applied in your route files.\"), mdx(\"p\", null, \"Other application components such as migrations, routes and views can be loaded from a service provider very easily. Just create a service provider for your module, register it in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"config/app.php\"), \", and set up the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"boot()\"), \" method to load whichever components you want from the appropriate place, as in this example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"        $this->loadMigrationsFrom(__DIR__.'/../database/migrations');\\n        $this->loadRoutesFrom(__DIR__.'/../routes.php');\\n        $this->loadViewsFrom(__DIR__.'/../views', 'comments');\\n\")), mdx(\"h1\", null, \"Separate packages\"), mdx(\"p\", null, \"The above approach works particularly well in the initial stages of a project, when you may need to jump around a lot to edit different parts of the project. However, later on, once many parts of the project have stabilised, it may make more sense to pull the modules out into separate repositories and use Composer to pull them in as dependencies, using its support for private repositories. I've also often taken this approach right from the start without issue.\"), mdx(\"p\", null, \"This approach has a number of advantages. It makes it easier to reuse parts of the project in other projects if need be. Also, if you put your tests in the packages containing the components they test, it means that rather than running one monolithic test suite for the whole project, you can instead run each module's tests each time you change it, and limit the test suite of the main project to those integration and acceptance tests that verify the whole thing, along with any unit tests for code that remains in the main repository, resulting in quicker test runs.\"), mdx(\"p\", null, \"Don't get me wrong, making your code more modular is definitely a good thing and I'm wholly in favour of it. However, it only takes a little knowledge of Composer to be able to achieve this without any third party package at all, which is good because you're no longer dependent on a package that may at any time fall behind the curve or be abandoned.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Lately I've seen a number of Laravel packages being posted on places like Reddit that offer ways to make your project more modular by letting you break their classes out of theâ€¦","frontmatter":{"title":"You don't need that module package","date":"03 January 2019","categories":["php","composer"]},"fields":{"path":"/blog/2019/01/03/you-dont-need-that-module-package/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2019/01/02/why-bad-code-is-bad/"},"frontmatter":{"title":"Why bad code is bad","date":"2019-01-02 23:00:50 +0000","layout":"post"}},"next":{"fields":{"path":"/blog/2019/01/13/writing-a-custom-sniff-for-php-codesniffer/"},"frontmatter":{"title":"Writing a custom sniff for PHP CodeSniffer","date":"2019-01-13 18:50:45 +0000","layout":"post"}}}},"staticQueryHashes":["290055352","2909664151"]}