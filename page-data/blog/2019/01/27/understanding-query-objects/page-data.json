{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2019/01/27/understanding-query-objects/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"6837cb9d-2daa-5243-b852-f34968daaee1","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Understanding query objects\",\n  \"date\": \"2019-01-27 23:10:39 +0000\",\n  \"layout\": \"post\",\n  \"categories\": [\"php\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The project I've been maintaining for the last year has inherited a rather dubious database structure that would currently be very difficult to refactor, which also makes many queries more convoluted than they should be. At present, I'm involved in building a whole new home page, which has necessitated adding some new queries. Since some of these involve carrying out unions between several similar tables (that should have been one table, grr...), they can involve some quite large chunks for each query.\"), mdx(\"p\", null, \"As a result, it's made sense to break those queries down further. Since Zend 1 doesn't have anything analogous to scopes in Eloquent, I don't really have an easy way to break these queries up in the models (and I'm trying to get the query logic out of the models at present anyway), so I opted to make them into query objects instead, which is a pattern I hadn't used before (but probably should have).\"), mdx(\"p\", null, \"A query object is pretty much what it says on the tin - it's a PHP object that executes a single, very specific query. This may seem like overkill, but it's only really useful for the most complex and convoluted of queries. It can accept parameters, as you'd expect, and some parts of the query may be optional based on that, but fundamentally it should build and run only one single query.\"), mdx(\"p\", null, \"In this post I'll go through how you might create one, how it relates to the repository pattern, and when to create one.\"), mdx(\"h2\", null, \"Creating a query object class\"), mdx(\"p\", null, \"I'm a big fan of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__invoke()\"), \" magic method in PHP. For the uninitiated, it lets you instantiate the class, and then use it in the same way you would a function, making it very useful for callbacks. This also brings some other advantages:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Unlike with a function, you can create private methods to do other parts of the work, making it easier to understand the main method.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It can have a constructor, and can therefore both accept dependencies via the constructor, and be instantiated via dependency injection, simplifying setup and testing when compared to using a callback.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Since \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"__invoke()\"), \" is an innate part of the PHP language, it makes more sense for classes that have a single responsibility to use that method name to do that, rather than picking something like \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"handle()\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"run()\"), \".\")), mdx(\"p\", null, \"As a result, my query objects generally use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__invoke()\"), \" method to trigger the query.\"), mdx(\"p\", null, \"Since Zend 1 is no longer supported, I won't bother displaying how I'd write the query in that specific context. I have yet to use this pattern with Laravel, but if I did, it would look something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Queries;\\n\\nuse Illuminate\\\\Database\\\\DatabaseManager;\\n\\nfinal class DashboardItems\\n{\\n    protected $db;\\n\\n    public function __construct(DatabaseManager $db)\\n    {\\n        $this->db = $db;\\n    }\\n\\n    public function __invoke(int $days = 7)\\n    {\\n        return $this->fooTable()\\n            ->union($this->barTable())\\n            ->whereRaw('start_date >= (NOW() - INTERVAL ? DAY)', [$days]);\\n            ->get();\\n    }\\n\\n    private function fooTable()\\n    {\\n        return $this->db->table('foo')\\n            ->where('type', '=', 'fooType');\\n    }\\n\\n    private function barTable(int $days)\\n    {\\n        return $this->db->table('bar')\\n            ->where('type', '=', 'barType');\\n    }\\n}\\n\")), mdx(\"p\", null, \"Note that we break each one of the tables we want to perform a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UNION\"), \" on into a private method. This is probably the biggest advantage of query objects - it lets you break particularly unwieldy queries up into logical steps, making them more readable. You could do this by adding private methods on a repository class too, but I'd be reluctant to add private methods to a repository that were only used in one query - to my mind, a query object is a better home for that.\"), mdx(\"h2\", null, \"What about repositories?\"), mdx(\"p\", null, \"I regularly use the repository pattern in my code bases, whether that's for Laravel projects or the current Zend 1-based legacy project. It's an ongoing effort to refactor it so that all the queries are called from repository classes, leaving the models to act as containers for the data. So how do query objects fit in here?\"), mdx(\"p\", null, \"It's important to note that while a repository represents all queries relating to a table, a query object represents only a single query, and so the repository should still be the place where the query is called from. However, the repository should just defer the actual querying to the query object. The relevant parts of the application structure for my current application look a bit like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"\\u2514\\u2500\\u2500 app\\n    \\u251C\\u2500\\u2500 Queries\\n    \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 DashboardItems.php\\n    \\u2514\\u2500\\u2500 Repositories\\n        \\u2514\\u2500\\u2500 DashboardRepository.php\\n\")), mdx(\"p\", null, \"And the repository might call the query object as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Repositories;\\n\\nuse App\\\\Queries\\\\DashboardItems;\\n\\nfinal class DashboardRepository\\n{\\n    public static function dashboardItems(int $days = 7)\\n    {\\n        $query = new DashboardItems;\\n        return $query($days);\\n    }\\n}\\n\")), mdx(\"p\", null, \"At present my repositories all use static methods as I'm still in the process of migrating the queries over to the repository classes. That also means I can't easily use dependency injection. For a Laravel application, a similar call might look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php\\n\\nnamespace App\\\\Repositories;\\n\\nuse App\\\\Queries\\\\DashboardItems;\\n\\nfinal class DashboardRepository\\n{\\n    protected $dashboardQuery;\\n\\n    public function __construct(DashboardItems $dashboardQuery)\\n    {\\n        $this->dashboardQuery = $dashboardQuery;\\n    }\\n\\n    public function dashboardItems(int $days = 7)\\n    {\\n        return $this->dashboardQuery($days);\\n    }\\n}\\n\")), mdx(\"p\", null, \"The only real difference is that we can instantiate the query object out of the container, simplifying setup.\"), mdx(\"h2\", null, \"When to use query objects\"), mdx(\"p\", null, \"I think it probably goes without saying, but it should be a rare query that actually needs to be implemented as a query object, especially if you're using an ORM like Eloquent that provides features like scopes, and as yet I only have two using this pattern, as well as two others that were implemented as \\\"reporter\\\" classes, but could be query objects instead. So far, my experience has been that the sort of queries that are large enough to be worth considering include:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Queries that generate reports, particularly if they have various options\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Queries that use unions, as in the above example, since it makes sense to use a private method to fetch each table\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Queries with multiple complex joins\")), mdx(\"p\", null, \"Smaller queries will typically fit happily inside a single method in your repository classes. If that's the case, then they can live there without trouble. However, if you have a query that's becoming too big to fit inside a single method, rather than adding private methods to your repository class, it may make more sense to refactor it out into a query object in its own right. You can still call it via the same method on your repository class, but the repository can just defer to the query object. As I usually use decorators to cache the responses from my repository classes anyway, then it makes sense to stick with this approach to keep caching consistent too.\"), mdx(\"p\", null, \"Query objects only really offer any value for particularly large queries. However, they can be invaluable in those circumstances. By enabling you to break those big queries up into a series of steps, they help make them easier to understand.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"The project I've been maintaining for the last year has inherited a rather dubious database structure that would currently be very difficult to refactor, which also makes manyâ€¦","frontmatter":{"title":"Understanding query objects","date":"27th January 2019 11:10 pm","isoDate":"2019-01-27T23:10:39+00:00","categories":["php"]},"fields":{"path":"/blog/2019/01/27/understanding-query-objects/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2019/01/13/writing-a-custom-sniff-for-php-codesniffer/"},"frontmatter":{"title":"Writing a custom sniff for PHP CodeSniffer","date":"2019-01-13 18:50:45 +0000","layout":"post"}},"next":{"fields":{"path":"/blog/2019/02/02/creating-your-own-dependency-injection-container-in-php/"},"frontmatter":{"title":"Creating your own dependency injection container in PHP","date":"2019-02-02 21:45:52 +0100","layout":"post"}}}},"staticQueryHashes":["290055352","3373576264"]}