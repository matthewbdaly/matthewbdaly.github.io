{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2020/02/09/dont-use-stdclass/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"7dc05faa-f76b-52ac-bad2-2907ae1c4e3b","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Don't use stdClass\",\n  \"date\": \"2020-02-09 10:10:48 +0000\",\n  \"layout\": \"post\",\n  \"categories\": [\"php\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The digital agency I work for specialises in marketing, so some of my work tends to relate to mailing lists. This week I was asked to look at an issue on a Laravel-based export system built by a co-worker who left a few months ago. This particular application pulled data from the Campaign Monitor API about campaigns, and it returned the data as instances of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stdClass\"), \", something that I'm not terribly happy about.\"), mdx(\"p\", null, \"Now, this was an implementation detail of the Campaign Monitor PHP SDK, which is old and creaky (to say the least...) and doesn't exactly abide by modern best practices. However, the legacy application I maintain also does this (there's a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"lot\"), \" of stuff that needs sorting out on it, and sadly replacing the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stdClass\"), \" instances is a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"long\"), \" way down the list), so I thought it was an interesting subject for a blog post. I consider using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stdClass\"), \", even just as a dumb container for data, to be an antipattern, and I thought it would be useful to explain my thoughts on this.\"), mdx(\"h1\", null, \"Why shouldn't I use stdClass?\"), mdx(\"h2\", null, \"Readability\"), mdx(\"p\", null, \"One of the first things I learned about throwing exceptions is that they should be meaningful. It's trivial to define a named exception and use that to specify the type of exception, and you can then capture exceptions to handle them differently elsewhere in the application. For instance, a validation error is entirely due to a user submitting the wrong details, and should therefore be handled in an entirely different manner to the database going down.\"), mdx(\"p\", null, \"The same is applicable to an object. If an API client returns an instance of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stdClass\"), \", that doesn't tell me anything about what that object is. If I need to pass it elsewhere in a large application, it may become very difficult to understand what it represents without tracking it back to where it came from, which will slow me down. If instead I use a named class, the name can convey what it represents. It may seem like overkill to create a class that adds no new functionality, but the mere fact that it has a name makes your code more meaningful and easier to understand. I can also add DocBlock comments to describe it further.\"), mdx(\"p\", null, \"Of course, just giving something a generic name like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Container\"), \" isn't much of an improvement, and coming up with meaningful names for classes and methods is notoriously hard. As always, give some serious thoughts into what your objects represent and attempt to give them names that will make it easy to understand what they are if you look at the code base again six months down the line.\"), mdx(\"h2\", null, \"Type hinting\"), mdx(\"p\", null, \"A related argument is that it makes type hinting more useful. You \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"can\"), \" type hint \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stdClass\"), \", but as noted above it tells someone working on the code receiving it very little about where it's come from, or what it represents, and it doesn't offer much value since an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stdClass\"), \" could mean anything, and could be created anywhere in the application.\"), mdx(\"p\", null, \"By contrast, named classes provides much more information about what the type hinted parameter represents. For instance, naming your class something such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App\\\\Api\\\\Response\\\\Item\"), \", makes it much clearer that that object represents an individual item returned from an API, and others developers working on the same code base (including your future self, who may not necessarily remember all of the details of how you're implementing it now), will have less trouble understanding what is going on. There's also a much-reduced likelihood of the same class being used to represent completely different types of data.\"), mdx(\"h2\", null, \"New functionality\"), mdx(\"p\", null, \"Finally, are you sure you don't want to add any functionality? PHP includes a number of interfaces that can be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"extremely\"), \" useful for working with this sort of data.\"), mdx(\"p\", null, \"First off, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ArrayAccess\"), \" interface allows you to access an object's values using array syntax, which can be useful. Also, implementing either \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Iterator\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IteratorAggregate\"), \" will allow you to iterate over the object using a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foreach\"), \" loop. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Countable\"), \" interface is less useful, since all it does is let you get the number of items, but it's sometimes handy. Finally, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Serializable\"), \" interface lets you serialise an object so it can be stored in a suitable medium, which can sometimes be useful.\"), mdx(\"p\", null, \"The same also applies to some of the magic methods. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__toString()\"), \" method, in particular, can be useful for returning a suitable string-based representation of an object - for instance, if it represents an item in a database, it might be appropriate to use this to return the ID of the item, or a text representation of it (eg title for a blog post, or product name for a product in an e-commerce site). The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__get()\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__set()\"), \" magic methods may be a bit more dubious, but they can be useful if your object is intended to just be a dumb container as they allow you to make the properties on the object private, but keep them accessible without writing explicit getters and setters. I'd also suggest adding \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__debugInfo()\"), \" to objects unless you have a good reason not to, as when you're debugging it can be hard to see the wood for the trees, and returning only the most pertinent data can make your job a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"lot\"), \" easier.\"), mdx(\"p\", null, \"Of course, you don't have to implement all this functionality from scratch for every class. It often makes sense to create an abstract class that implements this sort of basic container functionality, and then base all your container classes on that, overriding it when necessary.\"), mdx(\"h2\", null, \"Summary\"), mdx(\"p\", null, \"Hopefully, this has made it clear how compelling it is to use named classes instead of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stdClass\"), \", and how much benefit you can get from not just using named classes, but creating your own base container class for them. I'm of the opinion that PHP should probably make \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stdClass\"), \" abstract to prevent them from being used like this, and indeed I'm seriously considering the idea of creating a Codesniffer sniff to detect instances of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stdClass\"), \" being instantiated and raise them as an error.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"The digital agency I work for specialises in marketing, so some of my work tends to relate to mailing lists. This week I was asked to look at an issue on a Laravel-based export…","frontmatter":{"title":"Don't use stdClass","date":"9th February 2020 10:10 am","isoDate":"2020-02-09T10:10:48+00:00","categories":["php"]},"fields":{"path":"/blog/2020/02/09/dont-use-stdclass/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2020/01/25/f***-phpstorm-man-and-the-high-horse-he-rode-in-on/"},"frontmatter":{"title":"F*** PHPStorm Man and the high horse he rode in on","date":"2020-01-25 22:25:17 +0000","layout":"post"}},"next":{"fields":{"path":"/blog/2020/02/12/the-trouble-with-integrated-static-analysis/"},"frontmatter":{"title":"The trouble with integrated static analysis","date":"2020-02-12 22:40:15 +0000","layout":"post"}}}},"staticQueryHashes":["290055352","2909664151"]}