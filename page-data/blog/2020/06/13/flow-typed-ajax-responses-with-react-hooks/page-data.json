{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2020/06/13/flow-typed-ajax-responses-with-react-hooks/","result":{"data":{"site":{"siteMetadata":{"title":"Matthew Daly","siteUrl":"https://matthewdaly.co.uk"}},"mdx":{"id":"398ad4a7-ca4f-572b-a1b2-94b697d31fcf","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Flow typed AJAX responses with React Hooks\",\n  \"date\": \"2020-06-13 13:50:41 +0100\",\n  \"layout\": \"post\",\n  \"categories\": [\"javascript\", \"react\", \"flow\"],\n  \"comments\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I'm a big fan of type systems in general. Using Psalm to find missing type declarations and incorrect calls in PHP has helped me out tremendously. However, I'm not a big fan of Typescript. The idea of creating a whole new language, primarily just to add types to Javascript, strikes me as a fundamentally bad idea given how many languages that compile to Javascript have fallen by the wayside. Flow seems like a much better approach since it adds types to the language rather than creating a new language, and I've been using it on my React components for a good while now. However, there are a few edge cases that can be difficult to figure out, and one of those is any generic AJAX component that may be reused for different requests.\"), mdx(\"p\", null, \"A while back I wrote the following custom hook, loosely inspired by axios-hooks (but using the Fetch API) to make a query to a GraphQL endpoint:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\",\n    \"metastring\": \"title=useFetch.js\",\n    \"title\": \"useFetch.js\"\n  }, \"import { useCallback, useState, useEffect } from \\\"react\\\";\\n\\nfunction useFetch(url, query) {\\n  const [data, setData] = useState(null);\\n  const [loading, setLoading] = useState(false);\\n  const [error, setError] = useState(false)\\n\\n  const fetchData = useCallback(() => {\\n    setLoading(true);\\n    fetch(url, {\\n      method: 'POST',\\n      headers: {\\n        'Content-Type': 'application/json',\\n        'Accept': 'application/json',\\n      },\\n      body: JSON.stringify({query: query})\\n    }).then(r => r.json())\\n      .then((data) => {\\n        setData(data.data);\\n        setLoading(false);\\n        setError(false);\\n      });\\n  }, [url, query]);\\n\\n  useEffect(() => {\\n    fetchData();\\n  }, [url, query, fetchData]);\\n\\n  return [{\\n    data: data,\\n    loading: loading,\\n    error: error\\n  }, fetchData];\\n};\\n\\nexport default useFetch;\\n\")), mdx(\"p\", null, \"When called, the hook receives two parameters, the URL to hit, and the query to make, and returns an array that contains a function for reloading, and an object containing the following values:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"loading\"), \" - a boolean that specifies if the hook is loading right now\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"error\"), \" - a boolean that specifies if an error has occurred\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"data\"), \" - the response data from the endpoint, or null\")), mdx(\"p\", null, \"Using this hook, it was then possible to make an AJAX request when a component was loaded to populate the data, as in this example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\",\n    \"metastring\": \"title=App.js\",\n    \"title\": \"App.js\"\n  }, \"import React from 'react';\\nimport useFetch from './Hooks/useFetch';\\nimport marked from 'marked';\\nimport './App.css';\\n\\nfunction App() {\\n  const url = `/graphql`;\\n  const query = `query {\\n    posts {\\n      title\\n      slug\\n      content\\n      tags {\\n        name\\n      }\\n    }\\n  }`;\\n\\n  const [{data, loading, error}] = useFetch(url, query);\\n\\n  if (loading) {\\n    return (<h1>Loading...</h1>);\\n  }\\n\\n  if (error) {\\n    return (<h1>Error!</h1>);\\n  }\\n\\n  const posts = data ? data.posts.map((item) => (\\n    <div key={item.slug}>\\n      <h2>{item.title}</h2>\\n      <div dangerouslySetInnerHTML={{__html: marked(item.content)}} />\\n    </div>\\n  )) : [];\\n  return (\\n    <div className=\\\"App\\\">\\n      {posts}\\n    </div>\\n  );\\n}\\n\\nexport default App;\\n\")), mdx(\"p\", null, \"This hook is simple, and easy to reuse. However, it's difficult to type the value of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data\"), \" correctly, since it will be different for different endpoints, and given that it may be reused for almost any endpoint, you can't cover \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"all\"), \" the acceptable response types. We need to be able to specify the response that is acceptable in that particular context.\"), mdx(\"h2\", null, \"Generics to the rescue\"), mdx(\"p\", null, \"Flow provides a solution for this in the shape of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://flow.org/en/docs/types/generics/\"\n  }, \"generic types\"), \". By passing in a polymorphic type using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<T>\"), \" in the function declaration, we can then refer to that type when specifying what \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data\"), \" should look like:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-flow\",\n    \"metastring\": \"title=useFetch.js {4-11}\",\n    \"title\": \"useFetch.js\",\n    \"{4-11}\": true\n  }, \"//@flow\\nimport { useCallback, useState, useEffect } from \\\"react\\\";\\n\\nfunction useFetch<T>(url: string, query: string): [{\\n  data: ?T,\\n  loading: boolean,\\n  error: boolean\\n}, () => void] {\\n  const [data, setData]: [?T, ((?T => ?T) | ?T) => void] = useState(null);\\n  const [loading, setLoading]: [boolean, ((boolean => boolean) | boolean) => void] = useState(false);\\n  const [error, setError]: [boolean, ((boolean => boolean) | boolean) => void] = useState(false)\\n\\n  const fetchData = useCallback(() => {\\n    setLoading(true);\\n    fetch(url, {\\n      method: 'POST',\\n      headers: {\\n        'Content-Type': 'application/json',\\n        'Accept': 'application/json',\\n      },\\n      body: JSON.stringify({query: query})\\n    }).then(r => r.json())\\n      .then((data) => {\\n        setData(data.data);\\n        setLoading(false);\\n        setError(false);\\n      });\\n  }, [url, query]);\\n\\n  useEffect(() => {\\n    fetchData();\\n  }, [url, query, fetchData]);\\n\\n  return [{\\n    data: data,\\n    loading: loading,\\n    error: error\\n  }, fetchData];\\n};\\n\\nexport default useFetch;\\n\")), mdx(\"p\", null, \"Then, when calling the hook, we can define a type that represents the expected shape of the data (here called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<Data>\"), \"), and specify that type when calling the hook, as in this example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-flow\",\n    \"metastring\": \"title=App.js\",\n    \"title\": \"App.js\"\n  }, \"//@flow\\nimport React from 'react';\\nimport useFetch from './Hooks/useFetch';\\nimport marked from 'marked';\\nimport './App.css';\\n\\ntype Data = {\\n  posts: Array<{\\n    title: string,\\n    slug: string,\\n    content: string,\\n    name: Array<string>\\n  }>\\n};\\n\\nfunction App() {\\n  const url = `/graphql`;\\n  const query = `query {\\n    posts {\\n      title\\n      slug\\n      content\\n      tags {\\n        name\\n      }\\n    }\\n  }`;\\n\\n  const [{data, loading, error}] = useFetch<Data>(url, query);\\n\\n  if (loading) {\\n    return (<h1>Loading...</h1>);\\n  }\\n\\n  if (error) {\\n    return (<h1>Error!</h1>);\\n  }\\n\\n  const posts = data ? data.posts.map((item) => (\\n    <div key={item.slug}>\\n      <h2>{item.title}</h2>\\n      <div dangerouslySetInnerHTML={{__html: marked(item.content)}} />\\n    </div>\\n  )) : [];\\n  return (\\n    <div className=\\\"App\\\">\\n      {posts}\\n    </div>\\n  );\\n}\\n\\nexport default App;\\n\")), mdx(\"p\", null, \"That way, we can specify a completely different shape for our response data every time we call a different endpoint, without creating a different hook for every different endpoint, and still enjoy properly typed responses from our hook.\"), mdx(\"p\", null, \"Generics can be useful for many other purposes, such as specifying the contents of collections. For instance, if you had a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Collection\"), \" object, you could use a generic type to specify that any one instance must consist of instances of a given type. Flow would then flag it as an error if you assigned an item of the wrong type to that collection, thus making some unit tests redundant.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"I'm a big fan of type systems in general. Using Psalm to find missing type declarations and incorrect calls in PHP has helped me out tremendously. However, I'm not a big fan of…","frontmatter":{"title":"Flow typed AJAX responses with React Hooks","date":"13 June 2020","categories":["javascript","react","flow"]},"fields":{"path":"/blog/2020/06/13/flow-typed-ajax-responses-with-react-hooks/"}}},"pageContext":{"previous":{"fields":{"path":"/blog/2020/03/11/caching-the-laravel-user-provider-with-a-decorator/"},"frontmatter":{"title":"Caching the Laravel user provider with a decorator","date":"2020-03-11 21:20:14 +0000","layout":"post"}},"next":{"fields":{"path":"/blog/2020/09/28/what-i-want-in-a-php-cms/"},"frontmatter":{"title":"What I want in a PHP CMS","date":"2020-09-28 15:50:48 +0100","layout":"post"}}}},"staticQueryHashes":["2909664151"]}