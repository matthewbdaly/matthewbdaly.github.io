<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Matthew Daly</title>
        <link>https://matthewdaly.co.uk</link>
        <description>I'm a web developer in Norfolk. This is my blog...</description>
        <lastBuildDate>Sun, 19 Jun 2022 17:41:49 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>GatsbyJS</generator>
        <language>en</language>
        <copyright>All rights reserved Matthew Daly 2022</copyright>
        <atom:link href="/rss.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[The ORM Delusion]]></title>
            <link>https://matthewdaly.co.uk/blog/2022/06/05/the-orm-delusion/</link>
            <guid>https://matthewdaly.co.uk/blog/2022/06/05/the-orm-delusion/</guid>
            <pubDate>Sun, 05 Jun 2022 18:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>I&#x27;ve used some low-level database interfaces like PDO, and the database interfaces from several frameworks, including Codeigniter, Zend 1, Django, and Laravel, and I&#x27;ve been in the web development industry for over a decade at this point, so I&#x27;ve had a reasonable amount of experience working with various database interfaces. Based on this experience, I agree wholly with <a href="https://twitter.com/erikaheidi/status/1510347907819524105?s=20&amp;t=0IjKFyO3O-EctVq43hRkVw">this tweet</a> about the advantages of using an ORM on your project. I routinely use an ORM for the overwhelming majority of projects I work on and rarely need to drop down to writing raw SQL. Unfortunately, there seems to be an <em>awful</em> lot of misinformation and misconceptions about the advantages and disadvantages of choosing to use an ORM, and when to do so.</p><p>A lot of people seem to think that using an ORM inherently makes your application perform badly. However, this just isn&#x27;t true, <em>as long as you&#x27;re using the ORM the right way</em>. Using an ORM not only allows you to solve certain classes of performance problems more easily than by writing SQL statements, but they generally make it easier to reason about how your application works. However, there are some things you need to bear in mind when using one, to prevent you from introducing potential performance problems. In this post, I&#x27;ll give you the reasons why you should consider using an ORM on your projects, at least by default, and warn you about some of the things that can cause trouble when using one.</p><div title="Fair warning"><p>If you&#x27;re going to patronize me, or other commenters, by mansplaining <a href="https://www.culttt.com/2014/06/18/whats-difference-active-record-data-mapper">ActiveRecord vs DataMapper</a>, you can get in the damned sea. I know the difference and I&#x27;ve chosen to use ActiveRecord. I&#x27;m categorically not interested in rehashing that argument, let alone being condescended to, and I will delete <strong>any comments</strong> that I think do either. If you <em>do</em> have <em>legitimate, specific gripes</em> about Eloquent, or any other implementation of ActiveRecord, or indeed ORMs in general, and can moan about them without being unpleasant to other people, I&#x27;m happy to accept those comments. No tool is perfect, and there are always some cases where it will cause problems, but I will not tolerate anyone being disrespectful. Using Laravel, Eloquent, or any ActiveRecord implementation, does not make someone Nooby McNoobface, and if you&#x27;re going to claim it does, you&#x27;re not welcome here.</p></div><p>Please note, that while I&#x27;m referring to Eloquent throughout this post, the overwhelming majority of what I&#x27;m talking about is also applicable to other ORMs, particularly other Active Record-style ORMs such as the Django ORM. I&#x27;m using Eloquent as the primary example here because it&#x27;s the one I&#x27;ve used most often in the last few years.</p><h2>Reasons to use an ORM</h2><p>Below I&#x27;ve listed the reasons I can think of for using an ORM. I don&#x27;t think this is necessarily an exhaustive list, and others may be able to think of others or express these reasons more elegantly than I can. If you can think of other good reasons, feel free to add them to the comments.</p><h3>Resolving N+1 queries</h3><p>In my experience, N+1 queries are <em>far and away</em> the most common performance problem I&#x27;ve encountered when dealing with legacy applications that don&#x27;t use an ORM. They&#x27;re typically somewhat less obvious than a single slow query would be when profiling your code because the problem comes from multiple small queries, rather than from single large ones, but they can have a crippling effect on the performance of your application.</p><p>It <em>is</em> possible to use JOINs to pull in another table and get the related data in a single query, but that <em>really</em> starts to get hairy if you have to pull in multiple levels of tables, and it can be <em>very</em> difficult to write a query that does so while remaining easy to understand.</p><p>Fortunately, most ORMs have simple methods for efficiently fetching related data via eager loading. For instance, Eloquent has the <code>with()</code> and <code>load()</code> methods. By making good use of these methods, you can write efficient queries that are still straightforward to understand. In addition, you can also use methods such as <code>has()</code> and <code>whereHas()</code> to query relationship existence, which is generally a lot more elegant than the underlying <code>WHERE EXISTS</code> statement.</p><p>Eloquent also carries out a degree of caching, particularly when dealing with relations. This can sometimes eliminate queries that would be made by a more naive ORM, but in the event you <em>do</em> need it, you can call the <code>refresh()</code> method on the model to ensure it&#x27;s up to date.</p><h3>Type safety</h3><p>Using an ORM, as opposed to a query builder or writing raw SQL, offers significant advantages in terms of the type safety of the code base.</p><p>For instance, say you have the below method in a Laravel project which returns an array of data from a query:</p><pre><code class="language-php">&lt;?php

use DB;

final class ProductRepository {
    // Rest of class...

    public function getFirstProductBelow(float $price): array
    {
        return DB::table(&#x27;products&#x27;)-&gt;where(&#x27;price&#x27;, &#x27;&lt;&#x27;, $price)-&gt;first();
    }
}
</code></pre><p>While having a return type at all is better than none, it isn&#x27;t very useful for static analysis tools. Just telling Psalm that the response is an array doesn&#x27;t tell it what fields to expect in that array.</p><p>You <em>can</em> use annotations to specify a more meaningful response...</p><pre><code class="language-php">&lt;?php

use DB;

final class ProductRepository {
    // Rest of class...

    /*
     * @psalm-return array{id: int, name: string, price: float}
     */
    public function getFirstProductBelow(float $price): array
    {
        return DB::table(&#x27;products&#x27;)-&gt;where(&#x27;price&#x27;, &#x27;&lt;&#x27;, $price)-&gt;first();
    }
}
</code></pre><p>And that <em>would</em> tell Psalm that it returns an array with the denoted keys. However, it&#x27;s not the best solution:</p><ul><li>You&#x27;d need to either duplicate that <code>@psalm-return</code> docblock to any other method that returns a list of those items, in which case adding a new field becomes problematic, or you&#x27;d have to use a predefined template annotation</li><li>Those annotations need to be maintained, and if they got out of sync with your database structure, Psalm might get confused</li><li>The native PHP return type can only validate that the response is an array. The actual response could <em>theoretically</em> look very different and short of adding some potentially long-winded <code>assert()</code> calls about the shape of the array, we can&#x27;t validate that the right values exist.</li></ul><p>But suppose we instead use Eloquent. Our method might then look like this:</p><pre><code class="language-php">&lt;?php

use App\Models\Product;

final class ProductRepository {
    // Rest of class...

    public function getFirstProductBelow(float $price): Product
    {
        return Product::where(&#x27;price&#x27;, &#x27;&lt;&#x27;, $price)-&gt;first();
    }
}
</code></pre><p>We now know with absolute certainty that the response from this method is an instance of <code>App\Models\Product</code> because we&#x27;ve been able to declare a return type, and if it wasn&#x27;t, the method would throw an exception.</p><p>By itself, that doesn&#x27;t tell us what fields to expect on an instance of <code>App\Models\Product</code>, but Laravel IDE Helper can easily generate suitable <code>@property</code> annotations for us, based on the current database structure. If we run the following command:</p><pre><code class="language-bash">$ php artisan ide-helper:models -W
</code></pre><p>Then our model might end up looking something like this:</p><pre><code class="language-php">&lt;?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

/*
 * @property integer $id
 * @property string $name
 * @property float price
 */
final class Product extends Model
{
    // class body here
}
</code></pre><p>And that gives Psalm a single, canonical description of the structure of this class. Even if you couldn&#x27;t use Laravel IDE Helper for some reason, it&#x27;s not exactly onerous to manually define the properties on a given model in one place - it&#x27;s the work of a few minutes if you do it at the same time you define your models and migrations.</p><p>For even better type safety on your models, you can add the <code>@psalm-seal-properties</code> annotation, which will ensure that if you try to use an undocumented property on the model, Psalm will flag it as an issue. And having comprehensive type information isn&#x27;t just a matter of finding type issues, it also affects how good your autocompletion will be - with better type hints, you&#x27;ll have more effective and accurate completion options.</p><h3>Refraining from reinventing the wheel, probably badly</h3><p>I maintain a large legacy Zend 1 application where the original developer decided they didn&#x27;t want to use an existing ORM. Instead, they wrote their own model classes which looked something like this:</p><pre><code class="language-php" metastring="title=application/models/Page.php" title="application/models/Page.php">&lt;?php

class Application_Model_Page
{
    protected $id;
    protected $name;
    protected $price;

    public function __construct()
    {
        $this-&gt;id = null;
        $this-&gt;name = null;
        $this-&gt;price = null;
    }

    public function getId()
    {
        return $this-&gt;id;
    }

    public function setId($val)
    {
        $this-&gt;id = $val;
        return $this;
    }

    public function getName()
    {
        return $this-&gt;name;
    }

    public function setName($val)
    {
        $this-&gt;name = $val;
        return $this;
    }

    public function getPrice()
    {
        return $this-&gt;price;
    }

    public function setPrice($val)
    {
        $this-&gt;price = $val;
        return $this;
    }

    public function toArray()
    {
        return [
            &#x27;id&#x27; =&gt; $this-&gt;id,
            &#x27;name&#x27; =&gt; $this-&gt;name,
            &#x27;price&#x27; =&gt; $this-&gt;price,
        ];
    }

    public function populate(array $data)
    {
        $this-&gt;id = $data[&#x27;id&#x27;];
        $this-&gt;name = $data[&#x27;name&#x27;];
        $this-&gt;price = $data[&#x27;price&#x27;];
        return $this;
    }

    public function save()
    {
        $db = Zend_Registry::get(&#x27;db&#x27;);
        $data = [
            &#x27;name&#x27; =&gt; $this-&gt;name,
            &#x27;price&#x27; =&gt; $this-&gt;price,
        ];
        $db-&gt;update(&#x27;products&#x27;, $data, &#x27;id=&#x27; . $this-&gt;id);
    }

    public function find($id)
    {
        $db = Zend_Registry::get(&#x27;db&#x27;);
        $result = $db-&gt;fetchRow(&#x27;SELECT * FROM products WHERE id = &#x27; . $id);
        return $this-&gt;populate($result);
    }
}
</code></pre><p>Honestly, there are so many issues with this it&#x27;s hard to know where to start:</p><ul><li>You can&#x27;t define generic implementations of the various methods because they&#x27;re dependent on a specific structure, so you have to define those methods from scratch for every single model</li><li>The <code>find()</code> method requires that you first create an instance of the object, then call that method to return another instance, eg <code>(new Application_Model_Page())-&gt;find(1)</code>, which is extremely cumbersome</li><li>And if you want to populate multiple instances, you have to do so manually like this:</li></ul><pre><code class="language-php">&lt;?php
$response = [];
foreach ($result as $row) {
    $response[] = (new Application_Model_Page())-&gt;populate($row);
}
return $response;
</code></pre><p>We&#x27;re in the process of migrating off these legacy models to Eloquent, with the intent of eventually migrating the whole application to Laravel, and the contrast between using the two model types could not be greater. The Eloquent models are easy to maintain, easy to work with, highly performant, and require far less boilerplate code when implementing functionality.</p><p>Martin Fowler covered this issue pretty well in <a href="https://martinfowler.com/bliki/OrmHate.html">ORM Hate</a>. To quote:</p><blockquote><p>Listening to some critics, you&#x27;d think that the best thing for a modern software developer to do is roll their own ORM. The implication is that tools like Hibernate and Active Record have just become bloatware, so you should come up with your own lightweight alternative. Now I&#x27;ve spent many an hour griping at bloatware, but ORMs really don&#x27;t fit the bill - and I say this with bitter memory. For much of the 90&#x27;s I saw project after project deal with the object/relational mapping problem by writing their own framework - it was always much tougher than people imagined. Usually you&#x27;d get enough early success to commit deeply to the framework and only after a while did you realize you were in a quagmire - this is where I sympathize greatly with Ted Neward&#x27;s famous quote that object-relational mapping is the Vietnam of Computer Science.</p><p>The widely available open source ORMs (such as iBatis, Hibernate, and Active Record) did a great deal to remove this problem. Certainly they are not trivial tools to use, as I said the underlying problem is hard, but you don&#x27;t have to deal with the full experience of writing that stuff (the horror, the horror). However much you may hate using an ORM, take my word for it - you&#x27;re better off.</p></blockquote><p>And it&#x27;s worth bearing in mind that those words were written a decade ago. We now have over ten years&#x27; more experience finding potential problems with ORMs and finding effective solutions for those problems, and Eloquent has benefited from those changes, as well as improvements in the PHP language. Many issues you might have with an ORM ten years ago may simply no longer be worth worrying about.</p><h3>Consistency</h3><p>Eloquent&#x27;s scopes in particular have been invaluable for me in ensuring consistency. On the Zend 1 project mentioned above, there are still some issues with poor, inconsistent database design that I haven&#x27;t yet been able to get around to resolving. One of these is that different content types are stored in different tables with different field names, but we need to be able to make them work consistently when resolving whether a given item is in date, even though the fields have different names.</p><p>If we had to use the query builder or write SQL, we&#x27;d be stuck writing the same chunk of the query over and over each time we needed to get the in-date items of each type, and it would be all too easy to mess it up and use the wrong field name when doing a union of different content types. But if we define a local scope on each model called <code>scopeIsInDate()</code> with an implementation specific to that model, we can then easily reuse that and ensure consistency.</p><p>We also have a use case where, based on the value of one field, or whether the ID of the model is in a hard-coded list, it needs to be treated as a different object. By using a global scope, we can create two models that extend a common base, and apply one scope to one model, and another to the other model. That way, even though we have only one database table, we can effectively treat it as two separate ones when using the models. Yes, a better database structure would resolve that, but this is a big legacy application and there&#x27;s already lots to do to clean it up, so we can&#x27;t justify it any time soon.</p><h3>Reduces context switching</h3><p>Going from writing PHP to writing SQL and back is <em>hard</em> on the grey matter. It will slow you down because:</p><ul><li>You have to go from one mental model of how to construct a correct statement in terms of grammar and punctuation to another</li><li>You&#x27;re mixing two or more languages up in the same file, which isn&#x27;t great - your editor or IDE may not be able to easily apply proper syntax highlighting to the SQL if it&#x27;s just a string. This may make it harder to spot syntax errors</li></ul><p>If instead you only have to think about PHP&#x27;s rules while writing a query, the mental load is significantly lower and your editor or IDE can help you out a lot more.</p><p>Now, it has to be said, sometimes there <em>are</em> queries where it&#x27;s easier to write it out initially in SQL using something like MySQL Workbench, but I&#x27;d still advocate taking the time to go back and translate those queries into Eloquent if possible, or to the query builder if that&#x27;s more practical. I consider raw SQL in a PHP file to be technical debt because, in addition to the other points above:</p><ul><li>It makes it all too easy to accidentally leave an SQL injection vulnerability in your code</li><li>You can&#x27;t extract a part of the query to a scope for reuse, or make use of existing scopes to handle a part of the query</li></ul><p>As always, sometimes if you&#x27;re in a rush you can justify adding technical debt on a temporary basis, but that should be the exception, not the rule, and has to be justified.</p><h2>Things to bear in mind when using an ORM</h2><p>With the reasons I&#x27;d recommend using an ORM out the way, here are some of the gotchas you should be aware of when making a decision about using one:</p><h3>The ORM is an abstraction for SQL, not a replacement</h3><p>Honestly, the overwhelming majority of performance issues developers have with ORM&#x27;s boil down to this. Again with a quote from Martin Fowler:</p><blockquote><p>I&#x27;ve often felt that much of the frustration with ORMs is about inflated expectations. Many people treat the relational database &quot;like a crazy aunt who&#x27;s shut up in an attic and whom nobody wants to talk about&quot;</p></blockquote><p>If a developer treats an ORM like a black box and just writes queries without thinking about the SQL it generates, it&#x27;s no surprise whatsoever if the generated queries don&#x27;t perform well. It&#x27;s still running queries under the bonnet, it&#x27;s just that some of it is implicit. For instance, take this (relatively simple) example of an Eloquent query:</p><pre><code class="language-php">Post::join(&#x27;user&#x27;)-&gt;get();
</code></pre><p>If you use something like Clockwork to profile this query, the end result will probably look something like this:</p><pre><code class="language-sql">SELECT * FROM posts
INNER JOIN users ON posts.user_id = users.id
</code></pre><p>And, to be fair, there <em>are</em> a few potential issues with this query.</p><ul><li>If you&#x27;re retrieving all the fields from the <code>posts</code> and <code>users</code> tables, then that could easily include fields that you don&#x27;t explicitly need</li><li>Depending on the use case, returning an arbitrary number of database rows can be potentially problematic, performance-wise, and it may be better to</li><li>If you haven&#x27;t set an appropriate foreign key on <code>posts.user_id</code>, the join could perform badly</li></ul><p>However, these issues really aren&#x27;t inherent to using an ORM, but are to do with it being used naively. Assuming we do want to paginate these results, and the only field on <code>users</code> that we need is the name, we could achieve what we want by rewriting this query as follows:</p><pre><code class="language-php">Post::join(&#x27;user&#x27;)-&gt;select(&#x27;posts.*&#x27;, &#x27;users.name&#x27;)-&gt;paginate(20);
</code></pre><div><p>Yes, <a href="https://laravel.com/docs/9.x/pagination#cursor-pagination">cursor pagination</a> is a thing and will perform better than offset-based pagination in most cases, but I&#x27;m deliberately keeping this example as simple as possible.</p></div><p>As for the third issue, that&#x27;s easy enough - just ensure that you&#x27;re setting an appropriate foreign key.</p><h3>An ORM isn&#x27;t training wheels, it&#x27;s a power tool</h3><p>This is nearly the same issue as that above, but it&#x27;s important enough to deserve being mentioned separately.</p><p>Using an ORM effectively requires knowledge of your relational database. To write efficient queries with it, you need the same knowledge that you do to write the underlying query in SQL, AND knowledge of the ORM itself. If you start using it without learning to use a relational database (or let a junior dev who hasn&#x27;t learned SQL properly), or don&#x27;t profile your queries, you&#x27;re going to run into problems.</p><p>I&#x27;ve often heard people suggest that using an ORM means your SQL skills atropy. Quite frankly, I find that utterly laughable. I make a point of avoiding writing raw SQL when I can use an ORM, and I still often find myself having to write raw SQL, particularly if I&#x27;m prototyping a complex query. It does make it unnecessary to write out simple queries in SQL, but I&#x27;m not going to benefit in the slightest at this point in my career by writing something like <code>SELECT * FROM posts</code> over and over if I can call <code>Post::all()</code> instead.</p><h3>Hydration can become a bottleneck for large datasets</h3><p>It has to be said, there <em>is</em> inevitably some overhead from instantiating an ORM model, which can be quite a complex class, compared to instantiating an array of data, and if you have to work with a response that contains a large number of rows, it may be better to return arrays than model instances.</p><p>Case in point, the Zend 1 project I maintain has a number of reports which the client downloads once a week. This includes a report of all the current users in the system, and although users who leave are cleaned out of the system automatically, there&#x27;s typically around thirty thousand rows returned from this query. That&#x27;s big enough that the time taken to instantiate a model instance for each row can become significant, and you don&#x27;t need a model instance if all you&#x27;re going to do is dump the data out to a CSV file. So in those circumstances, you&#x27;re better off using the query builder and returning an array - it&#x27;ll be quicker and use less memory.</p><p>Fortunately, it&#x27;s easy to convert an Eloquent query to a query builder one by calling the <code>getQuery()</code> method. That way you can write your query using Eloquent as normal, then convert it to a query builder instance, and return the data as an array.</p><h3>You can write nearly any query with an ORM, but it may require more effort</h3><p>Just because there isn&#x27;t a method for a particular SQL statement, or the methods it does have don&#x27;t have the options you need, doesn&#x27;t mean you need to write it the whole thing as a raw query. There&#x27;s still the various raw methods:</p><ul><li><code>selectRaw</code></li><li><code>whereRaw</code>/<code>orWhereRaw</code></li><li><code>havingRaw</code>/<code>orHavingRaw</code></li><li><code>orderByRaw</code></li><li><code>groupByRaw</code></li></ul><p>By making appropriate use of these methods, you can write only those parts of the query that absolutely need to be raw, without losing the advantages of using an ORM. For instance, if you need to use <code>CASE ... WHEN</code> statement to return a true or false value for if an entry is in date, or use <code>GROUP_CONCAT()</code> to concatenate some names from a related field into one field, you can easily do so using something like <code>-&gt;selectRaw(&#x27;CASE WHEN expiry_date &lt; NOW() THEN &#x27;true&#x27; ELSE &#x27;false&#x27;, GROUP_CONCAT(name)&#x27;)</code>.</p><p>Some more advanced parts of SQL can be harder to write using an ORM. For instance, take this query:</p><pre><code class="language-sql">WITH RECURSIVE children(id, name, parent_id, depth) AS
  (SELECT teams.*,
          0 AS depth
   FROM `teams`
   WHERE id = 1
   UNION ALL SELECT teams.*,
                    children.depth + 1
   FROM teams
   INNER JOIN children ON children.parent_id = teams.id)
SELECT *
FROM children
</code></pre><p>The <code>WITH RECURSIVE</code> CTE is a relatively new feature in SQL and not every implementation supports it. In addition, it&#x27;s only useful in certain, quite specific circumstances. As such, support for it is limited in most ORMs, and this is one use case where it <em>might</em> not be worth the bother of rewriting the query to use an ORM. However, it&#x27;s not impossible. The <a href="https://github.com/staudenmeir/laravel-cte">Laravel CTE</a> package extends Eloquent to add support for recursive queries, and even if you can&#x27;t use that for some reason, it might be worth rewriting the inner query alone in Eloquent, then using <code>toSql()</code> to get the SQL from it and insert that into the outer query, something like this:</p><pre><code class="language-php">$teams = Team::where(&#x27;id&#x27;, 1)
    -&gt;unionAll(Team::join(&#x27;children&#x27;, &#x27;children.parent_id&#x27;, &#x27;=&#x27;, &#x27;teams.id&#x27;)
    -&gt;selectRaw(&#x27;teams.*, children.depth + 1&#x27;)
    -&gt;toSql();
$query = &quot;WITH RECURSIVE children(id, name, parent_id, depth) AS ($teams) SELECT * FROM children&quot;;
</code></pre><p>It&#x27;s not perfect, but this at least means some of the query is expressed using Eloquent, making it easier to maintain and debug.</p><h3>You need to profile your queries to ensure they&#x27;re efficient</h3><p>Just because a query isn&#x27;t written manually doesn&#x27;t mean it&#x27;s not inefficient, and sometimes there can be hidden queries you&#x27;re not aware of. Third-party packages can be a source of this, and <a href="/blog/2020/03/11/caching-the-laravel-user-provider-with-a-decorator/">the authentication system can trigger some less-than-obvious queries which can be cached</a>. For this reason, it&#x27;s a really good idea to profile your pages to make sure they&#x27;re performing as expected.</p><p>I favour <a href="https://underground.works/clockwork/">Clockwork</a> as my profiling tool of choice, but <a href="https://laravel.com/docs/9.x/telescope">Laravel Telescope</a> and <a href="https://github.com/barryvdh/laravel-debugbar">Laravel Debugbar</a> are also solid options for this.</p><h3>It&#x27;s unlikely you can swap databases without rewriting at least some queries</h3><p>One of the advantages I&#x27;ve heard claimed for ORMs in the past is being able to migrate from, say, MySQL to PostgreSQL without making any changes to the code base. Honestly, I don&#x27;t think this one is very likely unless your queries are <em>very</em> simple. Any call to any of the <code>*raw()</code> would need to be manually checked and migrated, and I don&#x27;t think any sizeable application would be able to get away without having any of these. It may be you can find a third-party package to add custom methods to support these features directly, or can write your own, but it may not be worth the bother for only a handful of uses of that feature.</p><p>It can be convenient to be able to use an in-memory SQLite database for running your tests locally, but it likely won&#x27;t be practical if you depend on any database-specific functionality, or for all the tables in a large application. As such I only tend to do this when working on packages, where there&#x27;s only a handful of tables to deal with.</p><h2>Summary</h2><p>Hopefully this article has helped dispel some of the appalling myths, misconceptions, and general confusion that seem to be widespread around using an ORM. If there&#x27;s one thing I hope you take away from this article it&#x27;s that the ORM isn&#x27;t a black box, but a layer of abstraction over your relational database, and if you don&#x27;t bear that in mind, it&#x27;s no surprise if you go on to experience performance problems. When used properly, an ORM is an extremely useful tool that is applicable to nearly every query you&#x27;re likely to write, and it will help you make your code more readable, maintainable, performant, type-safe and secure.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Dynamic image handling with Glide and GraphQL]]></title>
            <link>https://matthewdaly.co.uk/blog/2021/08/21/dynamic-image-handling-with-glide-and-graphql/</link>
            <guid>https://matthewdaly.co.uk/blog/2021/08/21/dynamic-image-handling-with-glide-and-graphql/</guid>
            <pubDate>Sat, 21 Aug 2021 16:20:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>I&#x27;ve used <a href="https://glide.thephpleague.com/">Glide</a> on several PHP projects in the past. It&#x27;s a great package that makes it really easy to dynamically generate images on the fly. For instance, if you need a particular image at both a thumbnail size and a full-screen size, it means you have the flexibility to request it at the correct size for any one part of the page. This can potentially save bandwidth since you never have to request a larger image than you technically need and scale it down with HTML attributes or CSS, nor do you have to take steps to generate thumbnails separately before they&#x27;re needed. Frontend developers can adjust their code to request exactly the version they need at any one time, and can even apply certain effects dynamically.</p><p>However, by default it&#x27;s a bit too open. A malicious user could request an image at an excessive size as part of a denial of service attack. For that reason, it&#x27;s considered good practice to set a maximum image size, and sign all requests so that you can be sure they&#x27;re authorized by your application. This works fine if your images are being requested somewhere you can sign them easily, such as in a Blade template. However, doing so in the context of a React or Vue application can potentially be much harder because they&#x27;re working on the front end and so can&#x27;t sign requests that are made dynamically in the same way, at least not without you exposing your application&#x27;s key to the front end, which would be <em>really</em> risky. An API endpoint can return URLs for pre-signed specific versions of the image, but that&#x27;s not as flexible as being able to adjust what you get back via query parameters on the fly.</p><p>I&#x27;m currently working on an application that uses GraphQL for the API, and for that I wanted to use Glide to enable <a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images">responsive images</a> and minimise the size of the payload. Having recently rewritten this blog in Gatsby, I&#x27;d had some exposure to the Sharp plugin, which allows you to query for an image at specific dimensions. It struck me that I could probably do something similar with GraphQL in the context of a Laravel application. Since the GraphQL queries that would return the image URLs and other data were being handled server side, they could in theory accept parameters for the required images, validate that the specified values were acceptable, and return a secure, signed URL for that image for consumption by the front end. Since the frontend was having to make an AJAX request to fetch the items to show anyway, it could request the URLs as part of the same AJAX request as the rest of the items on a page, then render the images along with the rest of the content. Here I&#x27;ll demonstrate how to do this.</p><p>The first thing to do is implement a controller for returning images via Glide. This will differ between frameworks so you&#x27;d need to check the Glide documentation, but a typical Laravel version would look something like this:</p><pre><code class="language-php" metastring="title=app/Http/Controllers/GlideController.php" title="app/Http/Controllers/GlideController.php">&lt;?php

namespace App\Http\Controllers;

use Illuminate\Contracts\Filesystem\Filesystem;
use Illuminate\Http\Request;
use League\Glide\Filesystem\FileNotFoundException;
use League\Glide\Responses\LaravelResponseFactory;
use League\Glide\ServerFactory;
use League\Glide\Signatures\SignatureException;
use League\Glide\Signatures\SignatureFactory;
use Symfony\Component\HttpFoundation\StreamedResponse;

final class GlideController extends Controller
{
    /**
     * Storage
     *
     * @var Filesystem
     */
    private $filesystem;

    public function __construct(Filesystem $filesystem)
    {
        $this-&gt;filesystem = $filesystem;
    }

    public function __invoke(Request $request, string $path): StreamedResponse
    {
        try {
            SignatureFactory::create((string)env(&#x27;APP_KEY&#x27;))-&gt;validateRequest(&quot;/images/&quot; . $path, $request-&gt;all());
            $server = ServerFactory::create([
                &#x27;response&#x27; =&gt; new LaravelResponseFactory($request),
                &#x27;source&#x27; =&gt; $this-&gt;filesystem-&gt;getDriver(),
                &#x27;cache&#x27; =&gt; $this-&gt;filesystem-&gt;getDriver(),
                &#x27;cache_path_prefix&#x27; =&gt; &#x27;.cache&#x27;,
                &#x27;base_url&#x27; =&gt; &#x27;&#x27;,
                &#x27;max_image_size&#x27; =&gt; 1000 * 1000,
            ]);
            return $server-&gt;getImageResponse(&quot;images/&quot; . $path, $request-&gt;all());
        } catch (SignatureException) {
            abort(403);
        } catch (FileNotFoundException) {
            abort(404);
        }
    }
}
</code></pre><p>Note that I&#x27;m using a <a href="https://laravel.com/docs/8.x/controllers#single-action-controllers">single action controller</a> here. I&#x27;ve found myself gravitating more and more towards these for certain use cases, and <a href="https://driesvints.com/blog/the-beauty-of-single-action-controllers/">I&#x27;m not the only one</a>. For me, the biggest benefit of these is probably more concise naming - if a controller does one thing and one thing only, and the class name adequately describes that, you end up naming it something generic, like <code>call()</code>. By making the controller a single callable, you don&#x27;t have to make that decision since it&#x27;s taken out of your hands (it must be <code>__invoke()</code>). I&#x27;m also a big fan of callable classes in general - they&#x27;re essentially closures on steroids since you can still pass dependencies to the constructor.</p><p>The <code>SignatureFactory</code> line is what handles validating the signature. It&#x27;s based on the app key, and checks that the path and all its parameters are correctly signed. If the signature isn&#x27;t valid, it will throw an exception, thus protecting the endpoint from requests that weren&#x27;t already approved. We also specify a cache location, and a maximum image size to help prevent mass-resize attacks.</p><p>You can then register this controller in the usual way:</p><pre><code class="language-php" metastring="title=routes/web.php" title="routes/web.php">    Route::get(&#x27;/images/{path}&#x27;, GlideController::class)-&gt;where(&#x27;path&#x27;, &#x27;.*&#x27;)-&gt;name(&#x27;glide&#x27;);
</code></pre><p>If the images aren&#x27;t going to be accessible to users who aren&#x27;t logged in, it makes sense to apply whatever authentication middleware you&#x27;re using to this route as well.</p><p>Now, depending on which GraphQL package you&#x27;re using, defining the schema may be different. In this case, I&#x27;m using <a href="https://lighthouse-php.com/">Lighthouse</a> and the schema definition for an Eloquent model with an image would look something like this:</p><pre><code class="language-graphql" metastring="title=graphql/schema.graphql" title="graphql/schema.graphql">enum ImageFormat {
    jpg
    pjpg
    webp
}

type Image {
    id: ID!
    caption: String!
    dynamicImage(
        width: Int @rules(apply: [&quot;numeric&quot;, &quot;max:1000&quot;])
        height: Int @rules(apply: [&quot;numeric&quot;, &quot;max:1000&quot;])
        quality: Int @rules(apply: [&quot;numeric&quot;, &quot;max:100&quot;])
        format: ImageFormat
    ): String @method
}
</code></pre><p>Here we&#x27;re specifying what parameters the <code>dynamicImage()</code> field accepts, as well as applying some of Laravel&#x27;s validation rules to the field to ensure it remains within acceptable ranges. We also use an enum to specify the supported image formats - these are actually limited to the options Glide provdes, but by specifying this as an enum, GraphQL tooling like GraphiQL can provide autocompletion for this parameter for a better developer experience when constructing queries. Note that we also use the <code>@method</code> directive to tell Lighthouse that this field maps to a method, not a property. If the method name differs from the field name, you would also need to specify that method name, eg <code>@method(name: &quot;myMethod&quot;)</code>.</p><p>Now, assuming your image was stored on the filesystem and the appropriate model field was called <code>image_path</code>, the method to retrieve the image URL on the model would look something like this:</p><pre><code class="language-php" metastring="title=app/Models/Item.php" title="app/Models/Item.php">use Illuminate\Support\Facades\URL;
use League\Glide\Urls\UrlBuilderFactory;

// Define model class...

    public function dynamicImage(int $width = null, int $height = null, int $quality = null, string $format = null): ?string
    {
        $builder = UrlBuilderFactory::create(&#x27;/images/&#x27;, (string)env(&#x27;APP_KEY&#x27;));
        return URL::to($builder-&gt;getUrl($this-&gt;image_path, [
            &#x27;w&#x27; =&gt; $width,
            &#x27;h&#x27; =&gt; $height,
            &#x27;q&#x27; =&gt; $quality,
            &#x27;fm&#x27; =&gt; $format,
        ]));
    }
</code></pre><p>Note that the parameters on the model must be specified in the same order as they are defined in the GraphQL schema for them to be lined up correctly, and must have the same names. I&#x27;ve only added the most obviously useful parameters here, namely height, width, quality and format, but if you need them there&#x27;s nothing stopping you from adding further parameters - just don&#x27;t forget to update the GraphQL schema to include them too.</p><p>We can then write GraphQL queries to call <code>dynamicImage()</code> with whatever parameters we wish to pass through, and will get back an appropriate URL in response. For instance, consider this query:</p><pre><code class="language-graphql" metastring="{6}">query {
  items {
    data {
      id
      caption
      dynamicImage(width: 400, height:400, quality: 100, format: webp)
    }
  }
}
</code></pre><p>Here we assume a query has been defined called <code>items</code> which returns all instances of the <code>Item</code> GraphQL type. This would return, for each instance of the <code>Item</code> model, the ID, caption and the URL for an image of 100% quality, 400x400 pixels, in WebP format. Please also note that none of these arguments to <code>dynamicImage()</code> are required - if you leave one out, Glide will use the default value.</p><p>By calling <code>dynamicImage()</code> separately with different aliases, we can even fetch multiple versions of the image. In this example, we fetch it at two different sizes:</p><pre><code class="language-graphql" metastring="{6-7}">query {
  items {
    data {
      id
      caption
      large_image: dynamicImage(width: 400, height:400, quality: 100, format: webp)
      small_image: dynamicImage(width: 200, height:200, quality: 100, format: webp)
    }
  }
}
</code></pre><p>Then, when rendering a component, you could use the <code>&lt;picture&gt;</code> and <code>&lt;source&gt;</code> elements to show different versions based on media queries, as in this example of a simple React component used to render individual instances of <code>Item</code>:</p><pre><code class="language-typescript" metastring="title=resources/js/components/Card.tsx {3-5}" title="resources/js/components/Card.tsx">const Card = (item) =&gt; (
  &lt;picture&gt;
    &lt;source media=&quot;{max-width: 768px}&quot; srcSet={item.small_image} /&gt;
    &lt;source media=&quot;{min-width: 769px}&quot; srcSet={item.large_image} /&gt;
    &lt;img src={item.small_image} alt={item.caption} /&gt;
  &lt;/picture&gt;
)
</code></pre><p>This enables us to serve responsive images that are appropriately sized for the current screen resolution. On mobile devices, which may not always have a connection as fast as a desktop or laptop, it also means we aren&#x27;t wasting bandwidth downloading images which are larger than necessary.</p><p>Along similar lines, you could fetch both WebP and JPEG versions of an image:</p><pre><code class="language-graphql" metastring="{6-7}">query {
  items {
    data {
      id
      caption
      jpeg_image: dynamicImage(width: 400, height: 400, quality: 100, format: jpeg)
      webp_image: dynamicImage(width: 400, height: 400, quality: 100, format: webp)
    }
  }
}
</code></pre><p>Then, we can use the WebP version of the image if the web browser supports it, falling back to JPEG if it doesn&#x27;t, by using the <code>&lt;picture&gt;</code> and <code>&lt;source&gt;</code> elements again in our React component:</p><pre><code class="language-typescript" metastring="title=resources/js/components/Card.tsx {3-4}" title="resources/js/components/Card.tsx">const Card = (item) =&gt; (
  &lt;picture&gt;
    &lt;source type=&quot;image/webp&quot; srcSet={item.webp_image} /&gt;
    &lt;img src={item.jpeg_image} alt={item.caption} /&gt;
  &lt;/picture&gt;
)
</code></pre><p>By doing this we aren&#x27;t forced to work with the lowest common denominator in terms of image formats. We can instead offer WebP to users whose browsers support it, without locking out users on older browsers.</p><p>This technique should be easy enough to apply to other PHP frameworks since Glide is fairly framework agnostic and there are GraphQL implementations for most frameworks. It should also be applicable in other languages - for example, while I&#x27;m not aware of a direct equivalent of Glide in Node.js, you could conceivably use <a href="https://sharp.pixelplumbing.com/">Sharp</a> as the basis of your own custom endpoint to serve up dynamic images based on query parameters, and then serve signed URLs for it via GraphQL.</p><p>Responsive images are something that&#x27;s often overlooked when trying to build a modern web app. An approach like this makes it an awful lot easier to serve appropriately-sized images on demand, without locking front-end devs into specific known dimensions that might not fit their use case.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Moving to Gatsby.js]]></title>
            <link>https://matthewdaly.co.uk/blog/2021/07/28/moving-to-gatsby-js/</link>
            <guid>https://matthewdaly.co.uk/blog/2021/07/28/moving-to-gatsby-js/</guid>
            <pubDate>Wed, 28 Jul 2021 14:36:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>If you&#x27;re visting this site directly, rather than via RSS, you may have noticed that I&#x27;ve updated the whole thing. It&#x27;s now built in Typescript, using Gatsby.js, and with Tailwind for the styling.</p><p>This site has been through several incarnations, going from flat HTML, to Wordpress, to Octopress, before in 2015 I settled on my own custom static site generator, built as a Grunt plugin. This worked fine and produced a performant, simple flat HTML site, but over the last few years I&#x27;d started to have issues with it:</p><ul><li>I haven&#x27;t used Grunt as a build tool for anything else since 2015, and it&#x27;s not as performant as more modern tools</li><li>I also don&#x27;t use Handlebars anymore, and that was the templating system I used for the site. These days React is my go-to and that makes a lot of dynamic functionality simpler</li><li>I also don&#x27;t use Bootstrap anymore, having dropped it for Tailwind, but that would be difficult to integrate with a Grunt-based workflow</li></ul><p>As such, for the last couple of years I&#x27;ve wanted to migrate off it for something more modern. Early on, Gatsby looked like the strongest candidate since it used React, offered a GraphQL-based abstraction layer for easier querying, had a rich ecosystem of plugins for common functionality, and was highly performant, but I made about three attempts to rebuild my site in it which petered out over time. Then, earlier this year I decided to start over and had a lot more success. I did struggle a bit getting a halfway decent design, and for a while pivoted to trying to build it with Next.js instead - this was ultimately abandoned because without the GraphQL abstraction layer, a lot of the querying became a real chore, but I did ultimately decide to port the appearance of that over to the Gatsby site.</p><p>One of the things that made this particular implementation the one that stuck was <a href="https://mdxjs.com/">MDX</a>. If you&#x27;re not familiar with it, it&#x27;s a superset of Markdown that lets you include JSX in your content, allowing for easy addition of reusable UI components within page and blog post content. Also, building it in Typescript was a good call - I&#x27;d been sticking with Flow for several years, but unfortunately it&#x27;s looking like Flow has fallen by the wayside and Typescript has become the only realistic typed solution for Javascript developers, so I felt it was time to adopt that. I&#x27;ve also enjoyed how easy Tailwind was to use (implementing dark mode was really simple), and have been able to implement JSON feeds as well as the standard RSS and Atom ones. Also, for the first time since I dropped Octopress, I now have the ability to add a title and highlight individual lines in code blocks.</p><p>I did have to make a few tough decisions about what to drop as well:</p><ul><li>These days I have a few issues with how AMP works, and the site is responsive and works well on mobile, so I decided to drop AMP entirely. The old AMP versions of pages redirect to their standard versions now.</li><li>Due to issues with creating dynamic RSS feeds in Gatsby.js, I decided not to port over the per-category RSS feeds.</li></ul><p>I have to admit, I&#x27;ve been neglecting posting on this site for a while, largely because I was working on this - it&#x27;s now nearly the end of July and this is my first post of the year - but now that I&#x27;ve got this done, I&#x27;m hoping I will be able to post more. One of my biggest motivations to do this has been that I&#x27;m particularly interested in doing more posts about React.js, and adopting MDX not only means that I can embed components in my posts, but I&#x27;ve also been able to integrate <code>react-live</code> into the site so I can embed editable examples in here too, which is potentially very powerful when demonstrating a concept.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Lightweight Laravel - deconstructing a full stack framework]]></title>
            <link>https://matthewdaly.co.uk/blog/2020/12/30/lightweight-laravel-deconstructing-a-full-stack-framework/</link>
            <guid>https://matthewdaly.co.uk/blog/2020/12/30/lightweight-laravel-deconstructing-a-full-stack-framework/</guid>
            <pubDate>Wed, 30 Dec 2020 17:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>Back when I used to work with Django, I read the book <a href="https://www.oreilly.com/library/view/lightweight-django/9781491946275/">Lightweight Django</a>, and it completely changed the way I thought about building web applications. For years I&#x27;d heard the same lines parroted about how Django was too large and bloated, and something like Flask was a better bet for many applications, and this book completely blew this misconception away. By demonstrating how it was possible to break the framework apart, use just what you need, and leave out what you don&#x27;t, it showed how I could benefit from my familiarity with Django, while making it more suitable for smaller applications.</p><p>Laravel, like Django, is a full stack framework, and is often subject to similar misconceptions about bloat. But just because the framework ships with all this stuff, doesn&#x27;t mean you&#x27;re obliged to use it all. If you know you aren&#x27;t going to need all of a framework&#x27;s functionality, there&#x27;s nothing stopping you getting rid of what you don&#x27;t need, or even replacing it with something else. In this article, I&#x27;ll show you how to apply the same methodology to a Laravel application to remove what you don&#x27;t need. As part of this, we&#x27;ll be building a simple placeholder image service. This was used in Lightweight Django as it&#x27;s a good example of an application that is completely stateless, and doesn&#x27;t need sessions or a database, so it&#x27;s often seen as a bad fit for a full stack framework. Since the same applies here, it&#x27;s a good example for us too.</p><h2>Getting started</h2><p>Run the following command in the shell to create a new Laravel application:</p><pre><code class="language-bash">$ composer create-project --prefer-dist laravel/laravel lightweight-laravel
</code></pre><p>What this actually does is as follows:</p><ul><li>Resolve the latest release of the package <code>laravel/laravel</code> that will work on your system</li><li>Copy it from the <a href="https://github.com/laravel/laravel">repository</a> to the specified location</li><li>Carry out any post-install scripts specified, such as creating the <code>.env</code> file and generating a key</li></ul><p>However, that&#x27;s just a standardised boilerplate for Laravel applications. Most of the functionality of the framework is in the package <code>laravel/framework</code>, which is included as a dependency in your <code>composer.json</code>. This makes sense, because by keeping as much of the actual framework out of the starter boilerplate and in a separate repository, it minimises the work required to update the application to a new version. It also means you can strip that boilerplate down to remove references to things you don&#x27;t need, and even create your own custom boilerplates to save you work in future.</p><h2>Stripping down the boilerplate</h2><p>Let&#x27;s start stripping out the things we don&#x27;t need. Since our application is stateless, we have no need whatsoever of a database, so we can delete the <code>app/Models</code> and <code>database</code> folders. We&#x27;ll want to support Redis for the cache, so we can&#x27;t delete the file <code>config/database.php</code>, but we can remove any references to the database other than Redis from that file. We can delete some other files from the <code>config/</code> folder, namely <code>auth.php</code>, <code>broadcasting.php</code>, <code>filesystems.php</code>, <code>mail.php</code>, <code>queue.php</code>, <code>services.php</code> and <code>session.php</code>.</p><p>We also don&#x27;t need a lot of the middleware that ships with Laravel. If you go into the file <code>app/Http/Kernel.php</code> you&#x27;ll see that it assigns some middleware as global, some to the <code>web</code> and <code>api</code> groups, and some as optional route middleware. In this file:</p><ul><li>We don&#x27;t need to make any POST requests to this application, so we can lose the <code>ValidatePostSize</code> middleware from the global middleware entirely</li><li>The <code>web</code> group relates to cookies, sessions, CSRF, authentication and handling routing with substitute bindings. Since we don&#x27;t need any of that we can empty this group entirely</li><li>The <code>auth</code>, <code>auth.basic</code>, <code>can</code>, <code>guest</code>, <code>password.confirm</code>, and <code>verified</code> route middleware is also surplus to requirements and can go</li></ul><p>As this change is a bit fiddly, here&#x27;s a patch, which may be easier to read:</p><pre><code class="language-diff">From 6bc87e9602e839d5635963b6d740279b2dbcf16b Mon Sep 17 00:00:00 2001
From: Matthew Daly &lt;Matthew Daly 450801+matthewbdaly@users.noreply.github.com&gt;
Date: Wed, 30 Dec 2020 11:54:56 +0000
Subject: [PATCH] Removed unwanted middleware

---
 app/Http/Kernel.php | 14 --------------
 1 file changed, 14 deletions(-)

diff --git a/app/Http/Kernel.php b/app/Http/Kernel.php
index 30020a5..10e150d 100644
--- a/app/Http/Kernel.php
+++ b/app/Http/Kernel.php
@@ -18,7 +18,6 @@ class Kernel extends HttpKernel
         \App\Http\Middleware\TrustProxies::class,
         \Fruitcake\Cors\HandleCors::class,
         \App\Http\Middleware\PreventRequestsDuringMaintenance::class,
-        \Illuminate\Foundation\Http\Middleware\ValidatePostSize::class,
         \App\Http\Middleware\TrimStrings::class,
         \Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull::class,
     ];
@@ -30,13 +29,6 @@ class Kernel extends HttpKernel
      */
     protected $middlewareGroups = [
         &#x27;web&#x27; =&gt; [
-            \App\Http\Middleware\EncryptCookies::class,
-            \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
-            \Illuminate\Session\Middleware\StartSession::class,
-            // \Illuminate\Session\Middleware\AuthenticateSession::class,
-            \Illuminate\View\Middleware\ShareErrorsFromSession::class,
-            \App\Http\Middleware\VerifyCsrfToken::class,
-            \Illuminate\Routing\Middleware\SubstituteBindings::class,
         ],

         &#x27;api&#x27; =&gt; [
@@ -53,14 +45,8 @@ class Kernel extends HttpKernel
      * @var array
      */
     protected $routeMiddleware = [
-        &#x27;auth&#x27; =&gt; \App\Http\Middleware\Authenticate::class,
-        &#x27;auth.basic&#x27; =&gt; \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
         &#x27;cache.headers&#x27; =&gt; \Illuminate\Http\Middleware\SetCacheHeaders::class,
-        &#x27;can&#x27; =&gt; \Illuminate\Auth\Middleware\Authorize::class,
-        &#x27;guest&#x27; =&gt; \App\Http\Middleware\RedirectIfAuthenticated::class,
-        &#x27;password.confirm&#x27; =&gt; \Illuminate\Auth\Middleware\RequirePassword::class,
         &#x27;signed&#x27; =&gt; \Illuminate\Routing\Middleware\ValidateSignature::class,
         &#x27;throttle&#x27; =&gt; \Illuminate\Routing\Middleware\ThrottleRequests::class,
-        &#x27;verified&#x27; =&gt; \Illuminate\Auth\Middleware\EnsureEmailIsVerified::class,
     ];
 }
--
2.28.0

</code></pre><p>These changes also mean a lot of the service providers and facades are now redundant and can be removed from the application. If you go into <code>config/app.php</code> you can remove <code>AuthServiceProvider</code>, <code>BroadcastServiceProvider</code>, <code>CookieServiceProvider</code>, <code>MailServiceProvider</code>, <code>NotificationServiceProvider</code>, <code>PaginationServiceProvider</code>, <code>PasswordResetServiceProvider</code>, <code>SessionServiceProvider</code> and <code>TranslationServiceProvider</code> from the providers section, as well as the commented-out local <code>BroadcastServiceProvider</code>. You can also delete the facades for <code>Auth</code>, <code>Cookie</code>, <code>DB</code>, <code>Eloquent</code>, <code>Gate</code>, <code>Lang</code>, <code>Mail</code>, <code>Notification</code>, <code>Password</code>, <code>Queue</code>, <code>Schema</code>, <code>Session</code>, and <code>Storage</code>.</p><p>Again, here&#x27;s a patch of the required changes:</p><pre><code class="language-diff">From 66be3b836706ef488b890cdae6e97d4fc6195dd6 Mon Sep 17 00:00:00 2001
From: Matthew Daly &lt;Matthew Daly 450801+matthewbdaly@users.noreply.github.com&gt;
Date: Wed, 30 Dec 2020 12:10:25 +0000
Subject: [PATCH] Removed unused service providers and facades

---
 config/app.php | 26 --------------------------
 1 file changed, 26 deletions(-)

diff --git a/config/app.php b/config/app.php
index 2a2f0eb..b7a38c8 100644
--- a/config/app.php
+++ b/config/app.php
@@ -139,26 +139,17 @@ return [
         /*
          * Laravel Framework Service Providers...
          */
-        Illuminate\Auth\AuthServiceProvider::class,
-        Illuminate\Broadcasting\BroadcastServiceProvider::class,
         Illuminate\Bus\BusServiceProvider::class,
         Illuminate\Cache\CacheServiceProvider::class,
         Illuminate\Foundation\Providers\ConsoleSupportServiceProvider::class,
-        Illuminate\Cookie\CookieServiceProvider::class,
         Illuminate\Database\DatabaseServiceProvider::class,
         Illuminate\Encryption\EncryptionServiceProvider::class,
         Illuminate\Filesystem\FilesystemServiceProvider::class,
         Illuminate\Foundation\Providers\FoundationServiceProvider::class,
         Illuminate\Hashing\HashServiceProvider::class,
-        Illuminate\Mail\MailServiceProvider::class,
-        Illuminate\Notifications\NotificationServiceProvider::class,
-        Illuminate\Pagination\PaginationServiceProvider::class,
         Illuminate\Pipeline\PipelineServiceProvider::class,
         Illuminate\Queue\QueueServiceProvider::class,
         Illuminate\Redis\RedisServiceProvider::class,
-        Illuminate\Auth\Passwords\PasswordResetServiceProvider::class,
-        Illuminate\Session\SessionServiceProvider::class,
-        Illuminate\Translation\TranslationServiceProvider::class,
         Illuminate\Validation\ValidationServiceProvider::class,
         Illuminate\View\ViewServiceProvider::class,

@@ -170,9 +161,6 @@ return [
          * Application Service Providers...
          */
         App\Providers\AppServiceProvider::class,
-        App\Providers\AuthServiceProvider::class,
-        // App\Providers\BroadcastServiceProvider::class,
-        App\Providers\EventServiceProvider::class,
         App\Providers\RouteServiceProvider::class,

     ],
@@ -193,35 +181,21 @@ return [
         &#x27;App&#x27; =&gt; Illuminate\Support\Facades\App::class,
         &#x27;Arr&#x27; =&gt; Illuminate\Support\Arr::class,
         &#x27;Artisan&#x27; =&gt; Illuminate\Support\Facades\Artisan::class,
-        &#x27;Auth&#x27; =&gt; Illuminate\Support\Facades\Auth::class,
         &#x27;Blade&#x27; =&gt; Illuminate\Support\Facades\Blade::class,
         &#x27;Broadcast&#x27; =&gt; Illuminate\Support\Facades\Broadcast::class,
         &#x27;Bus&#x27; =&gt; Illuminate\Support\Facades\Bus::class,
         &#x27;Cache&#x27; =&gt; Illuminate\Support\Facades\Cache::class,
         &#x27;Config&#x27; =&gt; Illuminate\Support\Facades\Config::class,
-        &#x27;Cookie&#x27; =&gt; Illuminate\Support\Facades\Cookie::class,
         &#x27;Crypt&#x27; =&gt; Illuminate\Support\Facades\Crypt::class,
-        &#x27;DB&#x27; =&gt; Illuminate\Support\Facades\DB::class,
-        &#x27;Eloquent&#x27; =&gt; Illuminate\Database\Eloquent\Model::class,
-        &#x27;Event&#x27; =&gt; Illuminate\Support\Facades\Event::class,
         &#x27;File&#x27; =&gt; Illuminate\Support\Facades\File::class,
-        &#x27;Gate&#x27; =&gt; Illuminate\Support\Facades\Gate::class,
         &#x27;Hash&#x27; =&gt; Illuminate\Support\Facades\Hash::class,
         &#x27;Http&#x27; =&gt; Illuminate\Support\Facades\Http::class,
-        &#x27;Lang&#x27; =&gt; Illuminate\Support\Facades\Lang::class,
         &#x27;Log&#x27; =&gt; Illuminate\Support\Facades\Log::class,
-        &#x27;Mail&#x27; =&gt; Illuminate\Support\Facades\Mail::class,
-        &#x27;Notification&#x27; =&gt; Illuminate\Support\Facades\Notification::class,
-        &#x27;Password&#x27; =&gt; Illuminate\Support\Facades\Password::class,
-        &#x27;Queue&#x27; =&gt; Illuminate\Support\Facades\Queue::class,
         &#x27;Redirect&#x27; =&gt; Illuminate\Support\Facades\Redirect::class,
         // &#x27;Redis&#x27; =&gt; Illuminate\Support\Facades\Redis::class,
         &#x27;Request&#x27; =&gt; Illuminate\Support\Facades\Request::class,
         &#x27;Response&#x27; =&gt; Illuminate\Support\Facades\Response::class,
         &#x27;Route&#x27; =&gt; Illuminate\Support\Facades\Route::class,
-        &#x27;Schema&#x27; =&gt; Illuminate\Support\Facades\Schema::class,
-        &#x27;Session&#x27; =&gt; Illuminate\Support\Facades\Session::class,
-        &#x27;Storage&#x27; =&gt; Illuminate\Support\Facades\Storage::class,
         &#x27;Str&#x27; =&gt; Illuminate\Support\Str::class,
         &#x27;URL&#x27; =&gt; Illuminate\Support\Facades\URL::class,
         &#x27;Validator&#x27; =&gt; Illuminate\Support\Facades\Validator::class,
--
2.28.0

</code></pre><p>There are a few service providers that ideally we&#x27;d strip out but are tightly integrated into the framework. For instance, the database and queue service providers are both used by some Artisan commands, and it&#x27;s not very practical to disable only those commands, so removing them will stop Artisan from working. If you don&#x27;t mind running the development server manually, you can go ahead and remove these.</p><h2>Building the application</h2><p>Now, let&#x27;s set out how our application will work. We will have two routes:</p><ul><li>A route that accepts width and height parameters in the route itself, and responds with a PNG response sized accordingly</li><li>A route that returns a simple HTML homepage</li></ul><p>You&#x27;ve no doubt seen various novelty placeholder sites like <a href="http://placekitten.com/">placekitten.com</a> for use in web projects, and this will be similar to that. We&#x27;ll use a simple black image with the dimensions in white text, but you should be able to use this as the basis of a more sophisticated placeholder service, such as if you wanted to use branded images for a particular client.</p><p>Since the home page will be fairly straightforward, let&#x27;s do that first. Delete the existing <code>resources/views/welcome.blade.php</code> file and save this to <code>resources/views/home.blade.php</code>:</p><pre><code class="language-html" metastring="title=resources/views/home.blade.php" title="resources/views/home.blade.php">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Laravel Placeholder Images&lt;/title&gt;
    &lt;link href=&quot;{{ mix(&#x27;css/app.css&#x27;) }}&quot; rel=&quot;stylesheet&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Laravel Placeholder Images&lt;/h1&gt;
    &lt;p&gt;This server can be used for serving placeholder
    images for any web page.&lt;/p&gt;
    &lt;p&gt;To request a placeholder image of a given width and height
    simply include an image with the source pointing to
    &lt;b&gt;/image/&amp;lt;width&amp;gt;x&amp;lt;height&amp;gt;/&lt;/b&gt;
    on this server such as:&lt;/p&gt;
    &lt;pre&gt;
        &amp;lt;img src=&quot;{{ $example }}&quot; &amp;gt;
    &lt;/pre&gt;
    &lt;h2&gt;Examples&lt;/h2&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;img src=&quot;{{{ route(&#x27;placeholder&#x27;, [&#x27;width&#x27; =&gt; 50, &#x27;height&#x27; =&gt; 50]) }}}&quot;&gt;&lt;/li&gt;
        &lt;li&gt;&lt;img src=&quot;{{{ route(&#x27;placeholder&#x27;, [&#x27;width&#x27; =&gt; 100, &#x27;height&#x27; =&gt; 50]) }}}&quot;&gt;&lt;/li&gt;
        &lt;li&gt;&lt;img src=&quot;{{{ route(&#x27;placeholder&#x27;, [&#x27;width&#x27; =&gt; 50, &#x27;height&#x27; =&gt; 100]) }}}&quot;&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>Note we&#x27;re using the <code>route()</code> helper to add some example images, even though it&#x27;s not in place yet. Add this route to your <code>routes/web.php</code> as well:</p><pre><code class="language-php" metastring="title=routes/web.php" title="routes/web.php">Route::get(&#x27;/&#x27;, function () {
    return view(&#x27;home&#x27;, [
        &#x27;example&#x27; =&gt; route(&#x27;placeholder&#x27;, [&#x27;width&#x27; =&gt; 50, &#x27;height&#x27; =&gt; 50]),
    ]);
});
</code></pre><p>Again, note that we&#x27;re using the <code>route()</code> helper to get the URL for the placeholder image. Next, we need to create the outline of the route for getting the placeholders:</p><pre><code class="language-php" metastring="title=routes/web.php" title="routes/web.php">Route::get(&#x27;/placeholder/{width}x{height}&#x27;, function (int $width, int $height) {
})-&gt;where([&#x27;width&#x27; =&gt; &#x27;[0-9]+&#x27;, &#x27;height&#x27; =&gt; &#x27;[0-9]+&#x27;])
    -&gt;name(&#x27;placeholder&#x27;);
</code></pre><p>Due to the limited scope of this application, we won&#x27;t bother with full controllers, but you can add them if you wish. Note we&#x27;ve specified the name <code>placeholder</code> and set a regex to validate the <code>width</code> and <code>height</code> parameters.</p><p>Now let&#x27;s populate the callback to generate a PNG file.</p><pre><code class="language-php" metastring="title=routes/web.php {2-13}" title="routes/web.php">Route::get(&#x27;/placeholder/{width}x{height}&#x27;, function (int $width, int $height) {
    if (!$img = imagecreatetruecolor($width, $height)) {
        abort();
    }
    $textColour = imagecolorallocate($img, 255, 255, 255);
    imagestring($img, 1, 5, 5, &quot;$width X $height&quot;, $textColour);
    ob_start();
    imagepng($img);
    $file = ob_get_contents();
    ob_end_clean();
    return response()-&gt;make($file, 200, [
        &#x27;Content-type&#x27; =&gt; &#x27;image/png&#x27;
    ]);
})-&gt;where([&#x27;width&#x27; =&gt; &#x27;[0-9]+&#x27;, &#x27;height&#x27; =&gt; &#x27;[0-9]+&#x27;])
    -&gt;name(&#x27;placeholder&#x27;);
</code></pre><p>We&#x27;ll also add some very basic CSS to the provided CSS file:</p><pre><code class="language-css" metastring="title=resources/css/app.css" title="resources/css/app.css">body {
    text-align: center;
}

ul {
    list-type: none;
}

li {
    display: inline-block;
}
</code></pre><p>Don&#x27;t forget to build this with <code>npm install &amp;&amp; npm run production</code> too.</p><p>If you now run <code>php artisan serve</code> you should be able to see that it works - the homepage renders, and the embedded images are pulled in OK. However, there are three potential issues:</p><ul><li>The images themselves are regenerated each time. Since they never change, it&#x27;s a no-brainer to cache them indefinitely for the best performance, and if we do need to change them in the future we can just flush the cache to resolve this</li><li>Similarly, we should use ETags to allow the application to tell the browser when the image has changed</li><li>There&#x27;s no limit on how large images can be, so a malicious user could request a huge image to break the system</li></ul><p>Let&#x27;s tackle these in order. First, let&#x27;s create some middleware to handle the caching:</p><pre><code class="language-php" metastring="title=app/Http/Middleware/CacheImages.php" title="app/Http/Middleware/CacheImages.php">&lt;?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Cache;

final class CacheImages
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle(Request $request, Closure $next)
    {
        $key = sprintf(&quot;%d.%d&quot;, $request-&gt;width, $request-&gt;height);
        return Cache::rememberForever($key, function () use ($next, $request) {
            return $next($request);
        });
    }
}
</code></pre><p>We construct a cache key from the request width and height, and use the <code>Cache::rememberForever()</code> method to cache the response. We then register this middleware as route middleware in <code>app/Http/Kernel.php</code>:</p><pre><code class="language-php" metastring="title=app/Http/Kernel.php {5}" title="app/Http/Kernel.php">    protected $routeMiddleware = [
        &#x27;cache.headers&#x27; =&gt; \Illuminate\Http\Middleware\SetCacheHeaders::class,
        &#x27;signed&#x27; =&gt; \Illuminate\Routing\Middleware\ValidateSignature::class,
        &#x27;throttle&#x27; =&gt; \Illuminate\Routing\Middleware\ThrottleRequests::class,
        &#x27;cache.images&#x27; =&gt; \App\Http\Middleware\CacheImages::class,
    ];
</code></pre><p>And apply it to the image route:</p><pre><code class="language-php" metastring="title=routes/web.php {16}" title="routes/web.php">Route::get(&#x27;/placeholder/{width}x{height}&#x27;, function (int $width, int $height) {
    if (!$img = imagecreatetruecolor($width, $height)) {
        abort();
    }
    $textColour = imagecolorallocate($img, 255, 255, 255);
    imagestring($img, 1, 5, 5, &quot;$width X $height&quot;, $textColour);
    ob_start();
    imagepng($img);
    $file = ob_get_contents();
    ob_end_clean();
    return response()-&gt;make($file, 200, [
        &#x27;Content-type&#x27; =&gt; &#x27;image/png&#x27;
    ]);
})-&gt;where([&#x27;width&#x27; =&gt; &#x27;[0-9]+&#x27;, &#x27;height&#x27; =&gt; &#x27;[0-9]+&#x27;])
  -&gt;name(&#x27;placeholder&#x27;)
  -&gt;middleware(&#x27;cache.images&#x27;);
</code></pre><p>Next, let&#x27;s set ETags on our images. Laravel comes with the <code>cache.headers</code> middleware, which we can easily wrap around our placeholder route:</p><pre><code class="language-php" metastring="title=routes/web.php {1,18}" title="routes/web.php">Route::middleware(&#x27;cache.headers:public;etag&#x27;)-&gt;group(function () {
    Route::get(&#x27;/placeholder/{width}x{height}&#x27;, function (int $width, int $height) {
        if (!$img = imagecreatetruecolor($width, $height)) {
            abort();
        }
        $textColour = imagecolorallocate($img, 255, 255, 255);
        imagestring($img, 1, 5, 5, &quot;$width X $height&quot;, $textColour);
        ob_start();
        imagepng($img);
        $file = ob_get_contents();
        ob_end_clean();
        return response()-&gt;make($file, 200, [
            &#x27;Content-type&#x27; =&gt; &#x27;image/png&#x27;
        ]);
    })-&gt;where([&#x27;width&#x27; =&gt; &#x27;[0-9]+&#x27;, &#x27;height&#x27; =&gt; &#x27;[0-9]+&#x27;])
      -&gt;name(&#x27;placeholder&#x27;)
      -&gt;middleware(&#x27;cache.images&#x27;);
});
</code></pre><p>Finally, let&#x27;s handle the dimensions issue. Again, this is something that is probably best handled in middleware since that way it can be rejected before the point it gets to the route handler. All we need to do is to check to see if the width and height parameters exceed the intended value, and throw an error in the middleware:</p><pre><code class="language-php" metastring="title=app/Http/Middleware/ValidateImageDimensions.php" title="app/Http/Middleware/ValidateImageDimensions.php">&lt;?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Validation\ValidationException;

final class ValidateImageDimensions
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle(Request $request, Closure $next)
    {
        if ($request-&gt;width &gt; 2000 || $request-&gt;height &gt; 2000) {
            abort(422, &#x27;Height and width cannot exceed 2000 pixels&#x27;);
        }
        return $next($request);
    }
}
</code></pre><p>Register this middleware in <code>app/Http/Kernel.php</code>:</p><pre><code class="language-php" metastring="title=app/Http/Kernel.php {5}" title="app/Http/Kernel.php">    protected $routeMiddleware = [
        &#x27;cache.headers&#x27; =&gt; \Illuminate\Http\Middleware\SetCacheHeaders::class,
        &#x27;signed&#x27; =&gt; \Illuminate\Routing\Middleware\ValidateSignature::class,
        &#x27;throttle&#x27; =&gt; \Illuminate\Routing\Middleware\ThrottleRequests::class,
        &#x27;cache.images&#x27; =&gt; \App\Http\Middleware\CacheImages::class,
        &#x27;validate.images&#x27; =&gt; \App\Http\Middleware\ValidateImageDimensions::class,
    ];
</code></pre><p>And apply it to the image route:</p><pre><code class="language-php" metastring="title=routes/web.php {17}" title="routes/web.php">Route::middleware(&#x27;cache.headers:public;etag&#x27;)-&gt;group(function () {
    Route::get(&#x27;/placeholder/{width}x{height}&#x27;, function (int $width, int $height) {
        if (!$img = imagecreatetruecolor($width, $height)) {
            abort();
        }
        $textColour = imagecolorallocate($img, 255, 255, 255);
        imagestring($img, 1, 5, 5, &quot;$width X $height&quot;, $textColour);
        ob_start();
        imagepng($img);
        $file = ob_get_contents();
        ob_end_clean();
        return response()-&gt;make($file, 200, [
            &#x27;Content-type&#x27; =&gt; &#x27;image/png&#x27;
        ]);
    })-&gt;where([&#x27;width&#x27; =&gt; &#x27;[0-9]+&#x27;, &#x27;height&#x27; =&gt; &#x27;[0-9]+&#x27;])
      -&gt;name(&#x27;placeholder&#x27;)
      -&gt;middleware([&#x27;validate.images&#x27;, &#x27;cache.images&#x27;]);
});
</code></pre><p>And we&#x27;re done! We now have a basic, but functional, stateless Laravel application that&#x27;s been stripped of a lot of the unnecessary functionality. There are a few further changes that could be made to expand this if necessary, such as:</p><ul><li>Amend the project to allow requesting different image formats using an additional route parameter (hint - you&#x27;ll want to use something like <a href="http://image.intervention.io/">Intervention for this</a>)</li><li>Serve different images, either by using one as a starting template so they are all branded the same, or specifying one from several options in the URL, such as with <a href="https://www.placecage.com/">PlaceCage</a></li></ul><p>However, I will leave these as an exercise for the reader. The code for this project is available on <a href="https://github.com/matthewbdaly/lightweight-laravel">Github</a> if you get stuck at any point.</p><p>Hopefully, this article has given you some food for thought about how you can use Laravel for applications you might have previously considered too small to use it for. Don&#x27;t worry too much about removing something that you need to add later - version control means you can always retrieve it if it turns out you do need it later. I&#x27;d also add that potentially the same approach can be applied to other full stack PHP frameworks, though you&#x27;ll have to do some exploring on your own to determine this.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[What I want in a PHP CMS]]></title>
            <link>https://matthewdaly.co.uk/blog/2020/09/28/what-i-want-in-a-php-cms/</link>
            <guid>https://matthewdaly.co.uk/blog/2020/09/28/what-i-want-in-a-php-cms/</guid>
            <pubDate>Mon, 28 Sep 2020 14:50:48 GMT</pubDate>
            <content:encoded><![CDATA[<p>I maintain a custom PHP legacy CMS for a client, and have also been building a micro-CMS as a learning project, so I&#x27;ve spent quite a lot of time in the last few years thinking about how content should be managed, and how applications to manage it should work.</p><p>I&#x27;ve also at least tinkered with a few different content management systems down the years, and I&#x27;ve found it depressing how many times Wordpress has been the default choice, despite it being probably the worst CMS I&#x27;ve ever had the gross misfortune to use. The argument that &quot;it&#x27;s easy to install and use&quot; doesn&#x27;t really hold water given that in my experience most users setting up a new Wordpress site don&#x27;t go through the five-minute install, but use their shared hosting provider&#x27;s setup wizard, which typically also supports several other content management systems. Also, it just does not make sense to optimise a short five minute install that will never be repeated for that site over the rest of the workflow for maintaining the site, possibly for years - I&#x27;d rather have something that takes a bit more time to do the initial set up, but is easier to maintain.</p><p>So, what do I want in a PHP CMS? Here&#x27;s my thoughts on my ideal CMS solution.</p><h2>Managed entirely with Composer</h2><p>Creating a new site using a CMS should be as simple as running something like the following command:</p><pre><code class="language-bash">$ composer create-project --prefer-dist my/cms newsite
</code></pre><p>And updating it should be as simple as running the following:</p><pre><code class="language-bash">$ composer update
</code></pre><p>Installing a plugin should be a case of running this:</p><pre><code class="language-bash">$ composer require my/plugin-foo
</code></pre><p>It should then be possible to activate the plugin simply by listing it in a config file.</p><p>As far as possible, <em>all</em> of the functionality of the CMS should be contained in a single &quot;core&quot; package, and plugins should be their own Composer packages that can be installed, and then switched on and off in a simple config file. The initial creation step should be a case of checking out a boilerplate that contains only the absolute minimum - a front controller, a starting configuration, front end tooling, and some views - and gets the rest of the functionality from the core package.</p><h2>Allow creating custom site boilerplates</h2><p>It should be possible to create and publish alternative boilerplates.</p><p>For instance, if a CMS provides a default starting boilerplate that ships with Bootstrap, VueJS and Laravel Mix, I should be able to fork it, replace Bootstrap with Tailwind and Vue with React, and then use my version for future projects without having to spend a lot of time maintaining the fork.</p><p>Similarly, if there are certain plugins I use all the time, it should be possible to include those plugins as dependencies in my <code>composer.json</code> so that when I create a new project from my boilerplate, they&#x27;re present right from the start and I don&#x27;t have to faff around downloading and configuring them manually.</p><h2>Plugin API should work like a framework</h2><p>The best practices we&#x27;ve all spent years learning shouldn&#x27;t go out the window when working with a CMS. A good CMS should feel familiar if you&#x27;ve got some experience working in MVC frameworks, and it should embrace PSR standards. Adding a route should largely be a matter of writing a controller, mapping it to a route, and adding a view file, just as it would be in a framework</p><p>There&#x27;s always going to be some things that need to be CMS-specific, because registering things like routes is more complex in a general purpose CMS than a custom web app as they can be defined in multiple arbitrary places. These can be handled by triggering events at various points in the CMS application&#x27;s lifecycle, so that plugin authors can set up listeners to do things such as register routes, add new view helpers and so on.</p><h2>Focused exclusively on content, not presentation</h2><p>I&#x27;m increasingly convinced that the ability to amend presentation in a CMS is a misfeature. The purpose of a CMS is to manage content, not presentation, and making it able to amend presentation potentially gives unskilled site owners enough rope to hang themselves with, while making it actively harder for us devs.</p><p>I&#x27;ve certainly seen enough sites that a client has completely messed up after being given access to change the presentation in Wordpress, and because it&#x27;s stored in the database it&#x27;s not possible to roll back the changes easily the way it would be if the styling was stored in version control. And it&#x27;s definitely quicker for an experienced front end developer to edit a CSS file than to use Wordpress&#x27;s own tools for amending styling.</p><h2>Use a proper templating system</h2><p>As a templating language, PHP <em>sucks</em>:</p><ul><li>It&#x27;s too easy to overlook escaping variables properly</li><li>Handling partials is difficult</li><li>There&#x27;s always the temptation to put in more logic than is advisable in the view layer, especially when deadlines are tight</li></ul><p>Using a dedicated templating language, rather than a full programming language, in the view layer, means that entire classes of issues can be completely eradicated from the layer of the application that the developers who work with the CMS have the most dealings with. Developers are forced to move more complex logic into dedicated helpers, and can&#x27;t just leave it in the template &quot;until we have time to clear it up&quot;, which is often never.</p><p>Twig is solid, reliable, fast, easy to extend, and similar enough to other templating languages such as Handlebars and Django&#x27;s templates that if you&#x27;ve used any of those you can adapt easily, and it should probably be your first choice. Blade is also a solid choice, and if you want something whose syntax is not dissimilar to PHP you should probably consider Plates.</p><h2>Configuration with version control in mind</h2><p>Wordpress does this particularly badly because it actively encourages storing sensitive data, such as database credentials, in a PHP file (which is then kept in the web root...). A good, solid way to store configuration details in PHP is to store generic details (for instance, a list of the active plugins, which will be the same for production and the local copy developers run) for that project in either a YAML or PHP file, and store install-specific details in either a <code>.env</code> file, or as environment variables.</p><h2>Custom content types</h2><p>It should be easy to create a new content type, and define specific fields for that content type. For instance, if I&#x27;m building a recipe site, I should be able to define a Recipe type that has the following attributes:</p><ul><li>Ingredients</li><li>Cover image</li><li>Title</li><li>Method</li></ul><p>Then all Recipe instances should have those attributes, and it shouldn&#x27;t be necessary to bastardise a different content type to make it work properly. It should also be possible to lock down the ability to create custom content types so it&#x27;s either limited to admins, or they&#x27;re defined in code, so end users can&#x27;t create arbitrary content types.</p><h2>Custom taxonomies</h2><p>It should be possible to define your own custom taxonomies for content. Continuing the Recipe example above, we should be able to define three sorts of taxonomy:</p><ul><li>Dietary requirements (eg vegetarian, vegan, gluten-free etc)</li><li>Meal (eg breakfast, lunch, dinner, snacks)</li><li>Region (eg Indian, Chinese, Italian)</li></ul><p>A taxonomy should be appropriately named, and again it shouldn&#x27;t be necessary to abuse generic categories and tags to categorise content. As with the content types, it should also be possible to lock them down.</p><h2>A better solution than rich text for managing content</h2><p>Rich text is not a great solution for more complex page layouts, and tends to be abused horribly to do all sorts of things. There&#x27;s a tendency to dump things like snippets for Google Maps, tables, galleries, Javascript widgets and many more into rich text. This means that it also loses the semantic value of the content - rather than being a paragraph, then a map of the local area, then a photo carousel, then another paragraph, it&#x27;s just a single blob of text. This can&#x27;t be easily migrated to another solution if, say, you decide to swap Google Maps for Open Streetmap, and change one carousel for another, without going through and manually replacing every map and carousel, which is a chore.</p><p>Wagtail isn&#x27;t a PHP CMS, but <a href="https://torchbox.com/blog/rich-text-fields-and-faster-horses/">it has an interesting approach to rich text handling</a> for complex content, inspired by <a href="https://madebymany.github.io/sir-trevor-js/">Sir Trevor</a>, based around blocks of different types. The Gutenberg editor in Wordpress 5.0 and up isn&#x27;t a million miles away from this, either. For simpler sites, it&#x27;s probably better to limit users to a Markdown editor and add helpers for adding more complex functionality directly in the template, such as a gallery helper.</p><h2>A decent command-line runner</h2><p>There are always going to be certain tasks that are best done from the command line. A decent CMS should have a command line tool that:</p><ul><li>Allows appropriate admin tasks, such as going into maintenance mode and flushing caches, to be done from the command line</li><li>Can be easily extended by plugin authors to add their own commands</li><li>Assists developers when working locally, such as by generating boilerplate when necessary (so, for instance, you can run a command to generate the skeleton for a new plugin)</li></ul><p>There&#x27;s no excuse not to do this when building a CMS. Symfony&#x27;s console component is solid, easy to work with, and a good base for whatever commands you need to write.</p><h2>Headless as an option</h2><p>The rise of headless CMS&#x27;s, both as a service and as software packages, hasn&#x27;t surprised me. Nowadays it&#x27;s quite common to have to publish the same content to multiple channels, which might be one or more websites, as well as mobile apps, and it makes sense to be able to centralise that content in one place rather than have to copy it in some fashion.</p><p>It&#x27;s therefore very useful to have an API that can retrieve that content for republishing. The same API can also be used with Javascript libraries like React and Vue to build sophisticated frontends that consume that data.</p><h2>Which solutions do this best?</h2><p>You&#x27;ll probably have got the idea at this point that Wordpress isn&#x27;t my first choice. It was created in a different era, and hasn&#x27;t kept up well compared to many of its contemporaries, and there are many technical issues with it that are at this point effectively impossible to ever fix. For instance, you could potentially store the post meta in the same table as the rest of the post data by using a JSON field in current versions of MySQL, which would make it more performant, but it seems unlikely it could ever be migrated across to use that solution.</p><p>Frustratingly, its mindshare means it&#x27;s erroneously seen as some kind of &quot;gold standard&quot; by inexperienced developers and non-technical clients, and there seems to be a common misconception that it&#x27;s the only solution that lets users update the content themselves (when in fact that&#x27;s the whole point of ANY CMS). Using Bedrock and a theme system like Sage that supports a proper templating system helps solve some of the problems with Wordpress, but not all.</p><p>I have tried a few solutions that come very close to what I want:</p><ul><li><a href="https://bolt.cm/">Bolt</a> seems from what I&#x27;ve seen so far to be effectively a &quot;better Wordpress&quot; in that the interface and functionality is broadly familiar to anyone already used to Wordpress, but it uses Twig, is built in Symfony, and has a proper command-line runner. I haven&#x27;t tried it since version 4 was released a few days back, so I will probably give it a spin before long.</li><li><a href="https://getgrav.org/">Grav</a> looks like a great solution for brochure sites. I&#x27;ve long thought that these sites, which often run on shared hosting, don&#x27;t really need a database-backed solution, and a flat-file solution is probably a better bet in most cases. Grav is simple to set up and configure, has a decent admin interface, and uses Twig for the views, making it easy to theme.</li><li><a href="https://statamic.com/">Statamic</a> is my current favourite and ticks almost all of the boxes mentioned above. It&#x27;s built on Laravel, and can be added to an existing Laravel site if required. It also allows you access to the full power of the underlying framework if you need it, and ships with a decent front-end boilerplate that includes Tailwind. The only downside compared to Wordpress is that it&#x27;s a paid-for solution, but the price is entirely reasonable, and if it&#x27;s for a client build you&#x27;ll not only save on all the premium plugins you don&#x27;t need, but you&#x27;ll probably save time on the site build.</li></ul><p>Payment shouldn&#x27;t be an issue if you&#x27;re doing client work, unless the cost is huge. You&#x27;re getting paid for building something, and if buying an off-the-shelf product saves you time, it&#x27;s well worth it. Back when Laravel Nova was first released, a lot of people were complaining that it wasn&#x27;t free, but that was neither here nor there - the cost is only equivalent to a few hours of an experienced developer&#x27;s time, and it would take a lot longer to build out the same functionality, and the same is true of any half-decent CMS. In the early days of the web, one company I used to work for sold <a href="http://www.wordserver.co.uk/">a CMS that was considered cheap by the standards of the time</a> at £495, plus £96 a year, for the entry level version - Statamic is significantly cheaper than that.</p><p>It&#x27;s always a good idea to be aware of the various CMS options around. Wordpress isn&#x27;t a great solution and there are plenty of options that are technically better, easier to use, more secure, and work out cheaper when you consider the total cost of ownership. I&#x27;ll probably be favouring Statamic for the foreseeable future when building content-based websites, but that doesn&#x27;t mean I won&#x27;t look elsewhere from time to time.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Flow typed AJAX responses with React Hooks]]></title>
            <link>https://matthewdaly.co.uk/blog/2020/06/13/flow-typed-ajax-responses-with-react-hooks/</link>
            <guid>https://matthewdaly.co.uk/blog/2020/06/13/flow-typed-ajax-responses-with-react-hooks/</guid>
            <pubDate>Sat, 13 Jun 2020 12:50:41 GMT</pubDate>
            <content:encoded><![CDATA[<p>I&#x27;m a big fan of type systems in general. Using Psalm to find missing type declarations and incorrect calls in PHP has helped me out tremendously. However, I&#x27;m not a big fan of Typescript. The idea of creating a whole new language, primarily just to add types to Javascript, strikes me as a fundamentally bad idea given how many languages that compile to Javascript have fallen by the wayside. Flow seems like a much better approach since it adds types to the language rather than creating a new language, and I&#x27;ve been using it on my React components for a good while now. However, there are a few edge cases that can be difficult to figure out, and one of those is any generic AJAX component that may be reused for different requests.</p><p>A while back I wrote the following custom hook, loosely inspired by axios-hooks (but using the Fetch API) to make a query to a GraphQL endpoint:</p><pre><code class="language-javascript" metastring="title=useFetch.js" title="useFetch.js">import { useCallback, useState, useEffect } from &quot;react&quot;;

function useFetch(url, query) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(false)

  const fetchData = useCallback(() =&gt; {
    setLoading(true);
    fetch(url, {
      method: &#x27;POST&#x27;,
      headers: {
        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,
        &#x27;Accept&#x27;: &#x27;application/json&#x27;,
      },
      body: JSON.stringify({query: query})
    }).then(r =&gt; r.json())
      .then((data) =&gt; {
        setData(data.data);
        setLoading(false);
        setError(false);
      });
  }, [url, query]);

  useEffect(() =&gt; {
    fetchData();
  }, [url, query, fetchData]);

  return [{
    data: data,
    loading: loading,
    error: error
  }, fetchData];
};

export default useFetch;
</code></pre><p>When called, the hook receives two parameters, the URL to hit, and the query to make, and returns an array that contains a function for reloading, and an object containing the following values:</p><ul><li><code>loading</code> - a boolean that specifies if the hook is loading right now</li><li><code>error</code> - a boolean that specifies if an error has occurred</li><li><code>data</code> - the response data from the endpoint, or null</li></ul><p>Using this hook, it was then possible to make an AJAX request when a component was loaded to populate the data, as in this example:</p><pre><code class="language-javascript" metastring="title=App.js" title="App.js">import React from &#x27;react&#x27;;
import useFetch from &#x27;./Hooks/useFetch&#x27;;
import marked from &#x27;marked&#x27;;
import &#x27;./App.css&#x27;;

function App() {
  const url = `/graphql`;
  const query = `query {
    posts {
      title
      slug
      content
      tags {
        name
      }
    }
  }`;

  const [{data, loading, error}] = useFetch(url, query);

  if (loading) {
    return (&lt;h1&gt;Loading...&lt;/h1&gt;);
  }

  if (error) {
    return (&lt;h1&gt;Error!&lt;/h1&gt;);
  }

  const posts = data ? data.posts.map((item) =&gt; (
    &lt;div key={item.slug}&gt;
      &lt;h2&gt;{item.title}&lt;/h2&gt;
      &lt;div dangerouslySetInnerHTML={{__html: marked(item.content)}} /&gt;
    &lt;/div&gt;
  )) : [];
  return (
    &lt;div className=&quot;App&quot;&gt;
      {posts}
    &lt;/div&gt;
  );
}

export default App;
</code></pre><p>This hook is simple, and easy to reuse. However, it&#x27;s difficult to type the value of <code>data</code> correctly, since it will be different for different endpoints, and given that it may be reused for almost any endpoint, you can&#x27;t cover <em>all</em> the acceptable response types. We need to be able to specify the response that is acceptable in that particular context.</p><h2>Generics to the rescue</h2><p>Flow provides a solution for this in the shape of <a href="https://flow.org/en/docs/types/generics/">generic types</a>. By passing in a polymorphic type using <code>&lt;T&gt;</code> in the function declaration, we can then refer to that type when specifying what <code>data</code> should look like:</p><pre><code class="language-flow" metastring="title=useFetch.js {4-11}" title="useFetch.js">//@flow
import { useCallback, useState, useEffect } from &quot;react&quot;;

function useFetch&lt;T&gt;(url: string, query: string): [{
  data: ?T,
  loading: boolean,
  error: boolean
}, () =&gt; void] {
  const [data, setData]: [?T, ((?T =&gt; ?T) | ?T) =&gt; void] = useState(null);
  const [loading, setLoading]: [boolean, ((boolean =&gt; boolean) | boolean) =&gt; void] = useState(false);
  const [error, setError]: [boolean, ((boolean =&gt; boolean) | boolean) =&gt; void] = useState(false)

  const fetchData = useCallback(() =&gt; {
    setLoading(true);
    fetch(url, {
      method: &#x27;POST&#x27;,
      headers: {
        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,
        &#x27;Accept&#x27;: &#x27;application/json&#x27;,
      },
      body: JSON.stringify({query: query})
    }).then(r =&gt; r.json())
      .then((data) =&gt; {
        setData(data.data);
        setLoading(false);
        setError(false);
      });
  }, [url, query]);

  useEffect(() =&gt; {
    fetchData();
  }, [url, query, fetchData]);

  return [{
    data: data,
    loading: loading,
    error: error
  }, fetchData];
};

export default useFetch;
</code></pre><p>Then, when calling the hook, we can define a type that represents the expected shape of the data (here called <code>&lt;Data&gt;</code>), and specify that type when calling the hook, as in this example:</p><pre><code class="language-flow" metastring="title=App.js" title="App.js">//@flow
import React from &#x27;react&#x27;;
import useFetch from &#x27;./Hooks/useFetch&#x27;;
import marked from &#x27;marked&#x27;;
import &#x27;./App.css&#x27;;

type Data = {
  posts: Array&lt;{
    title: string,
    slug: string,
    content: string,
    name: Array&lt;string&gt;
  }&gt;
};

function App() {
  const url = `/graphql`;
  const query = `query {
    posts {
      title
      slug
      content
      tags {
        name
      }
    }
  }`;

  const [{data, loading, error}] = useFetch&lt;Data&gt;(url, query);

  if (loading) {
    return (&lt;h1&gt;Loading...&lt;/h1&gt;);
  }

  if (error) {
    return (&lt;h1&gt;Error!&lt;/h1&gt;);
  }

  const posts = data ? data.posts.map((item) =&gt; (
    &lt;div key={item.slug}&gt;
      &lt;h2&gt;{item.title}&lt;/h2&gt;
      &lt;div dangerouslySetInnerHTML={{__html: marked(item.content)}} /&gt;
    &lt;/div&gt;
  )) : [];
  return (
    &lt;div className=&quot;App&quot;&gt;
      {posts}
    &lt;/div&gt;
  );
}

export default App;
</code></pre><p>That way, we can specify a completely different shape for our response data every time we call a different endpoint, without creating a different hook for every different endpoint, and still enjoy properly typed responses from our hook.</p><p>Generics can be useful for many other purposes, such as specifying the contents of collections. For instance, if you had a <code>Collection</code> object, you could use a generic type to specify that any one instance must consist of instances of a given type. Flow would then flag it as an error if you assigned an item of the wrong type to that collection, thus making some unit tests redundant.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Caching the Laravel user provider with a decorator]]></title>
            <link>https://matthewdaly.co.uk/blog/2020/03/11/caching-the-laravel-user-provider-with-a-decorator/</link>
            <guid>https://matthewdaly.co.uk/blog/2020/03/11/caching-the-laravel-user-provider-with-a-decorator/</guid>
            <pubDate>Wed, 11 Mar 2020 21:20:14 GMT</pubDate>
            <content:encoded><![CDATA[<p>A couple of years ago I posted <a href="https://matthewdaly.co.uk/blog/2018/01/12/creating-a-caching-user-provider-for-laravel/">this article</a> about constructing a caching user provider for Laravel. It worked, but with the benefit of hindsight I can now see that there were a number of issues with this solution:</p><ul><li>Because it extended the existing Eloquent user provider, it was dependent on the internals of that remaining largely the same - any change in how that worked could potentially break it</li><li>For the same reason, if you wanted to switch to a different user provider, you&#x27;d need to add the same functionality to that provider, either by writing a new provider from scratch or extending an existing one</li></ul><p>I&#x27;ve used the decorator pattern a few times in the past, and it&#x27;s a good fit for situations like this where you want to add functionality to something that implements an interface. It allows you to separate out one part of the functionality (in this case, caching) into its own layer, so it&#x27;s not dependent on any one implementation and can wrap any other implementation of that same interface you wish. Also, as long as the interface remains the same, there likely won&#x27;t be any need to change it when the implementation that is wrapped changes. Here I&#x27;ll demonstrate how to create a decorator to wrap the existing user providers.</p><p>If we only want to cache the <code>retrieveById()</code> method, like the previous implementation, the decorator class might look something like this:</p><pre><code class="language-php">&lt;?php

namespace App\Auth;

use Illuminate\Contracts\Auth\Authenticatable;
use Illuminate\Contracts\Auth\UserProvider;
use Illuminate\Contracts\Cache\Repository;

final class UserProviderDecorator implements UserProvider
{
    /**
     * @var UserProvider
     */
    private $provider;

    /**
     * @var Repository
     */
    private $cache;

    public function __construct(UserProvider $provider, Repository $cache)
    {
        $this-&gt;provider = $provider;
        $this-&gt;cache = $cache;
    }

    /**
     * {@inheritDoc}
     */
    public function retrieveById($identifier)
    {
        return $this-&gt;cache-&gt;remember(&#x27;id-&#x27; . $identifier, 60, function () use ($identifier) {
            return $this-&gt;provider-&gt;retrieveById($identifier);
        });
    }

    /**
     * {@inheritDoc}
     */
    public function retrieveByToken($identifier, $token)
    {
        return $this-&gt;provider-&gt;retrieveById($identifier, $token);
    }

    /**
     * {@inheritDoc}
     */
    public function updateRememberToken(Authenticatable $user, $token)
    {
        return $this-&gt;provider-&gt;updateRememberToken($user, $token);
    }

    /**
     * {@inheritDoc}
     */
    public function retrieveByCredentials(array $credentials)
    {
        return $this-&gt;provider-&gt;retrieveByCredentials($credentials);
    }

    /**
     * {@inheritDoc}
     */
    public function validateCredentials(Authenticatable $user, array $credentials)
    {
        return $this-&gt;provider-&gt;validateCredentials($user, $credentials);
    }
}
</code></pre><p>It implements the same interface as the user providers, but accepts two arguments in the constructor, which are injected and stored as properties:</p><ul><li>Another instance of <code>Illuminate\Contracts\Auth\UserProvider</code></li><li>An instance of the cache repository <code>Illuminate\Contracts\Cache\Repository</code></li></ul><p>Most of the methods just defer to their counterparts on the wrapped instance - in this example I have cached the response to <code>retrieveById()</code> only, but you can add caching to the other methods easily enough if need be. You do of course still need to flush the cache at appropriate times, which is out of scope for this example, but can be handled by model events as appropriate, as described in the prior article.</p><p>Then you add the new decorator as a custom user provider, but crucially, you need to first resolve the provider you&#x27;re going to use, then wrap it in the decorator:</p><pre><code class="language-php">&lt;?php

namespace App\Providers;

use Illuminate\Support\Facades\Gate;
use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;
use Illuminate\Contracts\Auth\UserProvider;
use Auth;
use Illuminate\Auth\EloquentUserProvider;
use Illuminate\Contracts\Cache\Repository;
use App\Auth\UserProviderDecorator;

class AuthServiceProvider extends ServiceProvider
{
    /**
     * The policy mappings for the application.
     *
     * @var array
     */
    protected $policies = [
        &#x27;App\Model&#x27; =&gt; &#x27;App\Policies\ModelPolicy&#x27;,
    ];

    /**
     * Register any authentication / authorization services.
     *
     * @return void
     */
    public function boot()
    {
        $this-&gt;registerPolicies();

        Auth::provider(&#x27;cached&#x27;, function ($app, array $config) {
            $provider = new EloquentUserProvider($app[&#x27;hash&#x27;], $config[&#x27;model&#x27;]);
            $cache = $app-&gt;make(Repository::class);
            return new UserProviderDecorator($provider, $cache);
        });
    }
}
</code></pre><p>Finally, set up the config to use the caching provider:</p><pre><code class="language-php">    &#x27;providers&#x27; =&gt; [
        &#x27;users&#x27; =&gt; [
            &#x27;driver&#x27; =&gt; &#x27;cached&#x27;,
            &#x27;model&#x27; =&gt; App\Eloquent\Models\User::class,
        ],
    ],
</code></pre><p>This is pretty rough and ready, and could possibly be improved upon by allowing you to specify a particular provider to wrap in the config, as well as caching more of the methods, but it demonstrates the principle effectively.</p><p>By wrapping the existing providers, you can change the behaviour of the user provider without touching the existing implementation, which is in line with the idea of composition over inheritance. Arguably it&#x27;s more complex, but it&#x27;s also more flexible - if need be you can swap out the wrapped user provider easily, and still retain the same caching functionality.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[The trouble with integrated static analysis]]></title>
            <link>https://matthewdaly.co.uk/blog/2020/02/12/the-trouble-with-integrated-static-analysis/</link>
            <guid>https://matthewdaly.co.uk/blog/2020/02/12/the-trouble-with-integrated-static-analysis/</guid>
            <pubDate>Wed, 12 Feb 2020 22:40:15 GMT</pubDate>
            <content:encoded><![CDATA[<p>I&#x27;ve always been a big fan in general of tools that provide feedback about the quality of my code. The development role in which I spent the most time was one in which I had no peer feedback or mentoring at all, and while I could definitely have done with more peer review than I had, automated tools helped fill the gap a little bit. When I started building my first Phonegap app, about a year after I started programming professionally, it used <em>far</em> more Javascript than I&#x27;d ever used before, and JSLint was very helpful in instilling good practices at that early stage in my career.</p><p>In addition, I often find that using an automated tool largely eliminates the issue of ego - if your colleague Bob tells you something is a bad practice, you can potentially dismiss it as &quot;That&#x27;s just Bob&#x27;s preferences&quot;, whereas an automated tool is potentially much more objective. Nowadays, my typical set of static analysis tools on a project includes:</p><ul><li>ESLint</li><li>Flow</li><li>PHP CodeSniffer</li><li>Psalm</li></ul><p>However, I&#x27;m always dubious of using any static analysis tool that&#x27;s tightly integrated with a particular editor or IDE. In this post, I will explain my reasoning.</p><h2>In-editor feedback</h2><p>Having instant feedback on the quality of your code is tremendously useful. Sure, you can run something like CodeSniffer from the command line and see what the problems are, but that&#x27;s nowhere near as useful as having it actually <em>in</em> your code. If you work on a legacy code base, there&#x27;s no way in hell you can wade through a long list of output in the terminal and fix them without losing the will to live. By comparison, actually seeing something flagged as an error where it actually occurs makes the mental cost of fixing it much smaller - you can see it in context, and can usually therefore resolve it more easily.</p><p>However, that doesn&#x27;t explicitly require that any one tool form an integral part of the editor. Most editors can hand off linting and static analysis to other, standalone tools, and doing so offers the following advantages:</p><ul><li>Less dependence on a given development environment - it&#x27;s always a struggle if you wind up stuck using a development environment you dislike (I grew to utterly despise Netbeans in my first role), but if you can use generic feedback tools that can be integrated with just about any editor, your team can use the development environment that suits them most, while still all benefiting from the feedback these tools provide</li><li>These tools tend to be open source, meaning you have the security of knowing that if the creator ceases maintaining it, either someone else may pick up the baton, or you can choose to fork it yourself. If a commercial IDE provider ceases trading, it&#x27;s likely you won&#x27;t be able to use their offering at all at some point in the future.</li></ul><p>Nowadays I use vim-ale in Neovim, and that provides real-time feedback for a number of linters and static analysis tools, including all those I mentioned above. I have comprehensive information on any issues in my code, and because any configuration is in simple text files that form part of the repository, it&#x27;s easy to update those settings for all developers working on the project to ensure consistency.</p><p>It&#x27;s possible that an integrated solution <em>might</em> offer a few advantages in terms of tighter integration with autocompletion and other functionality allowing for it, but whether they outweigh the tradeoffs mentioned here is dependent entirely on the implementation and how useful it is for any one team.</p><h2>Continuous integration to the rescue</h2><p>There&#x27;s another issue I have with this sort of tightly integrated static analysis, which is probably the biggest, and that is that the feedback is available only at the level of an individual developer, not the team.</p><p>It&#x27;s great providing all this feedback to developers, but what if they just ignore it? Not all developers have had the sort of experience that leads one to really appreciate the value of coding standards and type hints, particularly if they&#x27;ve worked primarily on small or greenfield projects, or in environments where the emphasis was on churning out large quantities of work, and getting developers to tidy up the sort of issues these tools identify can sometimes be a tough sell when faced with code which, at least superficially, works.</p><p>Suppose you take on a new developer and ask them to work alone on a particular project for several months. Due to your own workload you can&#x27;t easily schedule code reviews with them, so you don&#x27;t see what they&#x27;re writing until they&#x27;re done. Then you take a look at what they&#x27;ve written and it&#x27;s full of issues that the IDE caught, but the developer either didn&#x27;t bother to fix, or didn&#x27;t know how to. What they&#x27;ve done may well work, but they&#x27;ve introduced a huge morass of technical debt that will slow down future development for the foreseeable future.</p><p>If your static analysis tools work only in the context of a given editor or IDE, then if the new dev introduce issues in the code base and doesn&#x27;t resolve them because they don&#x27;t know how, or don&#x27;t see the value, then the first you knows about it is when you clone the repo yourself and open it up. With a solution that runs in a CI environment, you can catch any reduction in code quality when it&#x27;s pushed. Sure, code reviews can do that too, but that requires manual input in a way that not every team is willing to spare, whereas a CI server, once set up, is largely self sustaining. And you could run one tool locally and another in a CI environment, but you can&#x27;t be sure they&#x27;ll necessarily catch all the same issues.</p><p>Now consider the same scenario if you&#x27;re using a separate code quality tool that&#x27;s integrated both into the editor, and your continuous integration workflow. Obviously, it will depend on your personal CI setup, but once code quality either begins to drop, or drops below a given level, the CI server will mark the build as failed, and you&#x27;ll be alerted. You can therefore then raise the issue with the new dev before it gets out of hand, and provide whatever support they need to resolve the problem there and then.</p><p>I personally maintain a legacy project in which, at one point prior to my arrival, a junior dev introduced an enormous amount of technical debt after working on it alone for six months. An integrated linter or static analysis tool probably wouldn&#x27;t have stopped that from happening, for the reasons stated above, but if a similar tool were part of the CI workflow, it could have been flagged as an issue much earlier and dealt with. Yes, leaving a junior dev unsupported and unsupervised for that length of time isn&#x27;t a great idea, but it happens, particularly in busy environments such as agencies. A good CI setup lets you see if someone is adding these kinds of issues, and act to nip it in the bud before it becomes too much of a problem, which is ultimately good for that developer&#x27;s career.</p><p>Peer pressure can also be a strong motivating factor under these circumstances. By simply displaying a metric, you encourage people&#x27;s natural competitiveness, so displaying code quality stats in your CI dashboard will encourage your team to do better in this regard, and no-one wants to be visibly seen to be letting the team down by producing substandard code.</p><p>For these reasons, where possible for feedback on code quality, I would always prefer to rely on a standalone tool that can be integrated with an editor, or used as part of a continuous integration workflow, as opposed to any IDE-specific functionality.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Don't use stdClass]]></title>
            <link>https://matthewdaly.co.uk/blog/2020/02/09/dont-use-stdclass/</link>
            <guid>https://matthewdaly.co.uk/blog/2020/02/09/dont-use-stdclass/</guid>
            <pubDate>Sun, 09 Feb 2020 10:10:48 GMT</pubDate>
            <content:encoded><![CDATA[<p>The digital agency I work for specialises in marketing, so some of my work tends to relate to mailing lists. This week I was asked to look at an issue on a Laravel-based export system built by a co-worker who left a few months ago. This particular application pulled data from the Campaign Monitor API about campaigns, and it returned the data as instances of <code>stdClass</code>, something that I&#x27;m not terribly happy about.</p><p>Now, this was an implementation detail of the Campaign Monitor PHP SDK, which is old and creaky (to say the least...) and doesn&#x27;t exactly abide by modern best practices. However, the legacy application I maintain also does this (there&#x27;s a <em>lot</em> of stuff that needs sorting out on it, and sadly replacing the <code>stdClass</code> instances is a <em>long</em> way down the list), so I thought it was an interesting subject for a blog post. I consider using <code>stdClass</code>, even just as a dumb container for data, to be an antipattern, and I thought it would be useful to explain my thoughts on this.</p><h1>Why shouldn&#x27;t I use stdClass?</h1><h2>Readability</h2><p>One of the first things I learned about throwing exceptions is that they should be meaningful. It&#x27;s trivial to define a named exception and use that to specify the type of exception, and you can then capture exceptions to handle them differently elsewhere in the application. For instance, a validation error is entirely due to a user submitting the wrong details, and should therefore be handled in an entirely different manner to the database going down.</p><p>The same is applicable to an object. If an API client returns an instance of <code>stdClass</code>, that doesn&#x27;t tell me anything about what that object is. If I need to pass it elsewhere in a large application, it may become very difficult to understand what it represents without tracking it back to where it came from, which will slow me down. If instead I use a named class, the name can convey what it represents. It may seem like overkill to create a class that adds no new functionality, but the mere fact that it has a name makes your code more meaningful and easier to understand. I can also add DocBlock comments to describe it further.</p><p>Of course, just giving something a generic name like <code>Container</code> isn&#x27;t much of an improvement, and coming up with meaningful names for classes and methods is notoriously hard. As always, give some serious thoughts into what your objects represent and attempt to give them names that will make it easy to understand what they are if you look at the code base again six months down the line.</p><h2>Type hinting</h2><p>A related argument is that it makes type hinting more useful. You <em>can</em> type hint <code>stdClass</code>, but as noted above it tells someone working on the code receiving it very little about where it&#x27;s come from, or what it represents, and it doesn&#x27;t offer much value since an <code>stdClass</code> could mean anything, and could be created anywhere in the application.</p><p>By contrast, named classes provides much more information about what the type hinted parameter represents. For instance, naming your class something such as <code>App\Api\Response\Item</code>, makes it much clearer that that object represents an individual item returned from an API, and others developers working on the same code base (including your future self, who may not necessarily remember all of the details of how you&#x27;re implementing it now), will have less trouble understanding what is going on. There&#x27;s also a much-reduced likelihood of the same class being used to represent completely different types of data.</p><h2>New functionality</h2><p>Finally, are you sure you don&#x27;t want to add any functionality? PHP includes a number of interfaces that can be <em>extremely</em> useful for working with this sort of data.</p><p>First off, the <code>ArrayAccess</code> interface allows you to access an object&#x27;s values using array syntax, which can be useful. Also, implementing either <code>Iterator</code> or <code>IteratorAggregate</code> will allow you to iterate over the object using a <code>foreach</code> loop. The <code>Countable</code> interface is less useful, since all it does is let you get the number of items, but it&#x27;s sometimes handy. Finally, the <code>Serializable</code> interface lets you serialise an object so it can be stored in a suitable medium, which can sometimes be useful.</p><p>The same also applies to some of the magic methods. The <code>__toString()</code> method, in particular, can be useful for returning a suitable string-based representation of an object - for instance, if it represents an item in a database, it might be appropriate to use this to return the ID of the item, or a text representation of it (eg title for a blog post, or product name for a product in an e-commerce site). The <code>__get()</code> and <code>__set()</code> magic methods may be a bit more dubious, but they can be useful if your object is intended to just be a dumb container as they allow you to make the properties on the object private, but keep them accessible without writing explicit getters and setters. I&#x27;d also suggest adding <code>__debugInfo()</code> to objects unless you have a good reason not to, as when you&#x27;re debugging it can be hard to see the wood for the trees, and returning only the most pertinent data can make your job a <em>lot</em> easier.</p><p>Of course, you don&#x27;t have to implement all this functionality from scratch for every class. It often makes sense to create an abstract class that implements this sort of basic container functionality, and then base all your container classes on that, overriding it when necessary.</p><h2>Summary</h2><p>Hopefully, this has made it clear how compelling it is to use named classes instead of <code>stdClass</code>, and how much benefit you can get from not just using named classes, but creating your own base container class for them. I&#x27;m of the opinion that PHP should probably make <code>stdClass</code> abstract to prevent them from being used like this, and indeed I&#x27;m seriously considering the idea of creating a Codesniffer sniff to detect instances of <code>stdClass</code> being instantiated and raise them as an error.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[F*** PHPStorm Man and the high horse he rode in on]]></title>
            <link>https://matthewdaly.co.uk/blog/2020/01/25/f***-phpstorm-man-and-the-high-horse-he-rode-in-on/</link>
            <guid>https://matthewdaly.co.uk/blog/2020/01/25/f***-phpstorm-man-and-the-high-horse-he-rode-in-on/</guid>
            <pubDate>Sat, 25 Jan 2020 22:25:17 GMT</pubDate>
            <content:encoded><![CDATA[<p>There&#x27;s a particularly unpleasant type of programmer that exists, and you&#x27;ve probably met him, either online or in person. I call him <strong>PHPStorm Man</strong>.</p><p>NB: Despite the name I&#x27;ve chosen, I&#x27;m not singling out users of PHPStorm in particular about this. The first time I encountered PHPStorm Man in person, he was using Sublime Text, and you will find PHPStorm Men using all different editors and IDEs. PHPStorm Man is an archetype defined not by any particular piece of software, but by a common bad attitude, and given that I work primarily with PHP these days, I&#x27;ve most often encountered this kind of behaviour from PHPStorm users (or at least, people claiming to be PHPStorm users, since at least online you can&#x27;t discount the possibility that they&#x27;re trolls). Users of other languages may well see this behaviour most prominently from those who use some other editor or IDE, but the same underlying phenomenon is at work, whether we call him PHPStorm Man, Eclipse Man, Vim Man or PyCharm Man.</p><h2>Who is PHPStorm Man?</h2><p><span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:500px">
      <a class="gatsby-resp-image-link" href="/static/46cecd87a02e7a18e776a2b1243624cf/41099/phpstorm-man.jpg" style="display:block" target="_blank" rel="noopener">
    <span class="gatsby-resp-image-background-image" style="padding-bottom:64.66666666666666%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIFAwT/xAAUAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAGb0S91QQD/xAAaEAACAgMAAAAAAAAAAAAAAAABAgADEBIi/9oACAEBAAEFAqWAhKPYw6E3OP/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABwQAAIABwAAAAAAAAAAAAAAAAABAhESIEJhgf/aAAgBAQAGPwLFt6JxU8GrP//EABsQAQEBAAIDAAAAAAAAAAAAAAERABBBYZGh/9oACAEBAAE/IS4+Qp05IkfnKUDGUyjgOj1x/9oADAMBAAIAAwAAABCv7//EABcRAQADAAAAAAAAAAAAAAAAAAEQESH/2gAIAQMBAT8QHKj/xAAXEQEBAQEAAAAAAAAAAAAAAAABABEh/9oACAECAQE/EBA7bf/EABoQAQADAQEBAAAAAAAAAAAAAAEAETEhUYH/2gAIAQEAAT8QbBkFd9eHyC+hVUNtGkOmkNlusgNTGNmwrl0Fr32L1fez/9k=&#x27;);background-size:cover;display:block"></span>
  <img class="gatsby-resp-image-image" alt="The hero we really, really don&#x27;t need" title="The hero we really, really don&#x27;t need" src="/static/46cecd87a02e7a18e776a2b1243624cf/41099/phpstorm-man.jpg" srcSet="/static/46cecd87a02e7a18e776a2b1243624cf/f93b5/phpstorm-man.jpg 300w,/static/46cecd87a02e7a18e776a2b1243624cf/41099/phpstorm-man.jpg 500w" sizes="(max-width: 500px) 100vw, 500px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0" loading="lazy" decoding="async"/>
  </a>
    </span></p><p>PHPStorm Man (and he <em>will</em> almost certainly be a man - while it could be just because our industry is male-dominated, I&#x27;ve <em>never</em> known a woman to behave like this, and I strongly suspect it&#x27;s nothing more than an industry-specific example of the common phenomenon of <a href="https://en.wikipedia.org/wiki/Mansplaining">mansplaining</a>) doesn&#x27;t know squat about your editor or IDE. He just knows his is superior, and he wants you to know it, regardless of the evidence.</p><p>His knowledge of your editor is probably either non-existent, grossly outdated, plain ill-informed or second-hand (probably from another PHPStorm Man). If he&#x27;s advocating an IDE, he&#x27;ll likely equate all text editors with Notepad - he may claim the advantages of his one over yours include such fundamentals as syntax highlighting and autocompletion.</p><p>He&#x27;ll boast about some feature his editor has that yours doesn&#x27;t, even if it does. If your editor lacks that functionality out of the box, but can add it via a plugin, apparently that doesn&#x27;t count because although you&#x27;re intelligent enough to build a working web app, somehow installing and configuring that plugin is an insurmountable burden (yet mysteriously turning off all the stuff you don&#x27;t need in <em>his</em> editor is quick and easy). If it does do that out of the box, he&#x27;ll probably find some bullshit reason why his editor&#x27;s implementation is better, even if it&#x27;s something as pointless and irrelevant as &quot;it&#x27;s been around longer&quot;. He&#x27;ll likely claim, with absolutely no evidence whatsoever, or indeed in the presence of evidence to the contrary, that you&#x27;d be more productive if you only used his editor.</p><p>In short, if you aren&#x27;t using his editor or IDE of choice, you&#x27;re a troglodyte living in a dung hut.</p><h2>PHPStorm man in the wild</h2><p>I had an encounter with PHPStorm Man in person a while back. Just over two years ago I started a new job, which as it turned out didn&#x27;t last long after I caught the flu that was going around in late 2017 my first week. On the second day, shortly after going over something with me, the senior dev sent me the following message on Slack:</p><blockquote><p>I noticed you&#x27;re using Vim. Have you tried using Sublime Text?</p></blockquote><p>I responded that I had, and chose not to use it. There followed a long string of messages along the following lines:</p><blockquote><p>Him: Sublime Text has X!</p></blockquote><blockquote><p>Me: I have that</p></blockquote><blockquote><p>Him: Well Sublime Text also has Y!</p></blockquote><blockquote><p>Me: I have that too, via a plugin</p></blockquote><blockquote><p>Him: Well, Sublime Text doesn&#x27;t need a plugin for that</p></blockquote><blockquote><p>Me: Irrelevant since the plugin is already installed and configured, and I know how to use it</p></blockquote><blockquote><p>Him: Well, what about this?</p></blockquote><blockquote><p>Me: That sounds cool, so I just found a plugin to do that and installed it</p></blockquote><blockquote><p>Him: And this?</p></blockquote><blockquote><p>Me: I have absolutely no need for that</p></blockquote><blockquote><p>Him: Well, Vim is old, Sublime Text is new!</p></blockquote><blockquote><p>Me: Actually, this is Neovim, which is technically newer than Sublime Text</p></blockquote><blockquote><p>Him: Well, Sublime Text is a GUI application</p></blockquote><blockquote><p>Me: Exactly. That makes it slower and forces me to use the mouse, aggravating my RSI. I use the terminal because it&#x27;s more efficient</p></blockquote><blockquote><p>Him: Well, I don&#x27;t mind what you use...(despite the evidence of that entire conversation)</p></blockquote><p>With the benefit of hindsight, what I <em>should</em> have responded with was this:</p><blockquote><p>I&#x27;m an experienced, professional web developer of over six years, and I chose my editor based on years of personal experience, and have chosen my plugins and configuration based on what&#x27;s useful to me, and continue to do so to this day. I don&#x27;t appreciate you talking down to me like a child.</p></blockquote><h2>Why I personally don&#x27;t use an IDE</h2><p>In my case, I have a particularly good reason not to use <em>any</em> GUI application to develop in. Before I was a developer, I worked for an insurance company in a customer service role, and I didn&#x27;t have access to the sort of decent quality keyboards and mice developers habitually use, as well as having output goals linked to discipline and bonus/salary raises and having to use custom internal applications on Windows XP, with dreadful keyboard support. As a result I developed a degree of RSI in both hands, which I&#x27;ve found is aggravated by using any application that requires me to use a mouse extensively - I&#x27;m generally OK if I only have to type, but reaching for the mouse all the time quickly becomes tiring, and soon after painful.</p><p>For that reason I&#x27;ve developed a workflow that&#x27;s strongly dependent on the command line - I use Neovim in the terminal, alongside Byobu so that I can run multiple tabs and switch between them quickly without touching the mouse. Moving to a more GUI-oriented workflow would require me to use the mouse more than I do now, which would probably become physically painful quite quickly. Using an editor or IDE which I found made me more prone to further flare-ups of RSI could have serious consequences for my long-term health, and could potentially be career-ending. If I worked somewhere that mandated a particular IDE that didn&#x27;t work well for me, I&#x27;d <em>have</em> to either negotiate an exception on health and safety grounds or quit.</p><p>I&#x27;m also of the personal opinion that much of the functionality of an IDE should not be, in principle, tied to that IDE, but should instead be the province of more general purpose tools that can used, not merely in any editor or IDE but, where appropriate, on a continuous integration server. For instance, language servers provide a tool-agnostic way for any IDE or editor to implement functionality such as completion or navigation, and linters such as ESLint can integrate into any half-decent editor or run in a CI environment. Since these tend to be open source projects, whereas IDE&#x27;s are normally commercial offerings, they&#x27;re less vulnerable to suddenly disappearing and leaving users high and dry.</p><p>There&#x27;s also a lot of functionality in an IDE that I rarely, if ever, use. There&#x27;s no point including and starting up an FTP client as part of my editor if I&#x27;m never going to use it, as it slows the application down, and nor should I have to root around trying to turn off functionality I&#x27;m never going to have to use. For a lot of other functionality, there are more powerful standalone applications that I&#x27;m used to such as Postman or MySQL Workbench, and I&#x27;ll use them as and when I need them - I gain nothing by having them integrated with my editor.</p><p>I also like to be able to use the same editor everywhere. I still occasionally dabble in Python, so a language-specific IDE wouldn&#x27;t be suitable when switching between languages. I also sometimes work on personal projects on an HP Stream netbook running Xubuntu, which is fine for small PHP projects that don&#x27;t require a database server or any web server other than the PHP dev server. I can happily run Neovim on that, but there&#x27;s no way it could run an IDE at an acceptable speed.</p><p>Last of all, screen real estate is an issue. I don&#x27;t like interfaces that are too busy - I <em>cannot stand</em> having anything, <em>at all</em> on my desktop for any length of time at all, and any interface that has too much on screen at once is distracting. I will typically have Neovim open in a terminal, with the NERDTree file finder open on the left, and two panels split in the main body, and that&#x27;s all. A big factor in my productivity is how much code I can see at once, and having too much screen real estate taken up by menus and sidebars is counterproductive - with Neovim there&#x27;s almost nothing getting in the way.</p><p>I personally have had to give this sort of explanation many, many times as to why I use first Vim and then Neovim, and indeed part of the motivation behind writing this post is that I&#x27;m sick to death of having to explain myself over and over again and will now be able to merely direct them to this article. Thanks to tools like PHPActor, vim-ale and FZF, I don&#x27;t feel like there&#x27;s anything I&#x27;m missing out on that an IDE would give me, and Psalm is very good at catching type errors without being tied to any one IDE, but that doesn&#x27;t stop people telling me I&#x27;m missing out on features I already have. Any time I come across a feature I think is cool, I go through the following process:</p><ul><li>Find cool feature</li><li>Find plugin that implements said feature</li><li>Install plugin by adding a single line to my Neovim config and running <code>:PlugUpdate</code></li><li>Add a few lines of config</li><li>Start using feature</li></ul><p>Using an IDE <em>would</em> eliminate the middle three steps, but I don&#x27;t find those onerous - we&#x27;re talking about the work of five minutes, which is insignificant compared to the time taken to learn to use the feature effectively. And a feature you don&#x27;t use is one that you still have to start up if it&#x27;s present, so making it an opt-in plugin is often a better way to go.</p><p>Every other developer will have their own version of this story. Some will have stayed mostly static in their editor choices, while others will be changing all the time - indeed, I&#x27;ve sometimes used other editors for specific tasks in the past. In short, everyone has their own reasons for using their editor of choice, and it&#x27;s <em>appallingly</em> arrogant to assume that their reasons for using a particular one are less valid than yours.</p><h2>Am I PHPStorm Man?</h2><p>As I&#x27;ve said before, this behaviour is not confined to PHPStorm users, nor is it in any way universal among them. If you use PHPStorm and enjoy it, then fine, rock on. If you use a different editor or IDE, then that&#x27;s fine too - I don&#x27;t have a problem with that, and nor should your colleagues or line manager. Using any one editor or IDE <em>does not</em> make you PHPStorm Man. What makes you PHPStorm Man is the patronising attitude.</p><p>In the example given above, what made the senior dev PHPStorm Man was not the initial enquiry as to whether I&#x27;d tried Sublime Text, but the fact that he wouldn&#x27;t leave it be when confronted with evidence that I either had, could easily obtain, or didn&#x27;t need the functionality of his editor in mine, and that he was talking down to an experienced developer like a child.</p><p>Obviously, this isn&#x27;t a new development - editor wars have long been a feature of our industry, as has the divide between IDE and editor users. But that doesn&#x27;t mean I, and no doubt others, don&#x27;t get utterly sick of it.</p><h2>How not to be PHPStorm Man</h2><p>When talking to users of other editors or IDE&#x27;s about the subject of those tools, you should always bear this in mind:</p><ul><li>If they use a different tool to you, they probably know a hell of a lot more about it than you do, and are unlikely to take kindly to you ignorantly telling them what it can and can&#x27;t do</li><li>Mastering an editor or IDE can take years, and if they&#x27;re already invested in one, it&#x27;s incredibly arrogant to just assume that they&#x27;re less productive in it than they would be in yours - even if they would (and that&#x27;s almost certainly debatable), it would take some time to adjust.</li><li>They&#x27;ve probably had this conversation many times before, and are sick of hearing it, especially if they have a few years experience under their belt</li><li>Not every feature you use is useful to them</li><li>No-one minds seeing a cool feature, so feel free to demonstrate it, but bear in mind that it&#x27;s almost certainly not limited to that platform - if it&#x27;s sufficiently cool, someone <em>will</em> have made it available as a plugin on most of the major editors and IDE&#x27;s. If they like it, the most likely scenario is that they&#x27;ll look to add that feature to their own editor via a plugin</li><li>Just because it makes you more productive, doesn&#x27;t mean that it would make them more productive</li><li>It&#x27;s perfectly possible to enforce consistent code styles and catch errors using standalone tools such as PHP CodeSniffer, Psalm, or ESLint, and these tools can be integrated in <em>any</em> editor, triggered with Git hooks, or run with continuous integration.</li></ul><p>Now, it has to be said that sometimes there <em>are</em> some people who plod on with painfully outdated tools, like Notepad. But those tools tend to be limited to either commercial offerings that are no longer maintained or supported, or ones that lack any sort of plugin or extension system, making them limited in terms of how they can integrate with other services, so they&#x27;re fairly easy to spot. However, making a particular editor or IDE compulsory is going to be disruptive. If you&#x27;re in a leadership position, one way to resolve this is to simply require that everyone&#x27;s editor have certain functionality - for instance, if you specify that everyone&#x27;s editor must allow integration with PHP CodeSniffer and support for <code>.editorconfig</code>, then anyone using a legacy editor that can&#x27;t support those will need to move away from it, but they&#x27;ll be able to pick one that suits them, rather than be forced into one they may well dislike. Editors and IDE&#x27;s don&#x27;t produce proprietary formats the way word processors do - they work with common formats, and if prominent open-source projects can enforce a consistent coding standard with many different editors there&#x27;s absolutely no reason why your colleagues can&#x27;t do so too.</p><h2>Summary</h2><p>This post is a bit of an angry rant, but at the same time it shouldn&#x27;t be taken <em>too</em> seriously. As I said, despite the name <em>PHPStorm Man</em>, it&#x27;s not specifically about users of any one editor or IDE, but about the widespread, patronising attitude many developers have about editors and IDE&#x27;s other than their own in general.</p><p>Someone using a different IDE or editor is absolutely none of your business unless you&#x27;re their line manager or you work on the same code base, and even then it should only be an issue if it causes a clear effect on their productivity or the quality of their code. If that&#x27;s not the case, keep your nose out.</p>]]></content:encoded>
        </item>
    </channel>
</rss>